<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>链表环-快慢指针的数学原理</title>
    <url>/2020/10/09/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>设<strong>快指针</strong>与<strong>慢指针</strong>距离$d$格，快指针每次移动2格，满指针每次移动1格。当两个指针都进入环后，那么相遇时有：</p>
<script type="math/tex; mode=display">
d+n=2n,可推出: d=n, d小于等于环的长度。</script><p>此方程有界。<strong>故若链表中存在环，那么快慢指针必定会相遇。</strong></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL四种隔离级别</title>
    <url>/2020/09/12/mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><ul>
<li>未提交读：READ UNCOMMITTED</li>
<li>提交读：READ COMMITTED</li>
<li>可重复读（默认）：REPEATABLE READ</li>
<li>可序列化：SERIALIZABLE</li>
</ul><a id="more"></a>
<p>设置隔离级别：<code>set session transaction isolation level read uncommitted;</code></p>
<h3 id="未提交读（read-uncommitted）"><a href="#未提交读（read-uncommitted）" class="headerlink" title="未提交读（read uncommitted）"></a>未提交读（read uncommitted）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line"><span class="comment"># 会话一</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment"># 如果执行回滚</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话二</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 会看到已经更改的name，发生脏读</span></span><br><span class="line"><span class="comment"># 如果会话一的事务回滚，再执行。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 会发现name恢复原值</span></span><br></pre></td></tr></table></figure>
<p>发生<strong>脏读</strong></p>
<h3 id="提交读（read-committed）"><a href="#提交读（read-committed）" class="headerlink" title="提交读（read committed）"></a>提交读（read committed）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line"><span class="comment"># 会话一</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment"># 提交事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话二</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 无法看到会话一修改后的name</span></span><br><span class="line"><span class="comment"># 如果会话一的事务提交，再执行。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 会发现name的值发生更改。得到两次不同的结果</span></span><br></pre></td></tr></table></figure>
<p>可以避免<strong>脏读</strong>，但是发生<strong>不可重复读</strong></p>
<h3 id="可重复读（repeatable-read）"><a href="#可重复读（repeatable-read）" class="headerlink" title="可重复读（repeatable read）"></a>可重复读（repeatable read）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"><span class="comment"># 会话一</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment"># 提交事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话二</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;  <span class="comment"># 开启事务</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 无法看到会话一修改后的name</span></span><br><span class="line"><span class="comment"># 如果会话一的事务提交，再执行。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 无法看到会话一修改后的name</span></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment"># 提交事务后再查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 会发现name的值发生更改</span></span><br></pre></td></tr></table></figure>
<p>可以避免<strong>脏读</strong>和<strong>不可重复读</strong>，但是无法避免<strong>幻读</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"><span class="comment"># 会话一</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;  <span class="comment"># 6行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'hhh'</span>; <span class="comment"># 等待会话一的事务提交后，执行。</span></span><br><span class="line"><span class="comment"># 出现：7 rows affected</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话二</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;  <span class="comment"># 6行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span> (... ...); <span class="comment"># 插入一行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>发生<strong>幻读</strong>（即出现了新的数据）</p>
<h3 id="可串行化（serializable）"><a href="#可串行化（serializable）" class="headerlink" title="可串行化（serializable）"></a>可串行化（serializable）</h3><p>事务的串行执行。即一个事务提交后，另一个事务的操作才能执行，否则发生阻塞。</p>
]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2020/07/23/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><ul>
<li>基本类型：<code>byte, short, int, long, float, double, boolean, char</code></li>
<li>引用类型：<code>String, 类</code></li>
</ul><a id="more"></a>
<p>注：</p>
<ol>
<li>整数常量默认int型</li>
<li>对long型常量末尾加<code>l</code>或<code>L</code></li>
<li>浮点数常量默认double型</li>
<li>对float型常量末尾加<code>f</code>或<code>F</code></li>
<li>char赋值不能为空(String可以为””):<code>Error: char c = &#39;&#39;;</code></li>
<li>大转小-位截断</li>
</ol>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(object e: object[])&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><h3 id="4种访问权限修饰符"><a href="#4种访问权限修饰符" class="headerlink" title="4种访问权限修饰符"></a>4种访问权限修饰符</h3><ul>
<li>private：私有的，只有类的内部可访问</li>
<li>缺省的：与private相比，多了同一个包。</li>
<li>protected：保护的，与缺省的相比，多了一个不同包的子类</li>
<li>public：公有的，整个工程。</li>
</ul>
<p>范围：类内部&lt;同一个包&lt;不同包&lt;工程范围(private&lt;缺省&lt;protected&lt;public)。<em>不同包可以创建相同的类不冲突</em>。<br>修饰类的成员：变量、方法<br>类的修饰：缺省和public</p>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><ul>
<li>package关键字：申明java文件的包名或路径，”xxx.xxx.xxx”每一个“.”代表分了一层目录。同一个包下，不能有相同的接口和类</li>
<li>import关键字：导包必须，显示导入类或接口</li>
</ul>
<p><code>import static</code> 导入类或接口中的静态结构：属性或方法</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">public</span> | <span class="keyword">private</span> | <span class="keyword">protected</span>] classname (参数列表)&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：<strong>类有默认无参构造器，构造器可以重载，一旦显式提供构造器后，默认无参构造器不再有效</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this 调用构造器</span></span><br><span class="line"><span class="keyword">this</span>()  <span class="comment">// 只能放在首行</span></span><br><span class="line"><span class="comment">// 用于多个构造器的重载</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>重载</strong>：更改同名函数的参数个数和类型实现重载。</li>
</ul>
<h3 id="继承-Inherit"><a href="#继承-Inherit" class="headerlink" title="继承(Inherit)"></a><strong>继承</strong>(<strong>Inherit</strong>)</h3><ol>
<li>子类拥有父类的<strong>非private方法和属性</strong></li>
<li>子类可以<strong>重写</strong>父类的方法</li>
<li>只能<strong>单继承</strong></li>
<li>提高了类间的耦合性</li>
<li>子类使用<strong>super构造器</strong>调用父类结构：属性和方法。</li>
<li>所有类缺省继承lang包下的Object类。</li>
<li><strong>同名变量的搜寻，就近原则</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;  <span class="comment">// 只有非私有属性，方法被继承</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String major;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, age, String major)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>在子类中对继承的类中的方法进行改造（重写）并覆盖。</p>
<ol>
<li>重写的方法修饰符权限 &gt;= 父类中被重写的方法权限</li>
<li>不能重写private修饰的父类方法</li>
<li>两者的返回值要么都是void或都相同，<strong>要么重写的方法返回值类型是父类中被重写方法的子类</strong>，基本类型必须相同。</li>
<li>子类重写的方法抛出的异常类型不大于父类中被重写的方法抛出的异常类型</li>
<li>static方法不可被重写</li>
</ol>
<p>同名属性优先使用子类属性，或使用super关键字调用父类属性。<strong>子类会默认调用父类的super()空参构造器</strong>，一个类的构造器首行只能是super()或this()。</p>
<h4 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h4><ol>
<li>子类继承父类后，获取了父类中所有的属性和方法。</li>
<li>子类创建过程中，直接或间接的通过super关键字调用了父类的构造器。</li>
<li>只是调用父类的构造器，并没有创建父类的实例</li>
</ol>
<h3 id="多态-Polymorphic"><a href="#多态-Polymorphic" class="headerlink" title="多态(Polymorphic)"></a><strong>多态</strong>(<strong>Polymorphic</strong>)</h3><ol>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
<li>（向上转型）使用多态方式调用方法时，首先检查父类中是否有该方法，没有则编译错误；如果有，再去调用子类的同名方法</li>
<li><strong>运行时行为</strong></li>
<li>虚方法，动态绑定，运行时才确定方法，晚绑定</li>
</ol>
<p>多态的实现方式：</p>
<ul>
<li>有继承</li>
<li>有重写</li>
<li>接口</li>
<li>抽象方法和抽象类</li>
</ul>
<h4 id="向上转型与向下转型（多态性）"><a href="#向上转型与向下转型（多态性）" class="headerlink" title="向上转型与向下转型（多态性）"></a>向上转型与向下转型（多态性）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Father f = <span class="keyword">new</span> Son();   <span class="comment">// 向上转型，**子类结构已经加载到内存**</span></span><br><span class="line"></span><br><span class="line">Son s = (Son)f;         <span class="comment">// 向下转型</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Animal a1 = <span class="keyword">new</span> Bird(); <span class="comment">// 向上转型</span></span><br><span class="line">Animal a2 = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">System.out.println(a1 <span class="keyword">instanceof</span> Animal);   <span class="comment">// true</span></span><br><span class="line">System.out.println(a1 <span class="keyword">instanceof</span> Bird);     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Bird b1 = (Bird) a1;    <span class="comment">// 向下转型，**内存上是地址的改变** [class@address]</span></span><br><span class="line">System.out.println(b1 <span class="keyword">instanceof</span> Animal);  <span class="comment">// true</span></span><br><span class="line">System.out.println(b1 <span class="keyword">instanceof</span> Bird);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">Object ob = <span class="keyword">new</span> Bird();</span><br><span class="line">Animal a = (Animal)ob;</span><br><span class="line"><span class="comment">// **错误**的向下转型</span></span><br><span class="line">Father f = <span class="keyword">new</span> Father();</span><br><span class="line">Son s = (Son)f;         <span class="comment">// error：抛出类型转换错误</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>向上转型</strong>：父类引用指向子类对象（这里的父类可以是接口），不能调用与父类不同的特有的子类方法。</li>
<li><strong>向下转型</strong>：使用强制类型转换，可以调用子类的特有方法。</li>
<li><code>a instanceof B</code>: B与B的父类使其等价。</li>
</ul>
<p>编译看左边，运行看右边。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul>
<li>clone()方法：克隆对象</li>
<li>equals()方法：判断对象的值是否相等</li>
</ul>
<h4 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals"></a>== 与 equals</h4><p>== 运算符：</p>
<ol>
<li>可用于基本数据类型和引用数据类型。</li>
<li>对于基本数据类型的比较，比较的是存储的值。</li>
<li>对于引用类型的数据，比较的是指向的地址值。</li>
</ol>
<p>equals方法：</p>
<ol>
<li>只适用于引用型数据类型</li>
<li>用于比较对象间的值是否相同，自定义类需要重写equals方法。（继承自Object，重写前等价于==）</li>
</ol>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>使基本数据类型具有类的特征。主要用于：基本数据类型-包装类-String，三者之间的转换</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center"><strong>Byte</strong></td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center"><strong>Short</strong></td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center"><strong>Integer</strong></td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center"><strong>Long</strong></td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center"><strong>Float</strong></td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center"><strong>Double</strong></td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center"><strong>Boolean</strong></td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center"><strong>Character</strong></td>
</tr>
</tbody>
</table>
</div>
<p>装箱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">Integer i = a;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"232"</span>;</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(s);</span><br><span class="line"></span><br><span class="line">Boolean b1 = <span class="keyword">new</span> Boolean(<span class="string">"true"</span>);  <span class="comment">// true</span></span><br><span class="line">Boolean b2 = <span class="keyword">new</span> Boolean(<span class="string">"true123"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>拆箱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">int</span> i = i.intValue();  <span class="comment">// xxxValue()方法调用</span></span><br></pre></td></tr></table></figure>
<h4 id="自动装箱与自动拆箱-JDK-5-0"><a href="#自动装箱与自动拆箱-JDK-5-0" class="headerlink" title="自动装箱与自动拆箱 (JDK 5.0+)"></a>自动装箱与自动拆箱 (JDK 5.0+)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">method(a);  <span class="comment">// int-&gt;Integer-&gt;Object, 自动装箱+向上转型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动装箱：<code>Integer a = 12;</code></li>
<li>自动拆箱：<code>int b = a;</code></li>
<li>转String转：valueof() 与 parseXXX()<ol>
<li><code>String s = [int|double|float|byte] + &quot;&quot;;</code></li>
<li><code>String s = String.valueOf([int|double|float|byte]) | String.valueOf(Object)</code></li>
<li><code>object o = Object.parseObj(String);</code></li>
</ol>
</li>
</ul>
<p><strong>面试题</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一题：</span></span><br><span class="line">Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">1.2</span>);</span><br><span class="line">sysout(o1)  <span class="comment">// 1.0 自动类型提升</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二题：</span></span><br><span class="line">Integer aa = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer bb = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(aa == bb);  <span class="comment">// false：两个对象的地址不同</span></span><br><span class="line"></span><br><span class="line">Integer m = <span class="number">1</span>;</span><br><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line">System.out.println(m == n);    <span class="comment">// true: Integer的内部类IntegerCache中有个int型的cache数组，里面存了-128~127这些数，该范围的数事先加载好了，每个数都有一个地址值。故在该范围的数，地址都相同</span></span><br><span class="line"></span><br><span class="line">Integer x = <span class="number">128</span>;</span><br><span class="line">Integer y = <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false：超过了-127-128这个范围，故都是要new一个Integer对象，故地址不同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer的私有静态内部类（私有的构造器），且有一个静态块</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h3><p>static：静态</p>
<ol>
<li>静态：<strong>不随外部的变化而变化，被所有对象共有，属于类本身</strong>。</li>
<li>可以修饰：属性、方法、代码块、内部类</li>
<li>静态成员随着类的加载而加载</li>
<li>静态变量不仅可以通过类调用</li>
<li>由于类只加载一次，故<strong>静态变量</strong>在内存中只有一份，<strong>存在方法区的静态域中</strong></li>
<li>静态方法中<strong>不能使用</strong>this、super、非静态变量。（生存周期的角度去理解）</li>
</ol>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>私有化构造器，使用类变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式: 提前新建好了，对象加载时间过长，但是线程安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();  <span class="comment">// 私有类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;   <span class="comment">// 私有构造器</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;   <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式: 需要时才新建对象，延迟对象的创建，线程不安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ol>
<li>存在于类内部，属于类成员。用来初始化类、对象</li>
<li>只能用static修饰，或者不修饰</li>
<li>静态代码块属于类，非静态代码块属于对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    String s = Block.s;       <span class="comment">// 输出 static code block</span></span><br><span class="line">    Block b1 = <span class="keyword">new</span> Block();   <span class="comment">// 输出 code block</span></span><br><span class="line">    Block b2 = <span class="keyword">new</span> Block();   <span class="comment">// 输出 code block</span></span><br><span class="line">    Block b3 = <span class="keyword">new</span> Block();   <span class="comment">// 输出 code block</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String s = <span class="string">"Block"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Block</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态代码块：</span></span><br><span class="line"><span class="comment">        1. 随着类的加载执行一次，后不再执行（按照声明的先后顺序执行多个）</span></span><br><span class="line"><span class="comment">        2. 只能调用静态的成员。</span></span><br><span class="line"><span class="comment">        3. 不能调用非静态结构</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        sysout(<span class="string">"static code block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        非静态代码块：</span></span><br><span class="line"><span class="comment">        1. 随着对象的创建执行，每次创建一次则执行一次（先执行代码块，再执行构造器，可以对对象进行初始化）</span></span><br><span class="line"><span class="comment">        2. 静态、非静态都可以调用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#123;</span><br><span class="line">        sysout(<span class="string">"code block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值顺序：默认赋值-&gt;(显示赋值-&gt;代码块赋值)-&gt;构造器</p>
<h3 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h3><ul>
<li>final修饰类: 不能被继承，不能被拓展，最终形态。</li>
<li>final修饰方法：不能被重写，最终版本。</li>
<li>final修饰变量：一旦被赋值，则不可修改。常量。</li>
</ul>
<p>类中的final变量初始化：显式、构造器、代码块。即在对象出生前，要被初始化</p>
<h2 id="抽象-Abstract"><a href="#抽象-Abstract" class="headerlink" title="抽象(Abstract)"></a><strong>抽象</strong>(<strong>Abstract</strong>)</h2><p>如果一个类中没有包含足够的信息来描绘一个具体的对象，那这个类就是抽象的。  </p>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul>
<li>只属于抽象类：<strong>如果一个类包含抽象方法，那么该类必须是抽象类</strong></li>
<li>非抽象类（具体类）必须重写：任何子类<strong>必须重写父类的所有抽象方法，或者声明自身为抽象类</strong></li>
<li>没有方法体：声明为抽象方法时，不含方法体</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li><strong>抽象类不能被实例化</strong>。只有抽象类的非抽象子类可以创建对象</li>
<li>抽象类不一定包含抽象方法，<strong>包含抽象方法的类一定是抽象类</strong></li>
<li>可以是“模板类”，可以调用抽象方法。</li>
</ul>
<h3 id="匿名子类"><a href="#匿名子类" class="headerlink" title="匿名子类"></a>匿名子类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    Male m = <span class="keyword">new</span> Male();</span><br><span class="line">    func(m);</span><br><span class="line"></span><br><span class="line">    func(<span class="keyword">new</span> Male());  <span class="comment">// 匿名对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了匿名类的对象p：向上转型</span></span><br><span class="line">    Person p = <span class="keyword">new</span> [匿名 extends]Person()&#123;  <span class="comment">//  抽象类的匿名子类</span></span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a><strong>封装</strong>(<strong>Encapsulation</strong>)</h2><ol>
<li>良好的封装可以减少耦合</li>
<li>类内部的结构可以自由修改</li>
<li>对成员变量精确控制</li>
<li>隐藏信息，实现细节</li>
</ol>
<h2 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口(Interface)"></a>接口(<strong>Interface</strong>)</h2><p>接口与类是并列的结构。</p>
<h3 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h3><ul>
<li><strong>接口不是类，没有构造器</strong></li>
<li>接口中的<strong>所有方法必须是抽象方法</strong></li>
<li>JDK7.0-：只能有全局常量（public static final, 可省略）和抽象方法，JDK8.0+：增加了静态方法和默认方法</li>
</ul>
<h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul>
<li>接口中每一个方法被<strong>隐式指定且只能是</strong><code>public abstract</code></li>
<li>接口中的变量会被<strong>隐式指定且只能是</strong><code>public static final</code></li>
<li>接口中的方法不包含方法体，且只有两种结果：<ol>
<li>被抽象类实现，可以不含方法体</li>
<li>被具体类实现，必须重写方法体</li>
</ol>
</li>
<li>接口可以<strong>extends多继承</strong>多个接口</li>
</ul>
<p>接口的多态性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    USB usb = <span class="keyword">new</span> Printer();  <span class="comment">// 接口实现类的向上转型</span></span><br><span class="line">    transferData(usb);</span><br><span class="line">    transferData(<span class="keyword">new</span> Disk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">transferData</span><span class="params">(USB u)</span></span>&#123;  <span class="comment">// 多态</span></span><br><span class="line">    u.<span class="keyword">do</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<strong>接口是方法的规范，面向接口编程。</strong></p>
<h3 id="与抽象类的区别"><a href="#与抽象类的区别" class="headerlink" title="与抽象类的区别"></a>与抽象类的区别</h3><ul>
<li>抽象类中的方法可以有方法体，但是<strong>接口中所有的方法不能有方法体</strong></li>
<li>一个类只能继承一个抽象类，而<strong>一个类可以实现多个接口</strong></li>
<li>接口没有构造器</li>
</ul>
<h3 id="匿名实现类"><a href="#匿名实现类" class="headerlink" title="匿名实现类"></a>匿名实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上转型，多态</span></span><br><span class="line">Interface <span class="class"><span class="keyword">interface</span> </span>= <span class="keyword">new</span> [匿名] Interface&#123;...&#125;;  <span class="comment">// 匿名内部类，其实现了接口。省略号中包含方法体</span></span><br></pre></td></tr></table></figure>
<p>总结：<strong>接口就是抽象方法的集合</strong></p>
<h3 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h3><p>两个类实现同一个接口，代理类中有被代理类的对象，代理类代表被代理类的功能，屏蔽真实的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealImage realImage = <span class="keyword">new</span> RealImage();</span><br><span class="line">        ProxyImage proxyImage = <span class="keyword">new</span> ProxyImage(realImage);</span><br><span class="line">        proxyImage.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show 真实的图片"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Image image;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(Image i)</span></span>&#123;  <span class="comment">// 多态</span></span><br><span class="line">        <span class="keyword">this</span>.image = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"检查图片"</span>);</span><br><span class="line">        <span class="keyword">this</span>.image.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>实现了创建者与调用者的分离（开闭原则：对拓展开放，对修改封闭）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂方法模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AudiFactory audiFactory = <span class="keyword">new</span> AudiFactory();</span><br><span class="line">        BMWFactory bmwFactory = <span class="keyword">new</span> BMWFactory();</span><br><span class="line">        Car a = audiFactory.getCar();</span><br><span class="line">        Car b = bmwFactory.getCar();</span><br><span class="line">        a.run();</span><br><span class="line">        b.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"奥迪在跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"宝马在跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMW();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JDK8-0-的接口新特性"><a href="#JDK8-0-的接口新特性" class="headerlink" title="JDK8.0+的接口新特性"></a>JDK8.0+的接口新特性</h3><p>接口中的成员：</p>
<ol>
<li>全局常量</li>
<li>抽象方法</li>
<li><strong>静态方法</strong>(默认public，8.0+)</li>
<li><strong>默认方法</strong>(默认public，8.0+)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sys(<span class="string">"s"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">dprint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sys(<span class="string">"f"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态方法：只能使用接口调用</li>
<li>默认方法：可以重写方法体，也可以不重写使用默认的方法体。<br><strong>注：父类与接口中的方法同名同参数，那么子类在没有重写的情况下默认调用父类方法。（类优先，若是同名属性则不被允许，多个接口中的同名默认方法冲突否则必须重写。若要调接口中的方法—<code>InterfaceA.super.method</code>）</strong></li>
</ul>
<h2 id="内部类（不常见）"><a href="#内部类（不常见）" class="headerlink" title="内部类（不常见）"></a>内部类（不常见）</h2><ul>
<li>局部内部类：方法体内、代码块内。</li>
<li>成员内部类：类的下一层，与成员变量平级</li>
</ul>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul>
<li>可以调用外部类的结构</li>
<li>可以被static修饰</li>
<li>可以有4种修饰方式</li>
</ul>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><ul>
<li>接口实现类</li>
<li>匿名实现类。</li>
<li>局部内部类调用外部的局部变量，要求其是final的。</li>
</ul>
<h3 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h3><ol>
<li><strong>abstract：可以修饰类和方法，类是抽象的不能被实例化，方法是抽象的没有方法体需要具体类实现</strong></li>
<li><strong>接口相互之间可以继承，抽象类可以实现接口，抽象类可以继承非抽象类</strong><br>3.<strong>抽象与接口体现了多态</strong></li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>编译时异常</li>
<li>运行时异常</li>
</ul>
<h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">    |----java.lang.Error</span><br><span class="line">    |----java.lang.Exception</span><br><span class="line">         |----编译时异常：</span><br><span class="line">              - IOException</span><br><span class="line">              - ClassNotFountException</span><br><span class="line">         |----运行时异常</span><br><span class="line">              - NullPointerException</span><br><span class="line">              - ArrayIndexOutOfBoundsException</span><br><span class="line">              - ClassCastException</span><br><span class="line">              - NumberFormatException</span><br></pre></td></tr></table></figure>
<h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><ol>
<li><p><code>try-catch-catch-...-finally</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能会出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 发生异常1时，处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 发生异常2时，处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 无论对错，始终一定都会执行的代码，即使catch里有return语句，通常用于关闭资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>异常子类的catch必须在异常父类的上面，否则报错。</strong></p>
</li>
<li>异常类型方法：<ul>
<li>getMessage(): 返回一个String</li>
<li>printStackTrace(): void方法，输出栈追踪</li>
</ul>
</li>
<li><code>method() throws 异常类型</code>: 不处理异常，将异常抛给调用者，表示该方法可能抛出一个异常</li>
<li><code>throw new [异常类型1,2...]</code>：抛出异常</li>
<li>子类重写父类方法抛出的异常只能是父类异常的子异常。</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol>
<li>继承已有的异常类</li>
<li>提供全局常量标识类</li>
<li>提供多个构造器</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>程序：实体</li>
<li>进程：运行中的程序，<strong>是资源分配的基本单位</strong></li>
<li>线程：进程的细分，可理解为执行路径，<strong>是调度的基本单位</strong></li>
<li>并行：多个CPU同时执行多个任务，CPU的并行</li>
<li>并发：一个CPU同时执行多个任务，任务的并发</li>
<li>一个Java程序至少有3个线程：main，垃圾收集，异常处理</li>
</ul>
<h3 id="通过Thread类创建"><a href="#通过Thread类创建" class="headerlink" title="通过Thread类创建"></a>通过Thread类创建</h3><ol>
<li>继承java.lang.Thread类</li>
<li>重写run方法，是线程执行的代码</li>
<li>创建Thread类的子类对象</li>
<li>通过对象调用start方法</li>
<li><strong>start方法只能被同一个线程调用一次（IllegalThreadStateException）</strong></li>
<li>使用匿名子类使用不同的run方法</li>
</ol>
<h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><ol>
<li>start方法：启动线程</li>
<li>run方法：线程的执行内容</li>
<li>currentThread方法：获取执行当前代码的线程</li>
<li>setName、getName方法：命名的修改与获取</li>
<li>yield方法：释放对CPU的占用，回到就绪状态</li>
<li>join方法：阻塞<strong>执行当前代码</strong>的线程，等待调用方法的线程执行完毕后，<strong>结束阻塞状态</strong></li>
<li><em>stop方法</em>：以及弃用，结束线程的生命周期</li>
<li>sleep方法（静态）：当前线程“睡眠”毫秒数（1秒=1000毫秒），使线程阻塞</li>
<li>isAlive方法：线程是否存活</li>
</ol>
<h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><ul>
<li>时间片</li>
<li>优先级</li>
</ul>
<p>优先级：从概率上来讲优先</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="通过Runnable接口创建"><a href="#通过Runnable接口创建" class="headerlink" title="通过Runnable接口创建"></a>通过Runnable接口创建</h3><ol>
<li>创建实现Runnable接口的类</li>
<li>实现抽象方法：run</li>
<li>创建该类的对象</li>
<li>将此对象传入Thread的构造器中，创建Thread的对象</li>
<li>通过Thread的对象调用start方法</li>
</ol>
<p>继承Thread类影响了拓展性，而实现Runnable接口则不会影响拓展性</p>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WindowsTest继承了Thread类，创建3个对象来建立3个线程</span></span><br><span class="line">WindowsTest w1 = <span class="keyword">new</span> WindowsTest();</span><br><span class="line">WindowsTest w2 = <span class="keyword">new</span> WindowsTest();</span><br><span class="line">WindowsTest w3 = <span class="keyword">new</span> WindowsTest();</span><br><span class="line">w1.start();</span><br><span class="line">w2.start();</span><br><span class="line">w3.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowsRunnable实现了Runnable接口，创建1个对象来建立3个线程</span></span><br><span class="line">WindowsRunnable wr = <span class="keyword">new</span> WindowsRunnable();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(wr);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(wr);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(wr);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br></pre></td></tr></table></figure>
<ul>
<li>Thread也重写了Runnable接口</li>
<li>第二种方式相当于覆盖了Thread的run方法</li>
</ul>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul>
<li>新建</li>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
<li>死亡</li>
</ul>
<p>线程状态转换图：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cpu%E7%8A%B6%E6%80%81.png" alt="线程的生命周期"></p>
<h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><p>问题：</p>
<ol>
<li>当线程之间存在共享数据时，就会存在安全问题</li>
<li>共享数据成为<strong>临界资源</strong>，访问临界资源的代码称为<strong>临界区</strong></li>
</ol>
<p>如何解决：</p>
<ol>
<li>对线程的访问的资源进行<strong>加锁</strong>，加锁后其他进程不能访问</li>
</ol>
<p>java的解决方式：</p>
<ul>
<li><p><code>synchronized</code>关键字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法：Runnable实现类-this为同步监视器</span></span><br><span class="line">权限修饰符 <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步方法：Thread子类-ClassName.class为调用者，且只有一个</span></span><br><span class="line">权限修饰符 <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步监视器：锁-<strong>任何一个对象都可以作为锁</strong>；要求-<strong>多个线程必须共用一把锁</strong></p>
</li>
<li>this作为锁：适用于实现Runnable接口的类的对象，因为只创建了一个对象</li>
<li>ClassName.class作为锁：该对象只会加载一次</li>
<li>在Runnable实现类中考虑使用this为锁，在Thread的子类中考虑使用ClassName.class作为锁</li>
</ul>
<p>同步的缺点：</p>
<ol>
<li>使用了线程同步相当于，线程的串行执行，速度慢</li>
</ol>
<h3 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h3><ul>
<li><p>懒汉式：线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒汉式：双重校验锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingle</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    s = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>  不同的线程分别占用对方的资源不放弃，都在等待对方去释放自己需要的同步资源，就形成了死锁。可见申请资源的方向称为一个<strong>环状结构</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="keyword">new</span> Thread(&#123;</span><br><span class="line">    LockA&#123;</span><br><span class="line">        <span class="comment">// 抢占A锁，等待B锁</span></span><br><span class="line">        LockB&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start()</span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">new</span> Thread(&#123;</span><br><span class="line">    LockB&#123;</span><br><span class="line">        <span class="comment">// 抢占B锁，等待A锁</span></span><br><span class="line">        LockA&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><ul>
<li>Lock对象：JDK5.0+，作为同步锁</li>
<li><code>java.util.concurrent.locks.Lock</code>接口</li>
<li>ReentrantLock类实现了Lock接口</li>
</ul>
<p>synchronized与lock的不同：</p>
<ol>
<li>synchronized相当于自动锁，自动加锁，自动释放锁；lock手动启动锁，手动释放锁</li>
<li>优先使用顺序：lock锁-&gt;同步代码块-&gt;同步方法</li>
</ol>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul>
<li>wait方法：阻塞当前线程，<strong>并释放锁</strong></li>
<li>notify方法：唤醒用wait阻塞的线程</li>
<li>notifyAll方法：唤醒所有wait阻塞的线程</li>
<li><strong>方法的调用者必须是同步代码块或同步方法的同步监视器</strong>，否则出现异常<code>IllegalMonitorStateException</code></li>
<li><strong>3个方法都来自Object</strong>，因为同步监视器可以是任何对象，他们的共同父类是Object</li>
</ul>
<p>生产者消费者问题：使用wait与notify让生产者与消费者之间产生交互</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ind.MultiProcess;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者与消费者的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerAndProducerProblem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StoreManagement store = <span class="keyword">new</span> StoreManagement();</span><br><span class="line">        store.openStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stocks_num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> stocks_now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Store store;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Store store)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.store = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            produceItem(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produceItem</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (store) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (store.stocks_now &lt; store.stocks_num) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        store.stocks_now++;</span><br><span class="line">                        store.notify();   <span class="comment">// 唤醒消费者</span></span><br><span class="line">                        System.out.println(name + <span class="string">": 当前货量-"</span> + store.stocks_now);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        store.wait();    <span class="comment">//  货满，生产者等待</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Store store;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Store store)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.store = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            consumeItem(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumeItem</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (store) &#123;</span><br><span class="line">                <span class="keyword">if</span> (store.stocks_now &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    store.stocks_now--;</span><br><span class="line">                    store.notify();   <span class="comment">// 唤醒生产者</span></span><br><span class="line">                    System.out.println(name + <span class="string">" 消费后剩余"</span> + store.stocks_now);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    store.wait();   <span class="comment">// 货架为空，消费者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoreManagement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Store store = <span class="keyword">new</span> Store();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer(store);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> Consumer(store);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initProducers();      <span class="comment">// 开启生产者</span></span><br><span class="line">        initConsumers();      <span class="comment">// 开启消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initProducers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread[] producers = <span class="keyword">new</span> Thread[<span class="number">5</span>];   <span class="comment">// 5个生产者</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; producers.length; i++) &#123;</span><br><span class="line">            producers[i] = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">            producers[i].setName(<span class="string">"生产者"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : producers) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) (<span class="number">3</span> + Math.random() * <span class="number">5</span>);</span><br><span class="line">        System.out.println(n + <span class="string">"个消费者"</span>);</span><br><span class="line">        System.out.println(<span class="string">"5个生产者"</span>);</span><br><span class="line">        <span class="keyword">final</span> Thread[] consumers = <span class="keyword">new</span> Thread[n];   <span class="comment">// 3-8个消费者</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumers.length; i++) &#123;</span><br><span class="line">            consumers[i] = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line">            consumers[i].setName(<span class="string">"消费者"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : consumers) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JDK5-0-新增方式"><a href="#JDK5-0-新增方式" class="headerlink" title="JDK5.0+新增方式"></a>JDK5.0+新增方式</h3><ul>
<li>实现Callable接口</li>
<li>使用线程池</li>
</ul>
<p>Callable接口：</p>
<ul>
<li>创建Callable接口的实现类</li>
<li>借助FutureTask类创建对象，FutureTask类实现了Runnable接口</li>
<li>用FutureTask类的get方法获取线程执行call的返回值</li>
<li>同样将FutureTask类的对象来构造Thread，来启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CallThread t = <span class="keyword">new</span> CallThread();     <span class="comment">// Callable接口的实现类</span></span><br><span class="line">        FutureTask ft = <span class="keyword">new</span> FutureTask(t);   <span class="comment">// 继承过Runnable接口</span></span><br><span class="line">        <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object o = ft.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += <span class="number">2</span>;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>有返回值</li>
<li>可以抛出异常</li>
<li>支持泛型</li>
</ul>
<p>使用线程池：</p>
<ul>
<li>提高响应速度</li>
<li>降低资源消耗</li>
<li>便于线程管理</li>
</ul>
<ol>
<li><p>ExecutorService：线程池接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService service = <span class="keyword">new</span> ExecutorService(<span class="number">10</span>);  <span class="comment">// 创建10个线程的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span>: 执行任务，Runnable接口的实现类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span>: 关闭连接池</span></span><br><span class="line"><span class="function"></span>=========================</span><br><span class="line">corePoolSize: 核心池的大小</span><br><span class="line">maximumPoolSize：最大线程数</span><br><span class="line">keepAliveTime：线程没有任务时，最多保持多少时间后会终止</span><br></pre></td></tr></table></figure>
</li>
<li><p>Executors：线程池的工厂类、工具类。静态方法</p>
</li>
</ol>
<h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ul>
<li>final类</li>
<li>实现了<code>java.io.Serializable, Comparable&lt;String&gt;, CharSequence</code>三个接口<ol>
<li><code>Serializable</code>接口：表示支持序列化</li>
<li><code>Compareable&lt;String&gt;</code>接口：比较大小</li>
</ol>
</li>
<li><code>final char[]</code>：用于存储字符串数据</li>
<li><p><strong>不可变的字符序列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"123"</span>;  <span class="comment">// 字面量，字符串值存储在字符串常量池中，其中不会存储相同的常量字符串</span></span><br><span class="line">String s2 = <span class="string">"123"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> Stirng(<span class="string">"123"</span>)  <span class="comment">// 存储在堆中</span></span><br><span class="line"></span><br><span class="line">sysout(s1 == s2)   <span class="comment">// true</span></span><br><span class="line">sysout(s1 == s3)   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">12</span>)</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">113</span>)</span><br><span class="line">sysout(p1.name == p2.name)   <span class="comment">// true 因为"Jack"为字面量，存储在常量池中</span></span><br><span class="line"></span><br><span class="line">String s1 = <span class="string">"javaEE"</span>;</span><br><span class="line">String s2 = <span class="string">"hadoop"</span>;</span><br><span class="line"></span><br><span class="line">String s3 = <span class="string">"javaEEhadoop"</span>;</span><br><span class="line">String s4 = <span class="string">"javaEE"</span> + <span class="string">"hadoop"</span>;</span><br><span class="line">String s5 = s1 + <span class="string">"hadoop"</span>;</span><br><span class="line">String s6 = <span class="string">"javaEE"</span> + s2;</span><br><span class="line">System.out.println(s3 == s4);  <span class="comment">// true，常量与常量的拼接都在常量池中</span></span><br><span class="line">System.out.println(s3 == s5);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s6);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 只要其中一个是变量，结果就在堆当中</span></span><br><span class="line"></span><br><span class="line">String s7 = s5.intern()  <span class="comment">// 返回在常量池中的字符串</span></span><br><span class="line">sysout(s3 == s7)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>拼接操作会产生新的字符串常量</li>
<li>replace操作也会产生新的字符串常量</li>
</ol>
</li>
</ul>
<p>JVM内存结构：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="JVM内存结构"></p>
<h3 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h3><ul>
<li>int length()：返回字符串长度</li>
<li>char charAt(int index)：返回某索引处的字符</li>
<li>boolean isEmpty()：判断字符串是否为空</li>
<li>String toLowerCase()</li>
<li>String toUpperCase()</li>
<li>String trim()：返回字符串的副本，忽略前后空格</li>
<li>boolean equals(Object obj)：比较字符串的内容是否相同</li>
<li>String concat(String str)：等价于“+”</li>
<li>int CompareTo(String anotherString)：比较字符串中每个字符的Ascii大小</li>
</ul>
<hr>
<ul>
<li>String substring(int beginIndex)</li>
<li>boolean startWith(String suffix)</li>
<li>boolean endWith(String prifix)</li>
<li>boolean contains(CharSequence s)</li>
<li>int indexOf(String str)</li>
<li>int lastIndexOf(String str)</li>
</ul>
<hr>
<ul>
<li>String replace(String oldStr, String newStr)</li>
<li>String replaceAll(String regex, String replacement)</li>
<li>String replaceFirst(String regex, String replacement)</li>
<li>boolean matches(String regex)</li>
<li>String split(String regex)</li>
<li>String转其他类型：parseXxx(String str)</li>
<li>其他类型转String：String.valueOf(Xxx)</li>
<li>String转为char数组：str.toCharArray()</li>
<li>char数组转为String：调用String的构造器</li>
<li>String转为byte数组：str.getBytes(String charset)，使用默认字符集</li>
<li>byte数组转为String：调用String的构造器，使用编辑器默认字符集，<strong>或者利用参数指定字符集</strong></li>
</ul>
<h3 id="StringBuffer（效率低）与StringBuilder（效率最高）"><a href="#StringBuffer（效率低）与StringBuilder（效率最高）" class="headerlink" title="StringBuffer（效率低）与StringBuilder（效率最高）"></a>StringBuffer（效率低）与StringBuilder（效率最高）</h3><ul>
<li>String：<strong>不可变的字符序列</strong>；使用char数组存储数据</li>
<li><p>StringBuffer：<strong>可变的字符序列</strong>，<strong>线程安全的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();  <span class="comment">// 底层创建一个长度为16的char数组</span></span><br><span class="line">sb.append(<span class="string">"hello"</span>)   <span class="comment">// 数组的扩容</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  底层是将 原字符串的长度*2+2 作为新字符串的长度，同时赋给新的数组copyof</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          value = Arrays.copyOf(value,</span><br><span class="line">                  newCapacity(minimumCapacity));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          ? hugeCapacity(minCapacity)</span><br><span class="line">          : newCapacity;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>StringBuilder：<strong>可变的字符序列</strong>，线程不安全的。jdk5.0+；底层原理同StringBuffer，两者继承自同一父类。</p>
</li>
</ul>
<p>常用方法：</p>
<ol>
<li>append</li>
<li>replace</li>
<li>insert</li>
<li>reverse</li>
<li>setCharAt</li>
<li>delete</li>
</ol>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><ul>
<li>System类中的<code>currentTimeMillis()</code>:返回当前的时间戳毫秒数，返回long型</li>
</ul>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><ul>
<li>java.util.Date</li>
<li>java.sql.Date:继承自前者</li>
</ul>
<p>转换：<strong>利用时间戳来相互转换</strong></p>
<h3 id="SimpleDateFormat格式化日期"><a href="#SimpleDateFormat格式化日期" class="headerlink" title="SimpleDateFormat格式化日期"></a>SimpleDateFormat格式化日期</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">String s = sdf.format(date)   <span class="comment">// 日期----&gt;字符串  format</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line">String s1 = <span class="string">"2000-12-1 23:22"</span>;</span><br><span class="line">Date date1 = sdf1.parse(s1);   <span class="comment">// 字符串-----&gt;日期 parse</span></span><br></pre></td></tr></table></figure>
<h3 id="Calender抽象类的使用-JDK8-0"><a href="#Calender抽象类的使用-JDK8-0" class="headerlink" title="Calender抽象类的使用 JDK8.0-"></a>Calender抽象类的使用 JDK8.0-</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.getClass());   <span class="comment">// class java.util.GregorianCalendar</span></span><br><span class="line">System.out.println(calendar.get(Calendar.HOUR));  <span class="comment">// get</span></span><br><span class="line">calendar.set(Calendar.MONTH, <span class="number">9</span>);   <span class="comment">// set</span></span><br><span class="line">calendar.add(Calendar.MONTH, -<span class="number">2</span>);  <span class="comment">// add</span></span><br></pre></td></tr></table></figure>
<h3 id="JDK8-0-时间API"><a href="#JDK8-0-时间API" class="headerlink" title="JDK8.0+ 时间API"></a>JDK8.0+ 时间API</h3><p>常用类(没有偏移量了；<strong>不可变性</strong>)：</p>
<ul>
<li>LocalDate</li>
<li>LocalTime</li>
<li>LocalDateTime</li>
<li>Instant</li>
<li>DateTimeFomatter</li>
</ul>
<p>方法：</p>
<ul>
<li>withxxx()：返回带有指定值的新的日期对象</li>
<li>plusxxx()</li>
<li>minusxxx()</li>
</ul>
<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>两个接口</p>
<ul>
<li>Compareable（内比较器）：实现类需重写<code>compareTo</code>方法</li>
<li>Comparator（外比较器）：<strong>定制排序</strong>，重写<code>compare</code>方法</li>
</ul>
<h2 id="System、Math、BigInteger、BigDecimal"><a href="#System、Math、BigInteger、BigDecimal" class="headerlink" title="System、Math、BigInteger、BigDecimal"></a>System、Math、BigInteger、BigDecimal</h2><ul>
<li>System：有关系统的</li>
<li>Math：有关数学运算的</li>
<li>BigInteger：表示不可变的任意精度的整数</li>
<li>BigDecimal：表示不可变的、任意精度的有符号十进制<strong>定点数</strong>。精度较高。</li>
</ul>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>有限个、确定的值的类。（JDK5-自定义，JDK5+引入enum关键字）</p>
<h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><ol>
<li>私有化每个枚举值</li>
<li>私有化构造器</li>
<li>创建全局枚举对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String season;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.season = name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">"春天"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">"夏天"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">"秋天"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">"冬天"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeason</span><span class="params">()</span> </span>&#123;   <span class="comment">// 获取枚举变量的值</span></span><br><span class="line">        <span class="keyword">return</span> season;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Season&#123;"</span> +</span><br><span class="line">                <span class="string">"season='"</span> + season + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用enum关键字"><a href="#使用enum关键字" class="headerlink" title="使用enum关键字"></a>使用enum关键字</h3><ul>
<li>继承自java.lang.Enum</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> SeasonStatus&#123;</span><br><span class="line">    <span class="comment">// objName</span></span><br><span class="line">    SPRING(<span class="string">"春天"</span>),   <span class="comment">// 逗号隔开</span></span><br><span class="line">    SUMMER(<span class="string">"夏天"</span>),</span><br><span class="line">    AUTUMN(<span class="string">"秋天"</span>),</span><br><span class="line">    WINTER(<span class="string">"冬天"</span>);   <span class="comment">// 分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    SeasonStatus(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类的方法：</p>
<ul>
<li>values()</li>
<li>valueOf(String objName)</li>
</ul>
<p>枚举类实现接口：</p>
<ul>
<li>同类一样实现接口方法</li>
<li><strong>每个对象可以不同地实现接口方法</strong></li>
</ul>
<h2 id="注解（Annotation）JDK5-0"><a href="#注解（Annotation）JDK5-0" class="headerlink" title="注解（Annotation）JDK5.0+"></a>注解（Annotation）JDK5.0+</h2><ul>
<li>@override：限定重写父类的方法</li>
<li>@Deprecated：过时的</li>
<li>@SuppressWarnings：抑制编译器警告</li>
</ul>
<p>自定义注解：参照@SuppressWarnings；有成员value，或无成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The set of warnings that are to be suppressed by the compiler in the</span></span><br><span class="line"><span class="comment">     * annotated element.  Duplicate names are permitted.  The second and</span></span><br><span class="line"><span class="comment">     * successive occurrences of a name are ignored.  The presence of</span></span><br><span class="line"><span class="comment">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span></span><br><span class="line"><span class="comment">     * ignore any warning names they do not recognize.  They are, however,</span></span><br><span class="line"><span class="comment">     * free to emit a warning if an annotation contains an unrecognized</span></span><br><span class="line"><span class="comment">     * warning name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The string &#123;<span class="doctag">@code</span> "unchecked"&#125; is used to suppress</span></span><br><span class="line"><span class="comment">     * unchecked warnings. Compiler vendors should document the</span></span><br><span class="line"><span class="comment">     * additional warning names they support in conjunction with this</span></span><br><span class="line"><span class="comment">     * annotation type. They are encouraged to cooperate to ensure</span></span><br><span class="line"><span class="comment">     * that the same names work across multiple compilers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the set of warnings to be suppressed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>对<strong>现有的注解进行解释说明</strong>的注解：</p>
<ul>
<li>Retention（保留）：用于指定注解的生命周期-SOURCE\CLASS(default)\RUNTIME</li>
<li>Target：指定注解能用于修饰那些元素-TYPE/FIELD/METHOD/CONSTRUCTOR… …</li>
<li>Documented：令注解在被javadoc解析后被保留下来</li>
<li>Inherited：令注解具有继承性</li>
</ul>
<h3 id="JDK8-0-新特性"><a href="#JDK8-0-新特性" class="headerlink" title="JDK8.0+新特性"></a>JDK8.0+新特性</h3><ul>
<li>可重复注解</li>
<li>类型注解：TYPE_USER/TYPE_PARAMETER</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>Collection接口：单列数据，单一对象<ol>
<li>List：有序、可重复</li>
<li>Set：无序、不可重复</li>
</ol>
</li>
<li>Map接口：双列数据，存储key-value<ol>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
<li>HashTable</li>
<li>Properties</li>
</ol>
</li>
<li>Collections工具类</li>
</ul>
<p>Collection接口常用方法：</p>
<ul>
<li>add(Object e)：添加一个元素</li>
<li>addAll(Collection coll)：添加一个集合中的所有元素</li>
<li>size()：集合的大小</li>
<li>isEmpty()：集合是否为空</li>
<li>clear()：清空集合</li>
<li>contains(Object e)：是否存在元素，<strong>使用equals来比较元素</strong></li>
<li>containsAll(Collection coll)：判断集合的元素是否都存在</li>
<li>remove(Object e)</li>
<li>removeAll(Collection coll)</li>
<li>retainAll(Collection coll1)：求两个集合的交集，并替换this集合</li>
<li>Object.equals()</li>
<li>Object.hashCode()</li>
<li>toArray()：集合—&gt;Object数组</li>
<li>Arrays.asList()：数组—&gt;集合</li>
<li>iterator()：放回Iterator接口的实例</li>
</ul>
<p>注：<strong>添加的obj要重写equals方法</strong></p>
<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>迭代器，用于遍历集合中的元素，<strong>只能用一次。不可逆。</strong></p>
<ul>
<li>E next()：指针下移</li>
<li>boolean hasNext()：指针不变</li>
<li>void remove()：删除集合中的元素（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用遍历</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="List接口（Collection子接口）"><a href="#List接口（Collection子接口）" class="headerlink" title="List接口（Collection子接口）"></a>List接口（Collection子接口）</h3><p>元素有序、可重复、动态变化大小。List实现类：</p>
<ul>
<li>ArrayList：线程不安全，效率高；底层用Object[]<strong>数组</strong></li>
<li>LinkedList：插入、删除效率高；底层使用<strong>双向链表</strong>实现</li>
<li>Vector：线程安全，效率低；底层用Object[]<strong>数组</strong></li>
</ul>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>JDK7.0：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList arr = <span class="keyword">new</span> ArrayList();  <span class="comment">// 容量默认为10的Object数组</span></span><br><span class="line"><span class="comment">// add操作会让判断数组大小，扩容机制：变为原来的1.5倍，并赋值给新的数组</span></span><br><span class="line"><span class="comment">// 建议使用带参数的构造器，就避免去频繁的动态扩容</span></span><br></pre></td></tr></table></figure>
<p>JDK8.0+:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  <span class="comment">// &#123;&#125;空的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用add操作后才开始创建数组，其它与JDK7无异</span></span><br><span class="line"><span class="comment">// 延迟了数组的创建时间</span></span><br></pre></td></tr></table></figure>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类，前后指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;  <span class="comment">// 最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;  <span class="comment">// 新节点作为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>基本不用了</p>
<h3 id="List接口常用方法"><a href="#List接口常用方法" class="headerlink" title="List接口常用方法"></a>List接口常用方法</h3><ul>
<li>void add(int index, Object ele)</li>
<li>boolean addAll(int index, Collection eles)</li>
<li>Object get(int index)</li>
<li>int indexOf(Object obj)：如果不存在返回-1</li>
<li>int lastIndexOf(Object obj)</li>
<li>Object remove(int index) / boolean remove(Object o)：按照索引删除，并返回此元素</li>
<li>Object set(int index, Object ele)，按照索引修改，并返回此元素</li>
<li>List subList(int fromIndex, int toList)</li>
</ul>
<h3 id="Set接口（Collection子接口）"><a href="#Set接口（Collection子接口）" class="headerlink" title="Set接口（Collection子接口）"></a>Set接口（Collection子接口）</h3><ul>
<li><strong>存储无序的</strong>：不等于随机性，体现在哈希值上，根据哈希值存储。</li>
<li><strong>不可重复的</strong>：利用hashCode方法与equals方法判断是否重复。底层：<strong>数组+链表，哈希值与equals方法，在数组中的位置与哈希值有关</strong>（JDK7与8不一样，对链表的操作分为<strong>头插法</strong>8+与尾插法7-）</li>
</ul>
<p>实现类：</p>
<ul>
<li><code>HashSet</code>：主要实现类，线程不安全，可以存储null值，底层是一个数组，长度为16<ul>
<li><code>LinkedHashSet</code>：HashSet的子类，可以按照顺序变量。<strong>原理依然是数组+链表，不过链表的节点的双向量表，记录的是添加的顺序</strong>。遍历的效率高</li>
</ul>
</li>
<li><code>TreeSet</code>：空参构造底层是一个TreeMap，可以对属性排序。<strong>只能添加同类型的数据</strong>，并自然排序（实现Comparable接口的类）。<strong>根据compareTo来判断对象是否相同（返回0）。</strong><ul>
<li>定制排序：<code>TreeSet treeset = new TreeSet(Comparator com)</code>，使用比较器</li>
</ul>
</li>
</ul>
<p>所以<strong>一般需要重写hashCode方法与equals方法：相等的对象要有相等的哈希值。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题：理解hashSet利用哈希值存储、不可重复性的特点</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">hashSet.add(p1);</span><br><span class="line">hashSet.add(p2);</span><br><span class="line"></span><br><span class="line">System.out.println(hashSet);  <span class="comment">// [Person&#123;name='Tom', age=22&#125;, Person&#123;name='Jack', age=12&#125;]</span></span><br><span class="line"></span><br><span class="line">p1.age = <span class="number">11</span>;</span><br><span class="line">System.out.println(hashSet.remove(p1));  <span class="comment">// false</span></span><br><span class="line">System.out.println(hashSet);  <span class="comment">// [Person&#123;name='Tom', age=22&#125;, Person&#123;name='Jack', age=11&#125;]</span></span><br><span class="line">hashSet.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">11</span>));</span><br><span class="line">System.out.println(hashSet);  <span class="comment">// [Person&#123;name='Tom', age=22&#125;, Person&#123;name='Jack', age=11&#125;, Person&#123;name='Jack', age=11&#125;]</span></span><br><span class="line">hashSet.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">12</span>));</span><br><span class="line">System.out.println(hashSet);  <span class="comment">// [Person&#123;name='Tom', age=22&#125;, Person&#123;name='Jack', age=11&#125;, Person&#123;name='Jack', age=11&#125;, Person&#123;name='Jack', age=12&#125;]</span></span><br></pre></td></tr></table></figure>
<h3 id="Map接口（Collection子接口）"><a href="#Map接口（Collection子接口）" class="headerlink" title="Map接口（Collection子接口）"></a>Map接口（Collection子接口）</h3><p>双列数据，key-value型数据。实现类</p>
<ul>
<li>HashMap：常用实现类。线程不安全的。有null的key与value<ul>
<li>LinkedHashMap：继承自HashMap，可以按照添加的顺序遍历</li>
</ul>
</li>
<li>TreeMap：可以按照添加的顺序排序（<strong>按照key排序，要求是同一个类</strong>）遍历，底层使用红黑树</li>
<li>Hashtable：古老类。线程安全。不能有null的key与value<ul>
<li>Properties：用来处理配置文件，key与value都是String型的</li>
</ul>
</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>底层概述：</p>
<ul>
<li>JDK7-：数组+链表</li>
<li>JDK8+：数组+链表+红黑树</li>
<li>Key：无序，不重复。使用set存储Key，需要重写equals方法与hashCode方法</li>
<li>Value：无序，可重复。</li>
<li>Key-Value：一个Entry</li>
</ul>
<p>JDK7：Entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();  <span class="comment">// 默认16长度的Entry数组，数组+链表</span></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">hashMap.put(key, value)  <span class="comment">// 使用key的hashCode计算哈希值，按此哈希值计算存储位置。与Set类似，key的去重过程为先比较哈希值，再使用equals方法比较。</span></span><br><span class="line"><span class="comment">// 如果存在相同的key，则用新的value替换。从始至终都是比较的key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容：当超出临界值，且存放位置不为空</span></span><br><span class="line"><span class="comment">// 扩容为原来的2倍，并将原来的数据复制过来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------源码-------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span></span>&#123; <span class="comment">// 16, 0.75</span></span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); <span class="comment">// 默认初始化容量16，默认加载因子0.75</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> loadFactor)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> capcity = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)&#123;</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>   <span class="comment">// 2倍增加</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 临界值，影响扩容时的条件  16*0.75=12</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(capacity*loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容操作</span></span><br><span class="line"><span class="comment">// 头插法, 新节点next指向当前链表的头部</span></span><br><span class="line"></span><br><span class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K, V&gt; n)&#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK8：Node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();  <span class="comment">// 底层没有创建数组，Node，数组+链表+红黑树</span></span><br><span class="line"><span class="comment">// 添加，首次调用时，再创建</span></span><br><span class="line">hashMap.put(key, value)  <span class="comment">// 使用key的hashCode计算哈希值，按此哈希值计算存储位置。与Set类似，key的去重过程为先比较哈希值，再使用equals方法比较。</span></span><br><span class="line"><span class="comment">// 如果存在相同的key，则用新的value替换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容：容量*2，且加载因子*2</span></span><br><span class="line"><span class="comment">// 当某个索引位置处链表长度 &gt; 8 且当前数组长度 &gt; 64时，将此索引位置上的结构转变为红黑树。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------源码-------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123; <span class="comment">// 加载因子0.75，用于扩容临界值</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// put操作</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)  <span class="comment">// 第一个元素</span></span><br><span class="line">        n = (tab = resize()).length;  <span class="comment">// 初始化16</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  <span class="comment">// 找到需要插入的位置上是否为空</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;  <span class="comment">// 创建一个临时变量</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;  <span class="comment">// 比较两者的哈希值是否相同</span></span><br><span class="line">            <span class="comment">// 再比较key的地址是否相同，再equals比较内容是否相同</span></span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;  <span class="comment">// 哈希值相同且key相同的情况，p是旧的元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;  <span class="comment">// p旧元素的下一个元素</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);  <span class="comment">// 尾插法</span></span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD = 8，当超过这个长度时将变成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下一个元素与本元素比较</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;  <span class="comment">// 继续考虑下一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>内部单元为Entry，继承自HashMap中的Node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Map中的常用方法"><a href="#Map中的常用方法" class="headerlink" title="Map中的常用方法"></a>Map中的常用方法</h3><ul>
<li>Object put(Object key, object value)</li>
<li>void putAll(Map m)</li>
<li>Object remove(Object key)</li>
<li>void clear()</li>
</ul>
<hr>
<ul>
<li>Object get(Object key)</li>
<li>boolean containsKey(Object key)</li>
<li>boolean containsValue(Object value)</li>
<li>int size()</li>
<li>boolean isEmpty()</li>
<li>boolean equals(Object obj)</li>
</ul>
<hr>
<p>  通过迭代器遍历键与值</p>
<ul>
<li>Set keySet()</li>
<li>Collection values()</li>
<li>Set entrySet()</li>
</ul>
<h3 id="Properties（继承自Hashtable）"><a href="#Properties（继承自Hashtable）" class="headerlink" title="Properties（继承自Hashtable）"></a>Properties（继承自Hashtable）</h3><p>key和value都是String，通常用于配置文件<code>xxx.properties</code>。使用文件流操作。</p>
<h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>常用方法：</p>
<ul>
<li>reverse(List)</li>
<li>shuffle(List)</li>
<li>sort(List)</li>
<li>sort(List, Comparator)</li>
<li>swap(List, int, int)</li>
<li>Object max(Collection)</li>
<li>Object max(Collection, Comparator)</li>
<li>int frequency(Collection, Object)</li>
<li>void copy(List destination, List src):<code>Arrays.toList(new Object[src.size()])</code></li>
<li>boolean replaceAll(List, oldVal, newVal)</li>
<li>synchronizedXxx()</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>类型泛化，默认为Objec类型</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> Map&lt;&gt;();</span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = <span class="keyword">new</span> Set&lt;&gt;()</span><br></pre></td></tr></table></figure>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class MyObject&lt;T&gt;&#123;</span><br><span class="line">    T myObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li>多个泛型参数用逗号隔开</li>
<li>构造器不需要带泛型声明</li>
<li>不同泛型引用不能相互赋值</li>
<li>静态方法中不能使用类的泛型</li>
<li>不能使用new T()</li>
<li><strong>静态方法可以是泛型方法</strong></li>
</ol>
<p><strong>泛型方法</strong>：具有泛型的结构，与类的泛型没有任何关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;E&gt; 说明了他是泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通配符<code>?</code></strong>的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">List&lt;?&gt; = <span class="keyword">new</span> List&lt;&gt;();  <span class="comment">// 公用父类，拒接写入（add），允许读（get）</span></span><br></pre></td></tr></table></figure>
<p>有限制的通配符：</p>
<ul>
<li>&lt;? extends SuperClass&gt;: SuperClass的子类或本身才可以, 往下找，add(Object)</li>
<li>&lt;? super SuperClass&gt;：SuperClass的父类或本身才可以，往上找，add(Person往下)</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>不涉及到文件内容，仅存储文件的路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);  <span class="comment">// 相对于当前的项目路径下</span></span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">"D:\\windows\\program\\hello.txt"</span>);</span><br><span class="line">File file3 = <span class="keyword">new</span> File(<span class="string">"D:\\windows"</span>, <span class="string">"program"</span>);</span><br></pre></td></tr></table></figure>
<p>常用方法：</p>
<ul>
<li>public String getAbsolutePath()</li>
<li>public String getPath()</li>
<li>public String getName()</li>
<li>public String getParent()</li>
<li>public long length()</li>
<li>public long lastModified()</li>
<li>boolean renameTo(File2 file2)</li>
<li>String[] list()：返回路径下的文件名</li>
<li>File[] listFile()：返回文件对象</li>
</ul>
<hr>
<ul>
<li>boolean isDirectory()</li>
<li>boolean isFile()</li>
<li>boolean exists()</li>
<li>boolean canRead()</li>
<li>boolean canWrite()</li>
<li>boolean isHidden()</li>
</ul>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><ul>
<li>字节流：<code>OutputStream</code>, <code>InputStream</code></li>
<li>字符流：<code>Writer</code>, <code>Reader</code></li>
<li>转换流：<code>InputStreamReader</code>, <code>OutputStreamWriter</code></li>
</ul>
<p>字符流读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化File类对象</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"src/ind/IOTest/hello_three.txt"</span>);</span><br><span class="line">        <span class="comment">// 提供具体的流</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = fr.read();  <span class="comment">// 读入一个字符</span></span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>)&#123;  <span class="comment">// 返回-1说明到达文件末尾</span></span><br><span class="line">            System.out.println(data+<span class="string">" "</span>+(<span class="keyword">char</span>)data);</span><br><span class="line">            data = fr.read();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fr!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();  <span class="comment">// 关闭流</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节流使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"src/ind/IOTest/头像.jpg"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"src/ind/IOTest/头像copy.jpg"</span>);</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(f2);</span><br><span class="line">        <span class="keyword">byte</span>[] bcBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bcBuffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bcBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换流：</p>
<ol>
<li>将字节流转为字符流。—-解码过程</li>
<li>再将字符流转为字节流。—-编码过程</li>
</ol>
<p>标准输入输出流：<code>System.in</code>与<code>System.out</code><br>打印流：<code>PrintStream</code><br>数据流：<code>DataInputStream</code>  </p>
<h3 id="对象流（序列化与反序列化）"><a href="#对象流（序列化与反序列化）" class="headerlink" title="对象流（序列化与反序列化）"></a>对象流（序列化与反序列化）</h3><ul>
<li><code>ObjectInputStream</code></li>
<li><code>ObjectOutputStream</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"object.dat"</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> String(<span class="string">"hello!"</span>));</span><br><span class="line">    oos.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义类可序列化的要求：</p>
<ul>
<li>实现<code>java.io.Serializable</code>接口</li>
<li>定义序列版本号属性：<code>private static final long serialVersionUID = 10L;</code>：解决序列化与反序列化过程中，版本不一致的问题</li>
<li>其内部所有属性也必须是可序列化的</li>
</ul>
<h3 id="随机存取文件流（RandomAccessFile类）"><a href="#随机存取文件流（RandomAccessFile类）" class="headerlink" title="随机存取文件流（RandomAccessFile类）"></a>随机存取文件流（RandomAccessFile类）</h3><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>服务器端例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        Socket s = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line">            s = ss.accept();</span><br><span class="line">            is = s.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len=is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ss != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket s = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress ia = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">            s = <span class="keyword">new</span> Socket(ia, <span class="number">8899</span>);</span><br><span class="line">            os = s.getOutputStream();</span><br><span class="line">            os.write(<span class="string">"hello! this is client."</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射-动态性"><a href="#反射-动态性" class="headerlink" title="反射(动态性)"></a>反射(动态性)</h2><p>反射示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">26</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        <span class="comment">// 反射的使用</span></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        Object obj = cons.newInstance(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">        Person p1 = (Person) obj;</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">        <span class="comment">// 访问非私有属性</span></span><br><span class="line">        Field nameFiled = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        nameFiled.set(p1, <span class="string">"Lily"</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        <span class="comment">// 访问非私有方法</span></span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">"list"</span>);  <span class="comment">// 调用public方法</span></span><br><span class="line">        method.invoke(p1);</span><br><span class="line">        <span class="comment">//---------------------------------</span></span><br><span class="line">        <span class="comment">// 调用私有成员</span></span><br><span class="line">        Method method1 = clazz.getDeclaredMethod(<span class="string">"show"</span>);</span><br><span class="line">        method1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">double</span> res = (<span class="keyword">double</span>) method1.invoke(p1);  <span class="comment">// 接受返回值Object转型</span></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is person."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"list: 1, 2, 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ol>
<li>javac命令编译java源文件，生成字节码文件（.class结尾）</li>
<li>使用java命令对某个字节码文件解释执行。相当于将某个类文件加载打内存中去。称为<strong>运行类，并作为Class类的一个实例。</strong></li>
</ol>
<h3 id="如何获取Class实例"><a href="#如何获取Class实例" class="headerlink" title="如何获取Class实例"></a>如何获取Class实例</h3><ul>
<li><code>Class&lt;Person&gt; clazz = Person.class;</code></li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz = p.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Class clazz = Class.forName(&quot;ind.Reflection.Person&quot;);</code></p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = ClassLoaderDemo.class.getClassLoader();</span><br><span class="line">Class clazz3 = classLoader.loadClass(<span class="string">"ind.Reflection.Person"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>加载过程（类加载器ClassLoader）：</p>
<ul>
<li>加载：将class字节文件加载到内存中去，将静态数据转换为方法区的运行时数据结构</li>
<li>链接：为类变量分配内存，将常量替换为地址引用</li>
<li>初始化：执行类构造器\<clinit\>()方法的过程</clinit\></li>
</ul>
]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>模型评估与选择（参考自西瓜书）</title>
    <url>/2020/06/03/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h2 id="经验误差与过拟合"><a href="#经验误差与过拟合" class="headerlink" title="经验误差与过拟合"></a>经验误差与过拟合</h2><ul>
<li><strong>错误率</strong>：如果在$m$个样本中有$a$个样本分类错误，则错误率$E=\frac{a}{m}$</li>
<li><strong>精度(accuracy)</strong>：$1-\frac{a}{m}$，即“精度=1-错误率”</li>
<li><strong>误差：学习器的实际预测输出与样本的真实输出之间的差异</strong>。</li>
<li><strong>训练误差：学习器在训练集上的误差。</strong></li>
<li><strong>泛化误差：学习器在新样本上的误差。</strong></li>
<li><strong>过拟合(overfitting)</strong>与<strong>欠拟合(underfitting)</strong></li>
</ul><a id="more"></a>
<h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><h3 id="数据集的划分"><a href="#数据集的划分" class="headerlink" title="数据集的划分"></a>数据集的划分</h3><ol>
<li>留出法：直接将数据集$D$划分为两个互斥的集合，其中一个作为训练集$S$，另一个作为测试集$T$，即$D=S\cup T, S\cap T=\phi$。为了保证划分后数据分布的一致性。通常采用“分层抽样”(stratified sampling)的方法。</li>
<li>交叉验证法：将数据集$D$划分为$k$个大小相似的互斥子集，即$D=D_{1}\cup D_{2}\cup…\cup D_{k},D_{i}\cap D_{j}=\phi(i\neq j)$，每个子集$D_{i}$都尽可能保证数据分布的一致性，即来自分层抽样。<strong>然后每次用$k-1$个子集的并集作为训练集，剩下的那个子集作为测试集</strong>，这样就得到$k$组 训练/测试集，<strong>从而可以进行$k$次训练和测试，最终返回的是这$k$个测试结果的均值，称为“$k$折交叉验证”(k-fold cross validation)</strong></li>
<li>自助法(bootstrapping)：给定包含$m$个样本的数据集$D$，我们对它进行采样产生数据集$D’$：<strong>每次随机从$D$中挑选一个样本，将其拷贝放入$D’$，然后再将该样本放入$D$中，使得该样本在下次采样时任有可能被采到；重复这个过程$m$次后，我们就得到了含有$m$个样本的数据集$D’$</strong>。做一个简单的估计，样本每次采样不被采到的概率为$1-\frac{1}{m}$，则$m$次不被猜到的概率为$(1-\frac{1}{m})^m$，当$m$足够大时有：<script type="math/tex; mode=display">
\lim_{m\to\infty}(1-\frac{1}{m})^m\mapsto\frac{1}{e}\approx0.368</script>即通过自助采样，初始数据集$D$中大约有$36.8\%$的样本没有出现在$D’$中。适用于数据集较小，难以划分的数据集。</li>
</ol>
<h3 id="调参与最终模型"><a href="#调参与最终模型" class="headerlink" title="调参与最终模型"></a>调参与最终模型</h3><h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>回归任务中常用的<strong>均方误差</strong>：</p>
<script type="math/tex; mode=display">
E(f;D)=\frac{1}{m}\sum_{i=1}^m(f(\mathbf{x}_{i})-y_{i})^2</script><p>更一般的，对于数据分布$\mathfrak{D}$和概率密度函数$p(\cdot)$，均方误差可描述为</p>
<script type="math/tex; mode=display">
E(F;\mathfrak{D})=\int_{x\sim\mathfrak{D}}(f(\mathbf{x}_{i}-y)^2)p(\mathbf{x})dx</script><h3 id="查准率、查全率与-F1"><a href="#查准率、查全率与-F1" class="headerlink" title="查准率、查全率与$F1$"></a>查准率、查全率与$F1$</h3><p>对于二分类问题，可将样例的真实类别与学习器的预测类别的组合划分为：</p>
<ul>
<li>真正例(true positive)：预测的正例实际上就是正例</li>
<li>假正例(false positive)：预测的正例实际上是反例</li>
<li>真反例(true negative)：预测的反例实际上就是负例</li>
<li>假反例(false negative)：预测的反例实际上是正例</li>
</ul>
<p>由以上的概念可以得出，$真实的正例=TP+FN,真实的反例=TN+FP,预测的正例=TP+FP,预测的反例=TN+FN$，可组成混淆矩阵（confusion matrix）。</p>
<ul>
<li>查准率：$P=\frac{TP}{TP+FP}=\frac{预测正确的正例}{预测的正例数}$，即考量预测正例的准确率</li>
<li>查全率：$R=\frac{TP}{TP+FN}=\frac{预测正确的正例}{真实的正例数}$，即考量预测正例的完整率</li>
<li>P-R曲线与平衡点（Break-Event Point，简称BEP，它是查准率=查全率时的取值）</li>
<li>$F1$度量比平衡点更常用：<script type="math/tex; mode=display">F1=\frac{2\times P\times R}{P+R}=\frac{2\times TP}{样例总数+TP-TN}</script></li>
<li>对查全率与查准率的重视程度不同，定义$\beta&gt;0$度量了查全率对查准率的相对重要性：<script type="math/tex; mode=display">
F_{\beta}=\frac{(1+\beta^2)\times P\times R}{(\beta^2\times P)+R}</script></li>
<li>很多时候会多次的训练/测试，得到多个混淆矩阵。从而使用各种指标的<strong>均值</strong>来进行考量</li>
</ul>
<h3 id="ROC与AUC"><a href="#ROC与AUC" class="headerlink" title="ROC与AUC"></a>ROC与AUC</h3><p>ROC(Reveiver Operating Characteristic)全称是“受试者工作特征”，它考察“真正例率”(TPR)与“假正例率”(FPR):</p>
<script type="math/tex; mode=display">
TPR=\frac{TP}{TP+FN}=\frac{预测正确的正例}{真实的正例数}
\\ FPR=\frac{FP}{FP+TN}=\frac{预测错误的正例}{真实的反例数}</script><p>AUC即ROC曲线下的面积</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>模型评估</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论一：随机事件与概率</title>
    <url>/2020/06/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%80/</url>
    <content><![CDATA[<h2 id="随机事件"><a href="#随机事件" class="headerlink" title="随机事件"></a>随机事件</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>随机事件：</p><ul>
<li>随机现象的一切可能基本结果组成的集合称为<strong>样本空间</strong>，记为$\Omega=\left\{ \omega \right\}$，其中$\omega$为基本结果，又称为<strong>样本点</strong>。</li>
<li>随机现象的某些样本点组成的集合称为<strong>随机事件</strong>，常用大写字母$A,B,C,…$表示。由样本空间$\Omega$中的单个元素组成的子集称为<strong>基本事件</strong>。</li>
<li>如果$A$与$B$没有相同的样本点，则称$A$与$B$</li>
<li>事件$A$的<strong>对立事件</strong>$\bar{A}$，由在$\Omega$中而不在$A$中的样本点组成的新事件。</li>
<li>德摩根律：$\bar{A\cup B}=\bar{A}\cap\bar{B}$</li>
</ul><a id="more"></a>

<p>概率的性质：</p>
<ul>
<li>若$A\supset B$，则<script type="math/tex; mode=display">
P(A-B)=P(A)-P(B)</script></li>
<li>对任意两个事件$A,B$，有<script type="math/tex; mode=display">
P(A-B)=P(A)-P(AB)</script></li>
<li>条件概率：在$B$发生下$A$的条件概率：<script type="math/tex; mode=display">
P(A|B)=\frac{P(AB)}{P(B)},其中AB是事件A和B的交</script> <strong>可以理解为：在事件B发生的所有现象中A也同时发生的现象</strong></li>
<li><strong>乘法公式：</strong><script type="math/tex; mode=display">
\begin{aligned}
P(A|B)P(B)=P(AB)
\end{aligned}\tag{1}</script>若$P(A_{1}A_{2}…A_{n-1})&gt;0$<script type="math/tex; mode=display">
\begin{aligned}
P(A_{1}A_{2}...A_{n})
&=P(A_{1})\cdot \frac{P(A_{1}A_{2})}{P(A_{1})}\cdot \frac{P(A_{1}A_{2}A_{3})}{P(A_{1}A_{2})}\cdot\cdots\cdot \frac{P(A_{1}A_{2}...A_{n})}{P(A_{1}A_{2}...A_{n-1})}\\
&=P(A_{1})\cdot P(A_{2}|A_{1})\cdot P(A_{3}|A_{1}A_{2})\cdot\cdots\cdot P(A_{n}|P(A_{1}A_{2}...A_{n-1}))
\end{aligned}\tag{2}</script></li>
<li><strong>全概率公式</strong>：设$B_{1},B_{2},…,B_{n}$为样本空间$\Omega$的一个<strong>分割</strong>，如果$P(B_{i})&gt;0$，则对任意事件$A$有<script type="math/tex; mode=display">
\begin{aligned}
P(A)&=\sum_{i=1}^{n}P(B_{i})P(A|B_{i})\\
&=\sum_{i=1}^{n}P(AB_{i})
\end{aligned}</script><strong>可以理解为：$P(事件A)=\sum P(事件A与样本空间中每个不相容事件B_{i}的交)$</strong></li>
<li><strong>贝叶斯公式</strong>：设$B_{1},B_{2},…,B_{n}$为样本空间$\Omega$的一个<strong>分割</strong>，如果$P(B_{i})&gt;0,P(A)&gt;0$，则<script type="math/tex; mode=display">
\begin{aligned}
P(B_{i}|A)&=\frac{P(AB_{i})}{P(A)}
\\&=\frac{P(A|B_{i})P(B_{i})}{\sum_{i=1}^{n}P(AB_{i})}
\\&=\frac{P(A|B_{i})P(B_{i})}{\sum_{j=1}^{n}P(A|B_{j})P(B_{j})}
\end{aligned}</script><strong>可以理解为：每个被分割的不相容事件$B_{i}$在任意事件$A$发生的条件下的概率可以由每个事件$B_{i}$的概率和事件$A$在分割事件发生的条件下的概率$P(A|B_{i})$所求得</strong></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>条件概率</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2020/06/01/linear-reg/</url>
    <content><![CDATA[<h2 id="线性模型的推导-参考自西瓜书"><a href="#线性模型的推导-参考自西瓜书" class="headerlink" title="线性模型的推导(参考自西瓜书)"></a>线性模型的推导(参考自西瓜书)</h2><p>原问题：假设有$m$个样本$D=\left\{(\mathbf{x}_{1},y_{1}),(\mathbf{x}_{2},y_{2}),…,(\mathbf{x}_{m},y_{m}) \right\}$，每个样本$\mathbf{x}_{i}=\left ( x_{1},x_{2},…,x_{d} \right )$有$d$个特征，一个目标值$y_{i}=y$</p><a id="more"></a>
<h3 id="单变量的线性回归"><a href="#单变量的线性回归" class="headerlink" title="单变量的线性回归"></a>单变量的线性回归</h3><p>考虑最简单的只有<strong>一个特征</strong>的样本$(x_{i}, y_{i})$，线性回归试图学习：</p>
<script type="math/tex; mode=display">
f(x_{i})=wx_{i}+b,使得f(x_{i})渐进等于y_{i}</script><p>为了求得$w$和$b$，则需使用均方误差作为性能度量，并使均方误差最小化：</p>
<script type="math/tex; mode=display">
(w, b) = \arg\limits_{(w, b)}\min\sum_{i=1}^{m}\left(wx_{i}+b-y_{i} \right)^{2}</script><p>令$E(w,b)=\sum_{i=1}^{m}\left(wx_{i}+b-y_{i} \right)^{2}$分别对$w$和$b$求偏导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial E(w,b)}{\partial w}&=2\cdot x_{i}\cdot \sum_{i=1}^{m}(wx_{i}+b-y_{i})
\\ &=2\sum_{i=1}^{m}(wx_{i}^{2}+bx_{i}-x_{i}y_{i})
\\ &=2(\sum_{i=1}^{m}wx_{i}^{2}+\sum_{i=1}^{m}x_{i}(b-y_{i}))
\end{aligned} \tag{1}</script><p>对$b$:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial E(w,b)}{\partial b}&=2\cdot \sum_{i=1}^{m}(wx_{i}+b-y_{i})
\\&=2(\sum_{i=1}^{m}wx_{i}+\sum_{i=1}^{m}b-\sum_{i=1}^{m}y_{i})
\\&=2(\sum_{i=1}^{m}wx_{i}+mb-\sum_{i=1}^{m}y_{i})
\end{aligned} \tag{2}</script><p>从以上$w$和$b$的导函数中可以看出相关变量的系数$\sum_{i=1}^{m}x_{i}^{2}$与$m$都为<strong>正数</strong>，故对应的导函数都为<strong>增函数</strong>，故当导函数值取0时对应的极值为。令$(1)$式和$(2)$式为值为0，可推导出$w$和$b$的表达式。$先令x的均值\bar{x}=\frac{1}{m}\sum_{i=1}^{m}x_{i}$，先推导$b$的表达式：</p>
<script type="math/tex; mode=display">
令\frac{\partial E(w,b)}{\partial b}=0 \\
\Rightarrow \sum_{i=1}^{m}wx_{i}+mb-\sum_{i=1}^{m}y_{i}=0 \\
\Rightarrow b=\frac{1}{m}\sum_{i=1}^{m}y_{i}-\frac{1}{m}\sum_{i=1}^{m}wx_{i} \tag{3}</script><p>再推导$w$的表达式：</p>
<script type="math/tex; mode=display">
令\frac{\partial E(w,b)}{\partial w}=0 \\
\Rightarrow \sum_{i}^{m}wx_{i}^{2}+\sum_{i=1}^{m}x_{i}b-\sum_{i=1}^{m}x_{i}y_{i}=0
\\ 带入(3)\Rightarrow \sum_{i=1}^{m}wx_{i}^{2}+\sum_{i=1}^{m}x_{i}(\frac{1}{m}\sum_{i=1}^{m}y_{i}-\frac{1}{m}\sum_{i=1}^{m}wx_{i})-\sum_{i=1}^{m}x_{i}y_{i}=0
\\ 化简 \Rightarrow \sum_{i=1}^{m}wx_{i}^{2}+\frac{1}{m}\sum_{i=1}^{m}x_{i}\sum_{i=1}^{m}y_{i}-\frac{w}{m}(\sum_{i=1}^{m}x_{i})^{2}-\sum_{i=1}^{m}x_{i}y_{i}=0
\\ 化简合并 \Rightarrow w(\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2})+\sum_{i=1}^{m}(\bar{x}-x_{i})y_{i}=0
\\ \Rightarrow w = \frac{\sum_{i=1}^{m}y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2}}</script><p>求得的两个表达式为：</p>
<script type="math/tex; mode=display">
w = \frac{\sum_{i=1}^{m}y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2}}, \qquad
b=\frac{1}{m}\sum_{i=1}^{m}y_{i}-\frac{1}{m}\sum_{i=1}^{m}wx_{i}</script><h3 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><p>考虑多个特征的样本$\mathbf{x}_{i}=\left ( x_{1},x_{2},…,x_{d} \right )$，多元线性回归试图学习：</p>
<script type="math/tex; mode=display">
f(x_{i})=w^{T}x_{i}+b,使得f(x_{i})渐进等于y_{i}</script><p>为了便于向量的运算，令$\hat{w}=(w;b)=\binom{w}{b}$，把数据集$D$表示为一个$m\times(d+1)大小的矩阵：$</p>
<script type="math/tex; mode=display">
X=\begin{Bmatrix}
 &x_{11}  &x_{12}&...&x_{1d} &1\\
 &x_{21}  &x_{22}&...&x_{2d} &1\\
 &...  &...  &...  &... &...\\
 &x_{m1}  &x_{m2}  &...  &x_{md} &1
\end{Bmatrix}=\begin{pmatrix}
\mathbf{x}_{1}^{T} &1\\
\mathbf{x}_{2}^{T} &1\\
... &...\\
\mathbf{x}_{m}^{T} &1
\end{pmatrix}</script><p>再把目标值也写成向量的形式：$\mathbf{y}=\begin{pmatrix}<br>y_{1}\\<br>y_{2}\\<br>…\\<br>y_{m}<br>\end{pmatrix}$，则类似有：</p>
<script type="math/tex; mode=display">
\hat{w}=\arg\min(\mathbf{y}-X\hat{w})^{T}(\mathbf{y}-X\hat{w})</script><p>令$E_{\hat{w}}=(\mathbf{y}-X\hat{w})^{T}(\mathbf{y}-X\hat{w})$,对$\hat{w}$求导得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial E_{\hat{w}}}{\partial \hat{w}}&=\triangledown_{\hat{w}}(\mathbf{y}^{T}-\hat{w}^{T}X^{T})(\mathbf{y}-X\hat{w})
\\ &=\triangledown_{\hat{w}}(\mathbf{y}^{T}\mathbf{y}-y^{T}X\hat{w}-\hat{w}^{T}X^{T}\mathbf{y}+\hat{w}^{T}X^{T}X\hat{w})
\\ &=0-(\mathbf{y}^{T}X)^{T}-X^{T}\mathbf{y}+(X^{T}X\hat{w}+(\hat{w}X^{T}X)^{T})
\\ &=-2X^{T}\mathbf{y}+2X^{T}X\hat{w}
\\ &=2X^{T}(X\hat{w}-\mathbf{y})
\end{aligned}
\\ 这里的矩阵求导法则用了如下两个公式: \\ 
\frac{\partial(A^{T}WB)}{\partial W}=AB^{T},\frac{\partial(A^{T}W^{T}B)}{\partial W}=BA^{T}</script><p>令上式为零即可推导出$\hat{w}$的表达式：</p>
<script type="math/tex; mode=display">
2X^{T}(X\hat{w}-\mathbf{y})=0
\Rightarrow X^{T}X\hat{w}=X^{T}\mathbf{y}
\\ \Rightarrow \hat{w}=(X^{T}X)^{-1}X^{T}\mathbf{y}</script><p>令每个样本为$\hat{x}_{i}=(\mathbf{x}_{i},1)$，得最终的多元线性回归模型：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(\hat{x}_{i})&=(\mathbf{x}_{i},1)\begin{pmatrix}
w\\
b
\end{pmatrix}=\hat{x}_{i}\hat{w}\\&=\hat{x}_{i}(X^{T}X)^{-1}X^{T}\mathbf{y}
\end{aligned}</script><p>显然，上式能成立的基本条件就是矩阵$X^{T}X$可逆（即满秩矩阵），<strong>当特征的数量大于样本的数量时矩阵就不可逆了</strong>。</p>
<h3 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h3><script type="math/tex; mode=display">
g(y)=w^{T}x+b\\ \Rightarrow \\
y = g^{-1}(w^{T}x+b)</script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>linear regression</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶</title>
    <url>/2020/04/27/python%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="python类特殊方法"><a href="#python类特殊方法" class="headerlink" title="python类特殊方法"></a>python类特殊方法</h2><ol>
<li><p>__init__ 和 __new__</p>
<p>init方法<strong>不是类的构造方法，其作用是返回实例</strong>，new方法才是<strong>类的构造方法</strong>，通过继承<strong>object</strong>类重写改方法</p>
</li>
<li><p>__enter__ 和 __exit__</p>
<p>enter作用是<strong>初始化后返回实例</strong>，exit作用是<strong>退出with语句后做处理，例如清理内存，关闭文件，删除冗余等</strong></p>
</li>
<li><p>__str__ 和 __repr__</p>
<p>str方法是用于<strong>将实例的信息以字符串的形式输出</strong>，repr方法与str作用相同，不同在于<strong>repr方法用于交互式环境调试</strong></p>
</li>
<li><p>__setattr__ 、__getattr__、__getattribute__ 、__delattr__</p>
<p>setattr用于<strong>设置属性</strong>，getattr用于<strong>获取不存在的属性</strong>，getattribute用于<strong>访问存在的属性</strong>，delattr用于<strong>删除属性</strong></p>
</li>
</ol><a id="more"></a>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><ul>
<li>迭代器：可迭代对象皆为迭代器，用户自定义对象通过实现iter方法和next方法实现迭代器。</li>
<li>生成器：特殊的迭代器，更节省内存（call for need）</li>
</ul>
<h2 id="args和-kwargs"><a href="#args和-kwargs" class="headerlink" title="*args和**kwargs"></a>*args和**kwargs</h2><ul>
<li>*args：表示多个<strong>无名参数</strong>，返回其组成的tuple</li>
<li>**kwargs：表示<strong>key=value关键字型参数</strong>，返回一个dict</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ol>
<li><p>普通装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decoration</span><span class="params">(func)</span>:</span>  <span class="comment"># 装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125; is running."</span>.format(func__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 返回被包装函数</span></span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>带参数的装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_param</span><span class="params">(level)</span>:</span>  <span class="comment"># 带参数的装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_decoration</span><span class="params">(func)</span>:</span>  <span class="comment"># 内部装饰器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"&#123;&#125; is running."</span>.format(func.__name__))</span><br><span class="line">            print(<span class="string">"this level is &#123;&#125;"</span>.format(level))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 返回被包装函数</span></span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装函数</span></span><br><span class="line">    <span class="keyword">return</span> my_decoration  <span class="comment"># 返回装饰器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span>  <span class="comment"># 类装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"this is class decorator."</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        print(<span class="string">"ending..."</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>functools.wraps:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decoration</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 负责保护原函数的doc和name的装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
</li>
<li><p>装饰器的执行顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="meta">@d3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>等价于<code>func = d1(d2(d3(func)))</code></p>
</li>
<li><p>内部装饰器</p>
<ul>
<li>@staticmethod: 将类中函数修饰为静态方法不需要额外的参数（self等），<strong>不能访问类中的参数</strong></li>
<li>@classmethod: 函数必须包含一个类参数<strong>cls</strong>，返回一个实例，<strong>可访问类中的成员</strong></li>
<li>@property: <strong>将函数作为类的属性</strong>，进而使函数拥有setter方法和deletter方法，其本身是getter方法</li>
</ul>
</li>
<li><p>协程、多线程、多进程</p>
<ul>
<li>async</li>
<li>threading</li>
<li>multiprocessing</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫：豆瓣短评</title>
    <url>/2019/11/28/python%E7%88%AC%E8%99%AB%E8%B1%86%E7%93%A3%E7%9F%AD%E8%AF%84/</url>
    <content><![CDATA[<h2 id="导入必要的包-package"><a href="#导入必要的包-package" class="headerlink" title="导入必要的包(package)"></a>导入必要的包(package)</h2><p>若没有下列的包，可使用<code>pip install 包名</code>命令安装</p><ul>
<li>re: 使用正则表达式</li>
<li>json: 解析json内容</li>
<li>time: 爬虫间歇时间控制</li>
<li>jieba: 中文分词库</li>
<li>urlib: 将中文关键字编码(百分号+数字)</li>
<li>requests: 向网站发出请求</li>
<li>bs4: 解析网页内容</li>
<li>wordcloud: 生成词云</li>
</ul><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<h2 id="项目需求：爬取豆瓣的书评和影评概要"><a href="#项目需求：爬取豆瓣的书评和影评概要" class="headerlink" title="项目需求：爬取豆瓣的书评和影评概要"></a>项目需求：爬取豆瓣的书评和影评概要</h2><ul>
<li><strong>输入指定的书籍名称和电影名称，返回其评论构成的词云。</strong></li>
</ul>
<h3 id="网站分析-豆瓣电影和豆瓣读书"><a href="#网站分析-豆瓣电影和豆瓣读书" class="headerlink" title="网站分析(豆瓣电影和豆瓣读书)"></a>网站分析(豆瓣电影和豆瓣读书)</h3><p>我们豆瓣电影为例，爬取豆瓣读书原理相仿。</p>
<ul>
<li><strong>豆瓣电影</strong>：主页网址<a href="https://movie.douban.com/" target="_blank" rel="noopener">https://movie.douban.com/</a>，其页面如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_1.png" alt="movie.com">  </li>
</ul>
<p>首先我们打开谷歌浏览器的开发者工具，如果我们要搜索电影则在搜索框中键入搜索关键字是最近刚出的电影<strong>小丑</strong>，则会弹出下拉列表，并且旁边的Network中会显示出刚刚的响应：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_2.png" alt="xiaochou"><br>我们可以发现出现了一个json文件，这个json文件即是下拉列表的信息：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_3.png" alt="list"><br>我们再看看它的url，也就是我们爬虫目标网址，同时我们也能找到需要的请求头headers，可以发现它将我们的搜索关键字重新编码了(%+数字)，这个我们稍后用urllib处理编码：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_6.png" alt="head"><br>继续分析json文件，json文件中的内容就是每个电影的网址，列表中第一个地址即是我们要找的<strong>小丑</strong>的网址主页：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_4.png" alt="xiaochou"><br>我们点进小丑的主页进行验证，网址中的那串数字就是我们需要解析出来的电影唯一标识：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_5.png" alt="zhuye"><br>最后我们来看我们的目的地评论的网址，往下翻，点击全部评论：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_7.png" alt="com"><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_8.png" alt="com1"><br>发现网址并没有什么规律，我们继续点击评论的下一页，规律出现了。每增加一页，start参数增加20，这便是我们批量爬取评论的根据：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_9.png" alt="page"><br>好，我们继续看评论在html文件中的位置：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/2.png" alt="loc"><br>ok，分析完毕，爬虫抓取大概就是这个流程，最终的目的就是找到<strong>需求信息的位置</strong>。</p>
<h3 id="爬虫设计"><a href="#爬虫设计" class="headerlink" title="爬虫设计"></a>爬虫设计</h3><p>根据以上的分析，我们这样来设计我们的爬虫的爬虫流程：</p>
<ol>
<li>将我们输入的关键字编码成网址中的编码类型。</li>
<li>获取json中电影的真实地址信息。</li>
<li>生成我们要访问的评论所在的网页地址</li>
<li>抓取评论信息。</li>
</ol>
<h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>接下来给出几个关键步骤的代码说明</p>
<h3 id="汉字编码"><a href="#汉字编码" class="headerlink" title="汉字编码"></a>汉字编码</h3><p>使用<code>urllib.parse</code>中的<code>quote</code>函数进行编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__handle_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    编码中文关键字(%+[00-99])</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> str(quote(name))</span><br></pre></td></tr></table></figure>
<h3 id="解析json获取地址"><a href="#解析json获取地址" class="headerlink" title="解析json获取地址"></a>解析json获取地址</h3><p>使用<code>json</code>库中的<code>loads</code>函数解析json文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__find_url</span><span class="params">(self, url, tp)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取真实主页地址和编号id</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    r = requests.get(url, headers=self.headers[tp])</span><br><span class="line">    json_data = json.loads(r.text)</span><br><span class="line">    address_num = re.search(<span class="string">'[0-9]+'</span>, json_data[<span class="number">0</span>][<span class="string">'url'</span>])</span><br><span class="line">    <span class="keyword">if</span> tp == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> self.movie_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取电影地址</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.book_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取书籍地址</span></span><br></pre></td></tr></table></figure>
<h3 id="使用WordCloud生成词云"><a href="#使用WordCloud生成词云" class="headerlink" title="使用WordCloud生成词云"></a>使用WordCloud生成词云</h3><p>使用<code>WordCloud</code>生成词云，用<code>jieba</code>进行中文分词。该函数中有两个变量需要解释：</p>
<ul>
<li>bg_image: 为词云添加背景图片。</li>
<li>scale: 词云图片的清晰度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__plot_wordcloud</span><span class="params">(self, name, bg_image=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    绘制词云</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    file_name = str(name) + <span class="string">'.txt'</span></span><br><span class="line">    f = open(file_name, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>).read()</span><br><span class="line">    cut_text = <span class="string">" "</span>.join(jieba.cut(f))  <span class="comment"># 中文分词</span></span><br><span class="line">    print(<span class="string">"正在生成词云..."</span>)</span><br><span class="line">    word_cloud = WordCloud(</span><br><span class="line">        scale=<span class="number">10</span>,</span><br><span class="line">        font_path=<span class="string">'C:/Windows/Fonts/simfang.ttf'</span>,</span><br><span class="line">        background_color=<span class="string">"white"</span>, width=<span class="number">1000</span>, height=<span class="number">1000</span></span><br><span class="line">    ).generate(cut_text)</span><br><span class="line">    plt.imshow(word_cloud, interpolation=<span class="string">'bilinear'</span>)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="完整代码及运行示例"><a href="#完整代码及运行示例" class="headerlink" title="完整代码及运行示例"></a>完整代码及运行示例</h2><p>将整个爬虫过程封装，根据上述爬取电影评论的方法同时也实现了爬取数据评论的方法，最后爬取了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanCrawl</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, info_type)</span>:</span></span><br><span class="line">        self.info_type = info_type</span><br><span class="line">        self.headers = [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'movie.douban.com'</span></span><br><span class="line">            &#125;,  <span class="comment"># movie's headers</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'book.douban.com'</span></span><br><span class="line">            &#125;  <span class="comment"># book's headers</span></span><br><span class="line">        ]</span><br><span class="line">        self.movie_search_url = <span class="string">"https://movie.douban.com/j/subject_suggest?q="</span></span><br><span class="line">        self.movie_url = <span class="string">"https://movie.douban.com/subject/%s/"</span></span><br><span class="line">        self.movie_comment_url = <span class="string">"https://movie.douban.com/subject/%s/comments?start=%d&amp;limit=20&amp;sort=new_score&amp;status=P"</span></span><br><span class="line"></span><br><span class="line">        self.book_search_url = <span class="string">"https://book.douban.com/j/subject_suggest?q="</span></span><br><span class="line">        self.book_url = <span class="string">"https://book.douban.com/subject/%s/"</span></span><br><span class="line">        self.book_comment_url = <span class="string">"https://book.douban.com/subject/%s/comments/hot?p=%d"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_crawl</span><span class="params">(self, name, bg_image=None)</span>:</span></span><br><span class="line">        name_str = self.__handle_name(name)  <span class="comment"># 获取url的gbk编码</span></span><br><span class="line">        text_list = []</span><br><span class="line">        <span class="keyword">if</span> self.info_type == <span class="string">"movie"</span>:</span><br><span class="line">            print(<span class="string">"-----爬取电影短评-----"</span>)</span><br><span class="line">            self.movie_search_url += name_str</span><br><span class="line">            self.movie_url, num_str = self.__find_url(self.movie_search_url, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">15</span>):</span><br><span class="line">                url = self.movie_comment_url % (num_str, i*<span class="number">20</span>)</span><br><span class="line">                time.sleep(np.random.randint(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 间隔1~3秒</span></span><br><span class="line">                print(<span class="string">"正在获取第%d个页面"</span> % i)</span><br><span class="line">                r = requests.get(url, headers=self.headers[<span class="number">0</span>])</span><br><span class="line">                soup = BeautifulSoup(r.content, <span class="string">'lxml'</span>)</span><br><span class="line">                comment_list = soup.find_all(<span class="string">'span'</span>, class_=<span class="string">'short'</span>)</span><br><span class="line">                <span class="keyword">for</span> ct <span class="keyword">in</span> comment_list:</span><br><span class="line">                    text_list.append(ct.text)</span><br><span class="line">            self.__comment_to_txt(name, text_list)  <span class="comment"># 存储评论文字</span></span><br><span class="line">            self.__plot_wordcloud(name, bg_image)  <span class="comment"># 绘制词云</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"-----爬取书籍短评-----"</span>)</span><br><span class="line">            self.book_search_url += name_str</span><br><span class="line">            self.book_url, num_str = self.__find_url(self.book_search_url, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">20</span>):</span><br><span class="line">                url = self.book_comment_url % (num_str, i)</span><br><span class="line">                time.sleep(np.random.randint(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 间隔1~3秒</span></span><br><span class="line">                print(<span class="string">"正在获取第%d个页面"</span> % i)</span><br><span class="line">                r = requests.get(url, headers=self.headers[<span class="number">1</span>])</span><br><span class="line">                soup = BeautifulSoup(r.content, <span class="string">'lxml'</span>)</span><br><span class="line">                comment_list = soup.find_all(<span class="string">'span'</span>, class_=<span class="string">'short'</span>)</span><br><span class="line">                <span class="keyword">for</span> ct <span class="keyword">in</span> comment_list:</span><br><span class="line">                    text_list.append(ct.text)</span><br><span class="line">            self.__comment_to_txt(name, text_list)</span><br><span class="line">            self.__plot_wordcloud(name, bg_image)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__plot_wordcloud</span><span class="params">(self, name, bg_image=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        绘制词云</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :param bg_image:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        file_name = str(name) + <span class="string">'.txt'</span></span><br><span class="line">        f = open(file_name, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>).read()</span><br><span class="line">        cut_text = <span class="string">" "</span>.join(jieba.cut(f))</span><br><span class="line">        print(<span class="string">"正在生成词云..."</span>)</span><br><span class="line">        word_cloud = WordCloud(</span><br><span class="line">            scale=<span class="number">10</span>,</span><br><span class="line">            font_path=<span class="string">'C:/Windows/Fonts/simfang.ttf'</span>,</span><br><span class="line">            background_color=<span class="string">"white"</span>, width=<span class="number">1000</span>, height=<span class="number">1000</span></span><br><span class="line">        ).generate(cut_text)</span><br><span class="line">        plt.imshow(word_cloud, interpolation=<span class="string">'bilinear'</span>)</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__comment_to_txt</span><span class="params">(self, name, clist)</span>:</span></span><br><span class="line">        file_name = str(name) + <span class="string">'.txt'</span></span><br><span class="line">        <span class="keyword">with</span> open(file_name, <span class="string">'a+'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> clist:</span><br><span class="line">                f.write(c)</span><br><span class="line">            f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__handle_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        编码中文关键字</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> str(quote(name))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__find_url</span><span class="params">(self, url, tp)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取真实主页地址和编号id</span></span><br><span class="line"><span class="string">        :param url:</span></span><br><span class="line"><span class="string">        :param tp:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        r = requests.get(url, headers=self.headers[tp])</span><br><span class="line">        json_data = json.loads(r.text)</span><br><span class="line">        address_num = re.search(<span class="string">'[0-9]+'</span>, json_data[<span class="number">0</span>][<span class="string">'url'</span>])</span><br><span class="line">        <span class="keyword">if</span> tp == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.movie_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取电影地址</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.book_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取书籍地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    my_crawl = DoubanCrawl(<span class="string">"movie"</span>)</span><br><span class="line">    my_crawl.info_crawl(<span class="string">'千与千寻'</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-----爬取电影短评-----</span><br><span class="line">正在获取第0个页面</span><br><span class="line">正在获取第1个页面</span><br><span class="line">正在获取第2个页面</span><br><span class="line">正在获取第3个页面</span><br><span class="line">正在获取第4个页面</span><br><span class="line">正在获取第5个页面</span><br><span class="line">正在获取第6个页面</span><br><span class="line">正在获取第7个页面</span><br><span class="line">正在获取第8个页面</span><br><span class="line">正在获取第9个页面</span><br><span class="line">正在获取第10个页面</span><br><span class="line">正在获取第11个页面</span><br><span class="line">正在获取第12个页面</span><br><span class="line">正在获取第13个页面</span><br><span class="line">正在获取第14个页面</span><br><span class="line">Building prefix dict from the default dictionary ...</span><br><span class="line">Loading model from cache C:\Users\SkecisAI\AppData\Local\Temp\jieba.cache</span><br><span class="line">Loading model cost 0.879 seconds.</span><br><span class="line">Prefix dict has been built succesfully.</span><br><span class="line">正在生成词云...</span><br></pre></td></tr></table></figure>
<p><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/2_1.png" alt="cloud"></p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之道</title>
    <url>/2019/11/22/python%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本文使用python实现了一些常用的排序方法。文章结构如下如下：</p><ol>
<li><a href="#直接插入排序">直接插入排序</a></li>
<li><a href="#希尔排序">希尔排序</a></li>
<li><a href="#冒泡排序">冒泡排序</a></li>
<li><a href="#快速排序">快速排序</a></li>
<li><a href="#简单选择排序">简单选择排序</a></li>
<li><a href="#堆排序">堆排序</a></li>
<li><a href="#归并排序">归并排序</a></li>
<li><a href="#基数排序">基数排序</a></li>
</ol><a id="more"></a>

<p><strong>上述所有的排序均写在一个python自定义类中，作为成员函数。</strong></p>
<h2 id="排序方法详细介绍"><a href="#排序方法详细介绍" class="headerlink" title="排序方法详细介绍"></a>排序方法详细介绍</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><strong>直接插入排序</strong>(Straight Insertion Sort)是一种最简单的排序方法，它的基本操作是一个值插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/insert.png" alt="insert"><br>由上图可知若最初始的有序表即为数组的第一个元素。用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">straight_insertion_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    直接插入排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> self.__straight_insert(value_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__straight_insert</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    sorted_list = []</span><br><span class="line">    sorted_list.append(value_list.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(value_list)):</span><br><span class="line">        tail = <span class="literal">True</span>  <span class="comment"># 是否在尾部插入</span></span><br><span class="line">        insert_loc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(sorted_list)):</span><br><span class="line">            <span class="keyword">if</span> value_list[i] &lt;= sorted_list[j]:</span><br><span class="line">                tail = <span class="literal">False</span></span><br><span class="line">                insert_loc = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        sorted_list.append(value_list[i])  <span class="comment"># 先将值插入尾部</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">            <span class="comment"># 移动值</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(sorted_list) - <span class="number">1</span>, insert_loc, <span class="number">-1</span>):</span><br><span class="line">                tmp = sorted_list[j]</span><br><span class="line">                sorted_list[j] = sorted_list[j - <span class="number">1</span>]</span><br><span class="line">                sorted_list[j - <span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><strong>希尔排序</strong>(Shell’s Sort)又称“缩小增量排序”(Diminishing Incerement Sort)，它也是一种数插入排序的方法，但在时间效率上较前面的排序方法有较大的改进。它的基本思想是：先将整个待排记录序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/shell.png" alt="shell"><br>即根据增量将原序列分割成多个子序列进行直接插入排序。<strong>增量应不断减小，且最后一个增量为1</strong>。用python实现如下(其中用到的子函数见前文)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shells_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    gap = len(value_list) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt;= <span class="number">1</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i + gap) &lt; len(value_list):</span><br><span class="line">            start = i</span><br><span class="line">            gap_list = []</span><br><span class="line">            <span class="keyword">while</span> start &lt; len(value_list):</span><br><span class="line">                gap_list.append(value_list[start])</span><br><span class="line">                start = start + gap</span><br><span class="line">            gap_list = self.__straight_insert(gap_list)</span><br><span class="line">            start = i</span><br><span class="line">            <span class="keyword">while</span> start &lt; len(value_list):</span><br><span class="line">                value_list[start] = gap_list.pop(<span class="number">0</span>)</span><br><span class="line">                start = start + gap</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的过程很简单。首先将第一个记录的关键字和第二个记录的关键字进行比较，若逆序(与需要的顺序相反)，则将两个记录交换之，然后比较第二个记录和第三个记录的关键字，以此类推。为第一趟冒泡结束，接着对前$n-1$个记录继续进行上述的过程。这样重复的过程直至$n-1=1$结束。排序过程如下所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/buble.png" alt="buble"><br>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubule_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value_list) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(value_list)):</span><br><span class="line">            <span class="keyword">if</span> value_list[i] &gt; value_list[j]:</span><br><span class="line">                tmp = value_list[j]</span><br><span class="line">                value_list[j] = value_list[i]</span><br><span class="line">                value_list[i] = tmp</span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>快速排序</strong>(Quick Sort)是对冒泡排序的的一种改进。它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，已达到整个序列有序。其排序思想如下：</p>
<blockquote>
<p>首先任意选取一个记录（通常可选第一个记录）作为<strong>枢轴</strong>，然后按下述原则重新排列记录：将所有关键字较它小的记录都安置在它的位置之前，将所有关键字较它大的记录都安置在它的位置之后。一趟快速排序的具体做法是：设两个指针low和high，他们的初值分别为最低位置的下一个位置和最高位，设最低位置位枢轴的关键字为pivotkey，则首先从high所指位置起像前搜索找到第一个关键字小于pivotkey的记录和枢轴记录互相交换。<strong>发生了交换后</strong>才从low所指向的位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录互相交换。重复这两步直至low=how为止</p>
</blockquote>
<p>如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/quick.png" alt="quick"><br>特别要注意换方向的时机是<strong>发生了交换后</strong>，用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(value_list) - <span class="number">1</span></span><br><span class="line">    self.__qsort(value_list, low, high)</span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__qsort</span><span class="params">(self, val_list, low, high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序辅助函数</span></span><br><span class="line"><span class="string">    :param val_list: 无序列表</span></span><br><span class="line"><span class="string">    :param low: 低位</span></span><br><span class="line"><span class="string">    :param high: 高位</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pivot_key = low</span><br><span class="line">    tmp_low = pivot_key</span><br><span class="line">    tmp_high = high</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:  <span class="comment"># 分成一边比轴（pivot）大，一边比轴（pivot）小的顺序</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">if</span> val_list[high] &lt; val_list[pivot_key]:</span><br><span class="line">                tmp = val_list[high]</span><br><span class="line">                val_list[high] = val_list[pivot_key]</span><br><span class="line">                val_list[pivot_key] = tmp</span><br><span class="line">                pivot_key = high</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 发生交换后，就换方向</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">if</span> val_list[low] &gt; val_list[pivot_key]:</span><br><span class="line">                tmp = val_list[low]</span><br><span class="line">                val_list[low] = val_list[pivot_key]</span><br><span class="line">                val_list[pivot_key] = tmp</span><br><span class="line">                pivot_key = low</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 发生交换后，就换方向</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">    self.__qsort(val_list, tmp_low, pivot_key - <span class="number">1</span>)</span><br><span class="line">    self.__qsort(val_list, pivot_key + <span class="number">1</span>, tmp_high)</span><br></pre></td></tr></table></figure>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>选择排序的基本思想是：每一趟在$n-i+1(i=1,2,…,n-1)$个记录中选取关键字最小的记录作为有序序列中第$i$个记录。简单选择排序：通过$n-1$次关键字的比较，从$n-i+1$个记录中选出关键字最小的记录，并和第$i(1\leq i\leq n)$个记录交换之。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/selection.png" alt="simple"><br>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_selection_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    简单选择排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value_list)):</span><br><span class="line">        min_val = <span class="number">9999999</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(value_list)):</span><br><span class="line">            <span class="keyword">if</span> min_val &gt; value_list[j]:</span><br><span class="line">                min_val = value_list[j]</span><br><span class="line">        count = <span class="number">0</span>  <span class="comment"># 如果有多个相同的最小值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(value_list)):</span><br><span class="line">            <span class="keyword">if</span> min_val == value_list[j]:</span><br><span class="line">                tmp = value_list[j]</span><br><span class="line">                value_list[j] = value_list[i + count]</span><br><span class="line">                value_list[i + count] = tmp</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>堆</strong>的定义如下：$n$个元素的序列$\left \{k_{1},k_{2}, …k_{n} \right \}$当且仅当满足一下关系时，称之为堆。</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
k_{i}\leq k_{2i}\\
k_{i}\leq k_{2i+1}
\end{matrix}\right.或\left\{\begin{matrix}
k_{i}\geq k_{2i}\\
k_{i}\geq k_{2i+1}
\end{matrix}\right.</script><p><strong>若将序列看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端节点均不大于（或不小于）其左、右孩子节点的值。由此，若序列是堆，则堆顶元素必为序列中的最小值（或最大值）</strong>。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/heap.png" alt="heap"><br>至此，我们可以给出<strong>堆排序</strong>的过程：<strong>若在输出堆顶的最小值后，使得剩余$n-1$个元素的序列又建成一个堆，则得到$n$个元素中的次小值。如此反复执行，便能得到一个有序序列。</strong><br>故整个堆排序可以大致分为两个过程：</p>
<ul>
<li>将无序序列建成堆。</li>
<li>输出堆顶元素后，用类似建堆的方法调整堆。</li>
</ul>
<p>如下两个图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/construct_heap.png" alt="1"><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/heap_sort.png" alt="2"><br>根据堆排序的特点总结出两点注意事项：</p>
<ol>
<li>利用把堆看成完全二叉树的特点，用<strong>完全二叉树的性质</strong>解决算法问题</li>
<li>建堆的过程是从树种的<strong>最后一个非终端节点</strong>逆序开始调整的。</li>
<li>每调整一次需要检查前后是否依然保持<strong>堆的特征</strong>。</li>
</ol>
<p>本文利用了二叉树的<strong>孩子兄弟表示法</strong>来生成二叉树(堆)的。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">__CldSibNode</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    私有内部类：孩子兄弟二叉链表节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.value = val</span><br><span class="line">        self.child = <span class="literal">None</span></span><br><span class="line">        self.sibling = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">堆排序</span></span><br><span class="line"><span class="string">:param value_list: 无序列表</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">sorted_list = []</span><br><span class="line">root_node = self.__CldSibNode(<span class="literal">None</span>)</span><br><span class="line">self.__child_sibling(root_node, value_list, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> ct <span class="keyword">in</span> range(<span class="number">1</span>, len(value_list) // <span class="number">2</span> + <span class="number">1</span>):  <span class="comment"># 建堆</span></span><br><span class="line">    self.__adjust_heap(root_node, len(value_list) // <span class="number">2</span> + <span class="number">1</span> - ct, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(value_list) + <span class="number">1</span>):  <span class="comment"># 堆排序</span></span><br><span class="line">    sorted_list.append(root_node.value)  <span class="comment"># 输出堆顶元素</span></span><br><span class="line">    head = root_node</span><br><span class="line">    self.__shrink_heap(root_node, len(value_list) + <span class="number">1</span> - i, <span class="number">1</span>, head)  <span class="comment"># 收缩堆</span></span><br><span class="line">    self.__adjust_heap(root_node, <span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 调整堆</span></span><br><span class="line"><span class="keyword">return</span> sorted_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__child_sibling</span><span class="params">(self, node, value_list, ind)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建完全二叉树的左孩子右兄弟二叉链表</span></span><br><span class="line"><span class="string">    :param node: 当前节点</span></span><br><span class="line"><span class="string">    :param value_list:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> ind &gt;= len(value_list):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    node.value = value_list[ind]</span><br><span class="line">    <span class="keyword">if</span> (ind * <span class="number">2</span> + <span class="number">1</span>) &lt; len(value_list):</span><br><span class="line">        node.child = self.__CldSibNode(<span class="literal">None</span>)  <span class="comment"># 孩子</span></span><br><span class="line">        self.__child_sibling(node.child, value_list, ind * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (ind * <span class="number">2</span> + <span class="number">2</span>) &lt; len(value_list):</span><br><span class="line">        node.child.sibling = self.__CldSibNode(<span class="literal">None</span>)  <span class="comment"># 兄弟</span></span><br><span class="line">        self.__child_sibling(node.child.sibling, value_list, ind * <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__adjust_heap</span><span class="params">(self, root_node, last_ind, now_ind)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        内部函数：交换两个变量值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> y, x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> root_node) <span class="keyword">or</span> (<span class="keyword">not</span> root_node.child):  <span class="comment"># 不为空且有孩子</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> now_ind == last_ind:  <span class="comment"># 需要调整的非终端节点</span></span><br><span class="line">        tmp = root_node</span><br><span class="line">        cg = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> tmp.child:</span><br><span class="line">            <span class="keyword">if</span> tmp.value &gt; tmp.child.value:  <span class="comment"># 如果大于左子树根节点</span></span><br><span class="line">                tmp.value, tmp.child.value = change(tmp.value, tmp.child.value)</span><br><span class="line">                cg = <span class="literal">True</span>  <span class="comment"># 发生交换</span></span><br><span class="line">            <span class="keyword">if</span> tmp.child.sibling:</span><br><span class="line">                <span class="keyword">if</span> tmp.value &gt; tmp.child.sibling.value:</span><br><span class="line">                    <span class="keyword">if</span> cg:  <span class="comment"># 如果发生过交换</span></span><br><span class="line">                        tmp.value, tmp.child.value = change(tmp.value, tmp.child.value)</span><br><span class="line">                    tmp.value, tmp.child.sibling.value = change(tmp.value, tmp.child.sibling.value)</span><br><span class="line">                    tmp = tmp.child.sibling</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> cg:  <span class="comment"># 如果发生过交换</span></span><br><span class="line">                        tmp = tmp.child</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    self.__adjust_heap(root_node.child, last_ind, now_ind * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> root_node.child.sibling:</span><br><span class="line">        self.__adjust_heap(root_node.child.sibling, last_ind, now_ind * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__shrink_heap</span><span class="params">(self, root_node, last_ind, now_ind, head)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> root_node) <span class="keyword">or</span> (now_ind * <span class="number">2</span> &gt; last_ind):  <span class="comment"># 不为空</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> last_ind == (now_ind * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        head.value = root_node.child.sibling.value</span><br><span class="line">        root_node.child.sibling = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> last_ind == (now_ind * <span class="number">2</span>):</span><br><span class="line">        head.value = root_node.child.value</span><br><span class="line">        root_node.child = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> root_node.child:</span><br><span class="line">        self.__shrink_heap(root_node.child, last_ind, now_ind * <span class="number">2</span>, head)</span><br><span class="line">        self.__shrink_heap(root_node.child.sibling, last_ind, now_ind * <span class="number">2</span> + <span class="number">1</span>, head)</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序(Merging)，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假设初始序列有$n$个记录，则可看成是$n$个有序的子序列，每个子序列的长度为1，然后两两归并，得到$\left \lceil \frac{n}{2} \right \rceil$个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为$n$的有序序列为止，这种排序方法称为<strong>2-路归并排序</strong>。算法的基本思想如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/merge.png" alt="merge"><br>其中两个子序列的合并大有学问，基本思想就是：<strong>分别在两个序列头设置指针，比较两个序列指针所指的值的大小，将满足要求的值提取出来形成新列表，并将指针右移。当其中一个指针指向结尾之后时，表示其中一个列表已取尽，接着直接在新列表尾部连接另一个列表</strong>。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/merge1.png" alt="mege_1"><br>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merging_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    归并排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> np.power(<span class="number">2</span>, i) &lt; len(value_list):</span><br><span class="line">        count = np.power(<span class="number">2</span>, i)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        outer_tmp = []</span><br><span class="line">        <span class="keyword">while</span> start &lt; len(value_list):</span><br><span class="line">            other = start + count  <span class="comment"># 定位另一边</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">if</span> other &gt;= len(value_list):  <span class="comment"># 另一边不存在</span></span><br><span class="line">                outer_tmp.extend(value_list[start:start + count])  <span class="comment"># 直接合并</span></span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 结束</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; count) <span class="keyword">or</span> (right &lt; count):</span><br><span class="line">                <span class="keyword">if</span> other + right &gt;= len(value_list):  <span class="comment"># 右边提前结束</span></span><br><span class="line">                    tmp.extend(value_list[start + left:start + count])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> value_list[start + left] &lt; value_list[other + right]:  <span class="comment"># 左边更小</span></span><br><span class="line">                    tmp.append(value_list[start + left])</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> left == count:  <span class="comment"># 左边遍历结束</span></span><br><span class="line">                        tmp.extend(value_list[other + right:other + count])  <span class="comment"># 合并右边</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 右边更小</span></span><br><span class="line">                    tmp.append(value_list[other + right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> right == count:  <span class="comment"># 右边遍历结束</span></span><br><span class="line">                        tmp.extend(value_list[start + left:start + count])  <span class="comment"># 合并左边</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            outer_tmp.extend(tmp)</span><br><span class="line">            start += count * <span class="number">2</span></span><br><span class="line">        value_list = outer_tmp</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序</strong>(Radix Sort)是利用了多关键字排序的思想，分为从低位关键字开始排序的<strong>最低位优先法</strong>(Least Significant Digit first)和从高位关键字开始排序的<strong>高位优先法</strong>(Most Signficant Digit first)。基数排序是借助“分配”和“收集”两种操作对单逻辑关键字进行排序的一种内部排序方法。</p>
<blockquote>
<p>如对三位数(0~999，即有三个关键字)进行最低位优先法排序：<strong>首先以静态链表存储$n$个待排记录，并另表头指针指向第一个记录；第一趟分配对低位关键字个位数进行，初始化10个空队列，每个队列中记录关键字的个位数相等。第一趟收集是改变所有费控队列的队尾指针域，令其指向下一个非空队列的队头，重新将10个队列链接成一个链表。第二次、第三次分别对十位和百位进行同样的操作</strong>，直至排序结束。</p>
</blockquote>
<p>如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/radix.png" alt="radix"><br>排序时有两点需要注意：</p>
<ol>
<li>每完成一趟排序，要清空队列。</li>
<li>队列的连接要找到第一个不为空的队列作为头，和绕开所有空队列。</li>
</ol>
<p>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    基数排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_n</span><span class="params">(num, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        内部函数：得到数的第n位</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        remainder = num % np.power(<span class="number">10</span>, n)</span><br><span class="line">        quotient = remainder // np.power(<span class="number">10</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> quotient</span><br><span class="line"></span><br><span class="line">    max_val = <span class="number">-99999</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> value_list:</span><br><span class="line">        <span class="keyword">if</span> val &gt; max_val:</span><br><span class="line">            max_val = val</span><br><span class="line">    iter_nums = <span class="number">0</span>  <span class="comment"># 最大位数</span></span><br><span class="line">    <span class="keyword">while</span> max_val &gt; <span class="number">0</span>:</span><br><span class="line">        iter_nums += <span class="number">1</span></span><br><span class="line">        max_val = max_val // <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> bit <span class="keyword">in</span> range(<span class="number">1</span>, iter_nums + <span class="number">1</span>):  <span class="comment"># 开始排序</span></span><br><span class="line">        tmp_list = []</span><br><span class="line">        qs = []  <span class="comment"># 创建新的链式队列数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            qs.append(que.LinkedQueue())</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> value_list:</span><br><span class="line">            qs[get_n(val, bit)].enqueue(val)  <span class="comment"># 按位数入队</span></span><br><span class="line">        qhead = <span class="literal">None</span></span><br><span class="line">        tmp_q = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> qs[j].front <span class="keyword">and</span> (qhead <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">                qhead = qs[j]  <span class="comment"># 寻找重组队列头</span></span><br><span class="line">                tmp_q = qhead</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> qs[j].front:</span><br><span class="line">                tmp_q.rear.pnext = qs[j].front  <span class="comment"># 将队列按顺序连接</span></span><br><span class="line">                tmp_q = qs[j]</span><br><span class="line">        tmp = qhead.front  <span class="comment"># 链接队列头</span></span><br><span class="line">        <span class="keyword">while</span> tmp:  <span class="comment"># 更新数组列表</span></span><br><span class="line">            tmp_list.append(tmp.value)</span><br><span class="line">            tmp = tmp.pnext</span><br><span class="line">        value_list = tmp_list</span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>编写测试代码和运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 排序之道</span></span><br><span class="line">    li = list(np.random.randint(<span class="number">1</span>, <span class="number">1000</span>, <span class="number">30</span>))</span><br><span class="line">    my_sort = MySort()</span><br><span class="line">    print(<span class="string">'original sequence: '</span>, li)</span><br><span class="line">    print(<span class="string">'-'</span> * <span class="number">170</span>)</span><br><span class="line">    print(<span class="string">'1.'</span>, my_sort.straight_insertion_sort.__name__, <span class="string">':'</span>, my_sort.straight_insertion_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'2.'</span>, my_sort.shells_sort.__name__, <span class="string">':            '</span>, my_sort.shells_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'3.'</span>, my_sort.bubule_sort.__name__, <span class="string">':            '</span>, my_sort.bubule_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'4.'</span>, my_sort.quick_sort.__name__, <span class="string">':             '</span>, my_sort.quick_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'5.'</span>, my_sort.simple_selection_sort.__name__, <span class="string">':  '</span>, my_sort.simple_selection_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'6.'</span>, my_sort.heap_sort.__name__, <span class="string">':              '</span>, my_sort.heap_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'7.'</span>, my_sort.merging_sort.__name__, <span class="string">':           '</span>, my_sort.merging_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'8.'</span>, my_sort.radix_sort.__name__, <span class="string">':             '</span>, my_sort.radix_sort(li.copy()))</span><br></pre></td></tr></table></figure>
<p>测试运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">original sequence:  [758, 74, 857, 781, 831, 719, 489, 785, 405, 621, 165, 568, 915, 939, 886, 4, 966, 461, 385, 757, 263, 505, 793, 259, 107, 437, 296, 702, 240, 644]</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">1. straight_insertion_sort : [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">2. shells_sort :             [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">3. bubule_sort :             [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">4. quick_sort :              [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">5. simple_selection_sort :   [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">6. heap_sort :               [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">7. merging_sort :            [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">8. radix_sort :              [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各个排序效率见下图：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/time_zone.png" alt="time"><br>可以得出以下几个结论：</p>
<ol>
<li>从平均时间性能而言，<strong>快速排序</strong>最佳。</li>
<li><strong>堆排序</strong>适用于$n$较大的数据。</li>
<li><strong>基数排序</strong>是稳定的，时间复杂度较大的<strong>简单排序</strong>方法也是稳定的。</li>
<li>稳定性是由方法本身决定的。</li>
<li>没有最好的排序方法，视情况而定。</li>
</ol>
<h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><ol>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L16" target="_blank" rel="noopener">直接插入排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L44" target="_blank" rel="noopener">希尔排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L69" target="_blank" rel="noopener">冒泡排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L84" target="_blank" rel="noopener">快速排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L131" target="_blank" rel="noopener">简单选择排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L152" target="_blank" rel="noopener">堆排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L237" target="_blank" rel="noopener">归并排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L278" target="_blank" rel="noopener">基数排序</a></li>
</ol>
<p>仅供参考。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树(BST)</title>
    <url>/2019/11/18/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>二叉排序树又称为二叉查找树(Binary Sort Tree or Binary Search Tree, 简称BST)</strong>，或者是一颗空树，或者是具有下列性质的二叉树：</p><a id="more"></a>
<ol>
<li>若它的左子树不为空，则左子树上所有的节点的值均小于它的根节点的值。</li>
<li>若它的右子树不为空，则右子树上所有的节点的值均大于它的根节点的值。</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ol>
<p>如下例所示的二叉排序树：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/1.png" alt="二叉排序树"><br>根据上述定义的二叉排序树结构特点可见它的查找过程：当二叉排序树不为空时，首先将给定值和根节点的关键字比较，若相等，则查找成功，否则将依据给定值和根节点的关键字之间的大小关系，分别在左子树或右子树上继续进行查找。最后可见，<strong>二叉排序树的中序遍历结果即为从小到大的排序结果。</strong></p>
<h2 id="二叉排序树实现-python"><a href="#二叉排序树实现-python" class="headerlink" title="二叉排序树实现(python)"></a>二叉排序树实现(python)</h2><p>对给定的序列<code>list=[51, 12, 34, 5, 54, 89, 25, 11, 45, 67, 31, 22, 99, 79]</code>按顺序生成二叉排序树</p>
<h3 id="二叉树的节点"><a href="#二叉树的节点" class="headerlink" title="二叉树的节点"></a>二叉树的节点</h3><p>二叉树的节点分为三个部分：左子树指针域，数据域，右子树指针域。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/1_1.png" alt="node"><br>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the node of tree</span></span><br><span class="line"><span class="string">        :param v: the value of node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.value = v</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>生成一个二叉排序树的算法如下：</p>
<blockquote>
<p>初始化：生成一个空树$Tree$，即根节点为空：$Tree.root=None$<br>输入：一个数据$v$<br>步骤：  </p>
<ol>
<li>判断根节点$Tree.root$是否为空。若是，则生成根节点$Tree.root=Node(v)$，否则执行步骤2。</li>
<li>另当前节点为$NowNode=Tree.root$。</li>
<li>判断$v$与当前节点值$NowNode.value$的大小，如果$v&gt;NowNode.value$，执行步骤4，否则执行步骤5.</li>
<li>判断当前节点的右子树$NowNode.right$是否为空，如果$NowNode.right=None$，则生成新节点$NewNode(v)$，执行步骤6，否则另$NowNode=NowNode.right$，执行步骤3。</li>
<li>判断当前节点的左子树$NowNode.left$是否为空，如果$NowNode.left=None$，则生成新节点$NewNode(v)$，执行步骤6，否则另$NowNode=NowNode.left$，执行步骤3。</li>
<li>结束</li>
</ol>
</blockquote>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, seq=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param seq: the optional parameter, to initialize the tree</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.insert(seq)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val_list)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        insert value into the tree</span></span><br><span class="line"><span class="string">        :param val_list: integer or list, the value waiting for inserting</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(val_list, list):</span><br><span class="line">            <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.root = Node(val_list.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> val_list:</span><br><span class="line">                self.__ins(v)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(val_list, int):</span><br><span class="line">            self.__ins(val_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ins</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        insert a value into the tree</span></span><br><span class="line"><span class="string">        :param v: interger</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_node = Node(v)</span><br><span class="line">        tmp = self.root</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> v &gt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.right:</span><br><span class="line">                    tmp = tmp.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.right = new_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> v &lt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.left:</span><br><span class="line">                    tmp = tmp.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.left = new_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        find the specific value</span></span><br><span class="line"><span class="string">        :param val:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.root</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> val == tmp.value:</span><br><span class="line">                print(<span class="string">"查找成功^_^"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> val &gt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.right:</span><br><span class="line">                    tmp = tmp.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"查找失败x_x"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> val &lt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.left:</span><br><span class="line">                    tmp = tmp.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"查找失败x_x"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        preorder traversal</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">            self.pre_order(node.left)</span><br><span class="line">            self.pre_order(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        inorder traversal</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.in_order(node.left)</span><br><span class="line">            print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">            self.in_order(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        postorder traversal</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.post_order(node.left)</span><br><span class="line">            self.post_order(node.right)</span><br><span class="line">            print(node.value, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<p>其中还包括了二叉排序树的<strong>遍历算法</strong>。<strong>其中中序遍历的结果即为排序结果</strong>。</p>
<h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h3><p>使用前面的列表<code>list</code>生成二叉排序树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    li = [<span class="number">51</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">54</span>, <span class="number">89</span>, <span class="number">25</span>, <span class="number">11</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">79</span>]</span><br><span class="line">    my_tree = BST(li)</span><br><span class="line">    my_tree.in_order(my_tree.root)</span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    my_tree.insert([<span class="number">23</span>, <span class="number">1</span>])</span><br><span class="line">    my_tree.in_order(my_tree.root)</span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    my_tree.search(<span class="number">23</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5 11 12 22 25 31 34 45 51 54 67 79 89 99 </span><br><span class="line">1 5 11 12 22 23 25 31 34 45 51 54 67 79 89 99 </span><br><span class="line">查找成功^_^</span><br></pre></td></tr></table></figure>
<p>生成的二叉排序树图示如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/2.png" alt="result"></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>KNN算法-python实现</title>
    <url>/2019/11/18/knn%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="k-近邻算法"><a href="#k-近邻算法" class="headerlink" title="$k$近邻算法"></a>$k$近邻算法</h2><p>$k$近邻(k-Nearest Neighbor, KNN)分类算法，是机器学习中最简单的算法之一。该算法的基本思路是：在一个未知的样本附近选取k个距离最短的已知样本（有类别标签），将这k个已知样本中数量最多的类别（标签）作为未知样本的类别（标签）。直观一点，如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/knn%E7%AE%97%E6%B3%95/1.png" alt="knn示例"><br>可以看到上图选取了$k=5$个距离未知样本最近的已知样本，5个已知样本中有三个红色矩形和两个蓝色矩形，由算法的基本思路可知，未知样本应标记为<strong>红色</strong>。</p><a id="more"></a>
<h2 id="距离的度量"><a href="#距离的度量" class="headerlink" title="距离的度量"></a>距离的度量</h2><p>$x$和$y$分别为两个样本，$n$为特征总数。一般用到的是以下两种距离：</p>
<ul>
<li><strong>欧式距离</strong>：<script type="math/tex; mode=display">d\left ( x,y \right )=\sqrt{\sum_{k=1}^{n}\left ( x_{k}-y_{k} \right )^{2}}</script></li>
<li><strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">d\left ( x,y \right )=\sqrt{\sum_{k=1}^{n}\left | x_{k}-y_{k} \right |}</script></li>
</ul>
<p>无论用那种距离，目的都是为了刻画已知样本和未知样本的<strong>相似度</strong>，从而描述预知样本的特征。</p>
<h2 id="用python实现算法"><a href="#用python实现算法" class="headerlink" title="用python实现算法"></a>用python实现算法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><blockquote>
<p>初始化：已知类别标签的样本集$X_{n}$和最多近邻数$k$，<br>输入：未知样本$x$<br>步骤：</p>
<ol>
<li>对于每个样本集中的样本$X_{i}$和未知样本$x$计算距离$d_{i}$。得到距离集$D_{n}$。</li>
<li>将距离集$D_{n}$中的数从小到大排序，选择前$k$个距离数据。</li>
<li>根据步骤2的$k$距离数据中的样本下标，得到对应的类别标签集$C_{k}$</li>
<li>选择$C_{k}$中数量最多的类别标签$c_{max}$作为未知样本$x$的类别标签$c$</li>
</ol>
</blockquote>
<h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><p>python实现knn算法的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the k of KNN</span></span><br><span class="line"><span class="string">        :param k: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.samples_nums = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, x_train, y_train, test)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        predict the categorie of test sample</span></span><br><span class="line"><span class="string">        :param x_train: the set of train sample</span></span><br><span class="line"><span class="string">        :param y_train: the label set of train sample</span></span><br><span class="line"><span class="string">        :param test: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x_train = np.array(x_train)</span><br><span class="line">        self.samples_nums = x_train.shape[<span class="number">0</span>]</span><br><span class="line">        y_train = np.array(y_train)</span><br><span class="line">        sorted_k_v = self.__cal_dist(x_train, test)</span><br><span class="line">        lab_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind <span class="keyword">in</span> range(self.k):</span><br><span class="line">            s = sorted_k_v[ind]</span><br><span class="line">            <span class="keyword">if</span> y_train[s[<span class="number">0</span>]] <span class="keyword">not</span> <span class="keyword">in</span> lab_dict.keys():</span><br><span class="line">                lab_dict[y_train[s[<span class="number">0</span>]]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lab_dict[y_train[s[<span class="number">0</span>]]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(lab_dict, key=lab_dict.get)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cal_dist</span><span class="params">(self, x_train, x_test)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        calculate the distance between train set and test sample</span></span><br><span class="line"><span class="string">        :param x_train: </span></span><br><span class="line"><span class="string">        :param x_test: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind <span class="keyword">in</span> range(self.samples_nums):</span><br><span class="line">            d[ind] = np.sqrt(sum(np.power(x_train[ind, :] - x_test, <span class="number">2</span>)))</span><br><span class="line">        sort_list = sorted(d.items(), key=<span class="keyword">lambda</span> itm: itm[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> sort_list</span><br></pre></td></tr></table></figure>
<p>测试案例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    my_knn = KNN(<span class="number">3</span>)</span><br><span class="line">    x = [[<span class="number">0.1</span>, <span class="number">0.2</span>], [<span class="number">-1.5</span>, <span class="number">-1.1</span>], [<span class="number">0.7</span>, <span class="number">1.9</span>], [<span class="number">-0.3</span>, <span class="number">1.0</span>]]</span><br><span class="line">    y = [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>]</span><br><span class="line">    print(my_knn.predict(x, y, [<span class="number">1</span>, <span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>输出：<code>b</code></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--哈希表</title>
    <url>/2019/11/14/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>在介绍哈希表之前，先介绍一下<strong>查找表</strong></p><h2 id="查找表-Search-Table"><a href="#查找表-Search-Table" class="headerlink" title="查找表(Search Table)"></a>查找表(Search Table)</h2><blockquote>
<p>查找表是由同一类型的数据元素(或记录)构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵活的数据结构</p>
</blockquote><a id="more"></a>

<h3 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h3><ol>
<li>查询某个“特定的”的数据元素是否在查找表中。</li>
<li>检索某个“特定的”数据元素的各种属性。</li>
<li>在查找表中插入一个数据元素</li>
<li>从查找表中删去某个元素。</li>
</ol>
<p>查找表根据其操作的不同又分为以下两种：</p>
<ul>
<li>若对查找表只作前两种统称为“查找”的操作，则称此类查找表为<strong>静态查找表(Static Search Table)</strong>。</li>
<li>若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素，则称此类表为<strong>动态查找表(Dynamic Search Table)</strong></li>
</ul>
<h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><p>为了解释“特定的”，引入了<strong>关键字</strong>:</p>
<blockquote>
<p>关键字是数据元素(或记录)中某个数据项的值，用它可以标识一个数据元素(或记录)。</p>
</blockquote>
<p>接着定义<strong>查找</strong>:</p>
<blockquote>
<p>根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。</p>
</blockquote>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>查找的效率依赖于查找过程中所进行的比较次数。</p>
<h3 id="哈希-Hash-函数"><a href="#哈希-Hash-函数" class="headerlink" title="哈希(Hash)函数"></a>哈希(Hash)函数</h3><blockquote>
<p>理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个对应关系$f$，使每个关键字和结构中一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系$f$找到给定值$K$的像$f\left ( K \right )$。<strong>若结构中存在关键字和$K$相等的记录，则必定在$f\left ( K \right )$的存储位置上</strong>，由此，不需要进行比较便可直接取得所查记录。在此，我们称这个对应关系$f$为<strong>哈希函数</strong>，按这个思想建立的表为<strong>哈希表</strong>。</p>
</blockquote>
<h3 id="哈希函数的特征"><a href="#哈希函数的特征" class="headerlink" title="哈希函数的特征"></a>哈希函数的特征</h3><ol>
<li>哈希函数是一个映像，因此哈希函数的设定很灵活，只要是的任何关键字由此所得的哈希函数值都落在表长允许的范围内即可。</li>
<li>对不同的关键字可能得到同一哈希地址，即$key_{1}\neq key_{2}$，而$f\left ( key_{1} \right )= f\left ( key_{2} \right )$，这种现象称为<strong>冲突(collision)</strong>。</li>
</ol>
<h3 id="哈希表定义"><a href="#哈希表定义" class="headerlink" title="哈希表定义"></a>哈希表定义</h3><p>综上，可如下描述哈希表：</p>
<blockquote>
<p>根据设定的哈希函数$H\left ( key \right )$和处理冲突的方法将一组关键字映像到一个有限的连续的地址集上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为<strong>哈希表</strong>，这一映像过程称为哈希造表或<strong>散列</strong>，所得存储位置称<strong>哈希地址</strong>或<strong>散列地址</strong>。</p>
</blockquote>
<h2 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h2><p>若对于关键字集合中的任一个关键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称此类哈希函数为<strong>均匀的(Uniform)</strong>哈希函数。换句话说，就是使关键字经过哈希函数得到一个“随机的地址”，以便使一组关键字的哈希地址<strong>均匀分布</strong>在整个地址区间中，从而减少<strong>冲突</strong></p>
<ul>
<li><strong>直接定址法</strong>：取关键字或关键字的某个线性函数值作为哈希地址。即：</li>
</ul>
<script type="math/tex; mode=display">H\left ( key \right )= key</script><script type="math/tex; mode=display">H\left ( key \right )= a\cdot key+b</script><ul>
<li><strong>数字分析法</strong>：假设关键字是以$r$为基的数(如：以10为基的十进制数)，并且哈希表中可能出现的关键字都是事先知道的，则可以取关键字的若干数位组成哈希地址。</li>
<li><strong>平方取中法</strong>：取关键字平方后的中间几位为哈希地址。</li>
<li><strong>折叠法</strong>：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为哈希地址。</li>
<li><strong>除留余数法</strong>：取关键字被某个不大于哈希表表长$m$的数$p$除后所得的余数为哈希地址。即:</li>
</ul>
<script type="math/tex; mode=display">H\left ( key \right )= key\left ( MOD \right )p, p\leq m</script><h2 id="处理冲突-collision"><a href="#处理冲突-collision" class="headerlink" title="处理冲突(collision)"></a>处理冲突(collision)</h2><p>上文提到的均匀的哈希函数可以减少冲突，但不能避免，因此如何处理冲突时哈希造表不可缺少的另一方面。通常用的处理方法如下：</p>
<ul>
<li><strong>开放地址法</strong><script type="math/tex; mode=display">H_{i}=\left ( H\left ( key \right )+d_{i} \right )MOD\left ( m \right ),i=1,2,...,k\left ( k\leq m-1 \right )</script>其中：$H\left ( key \right )$为哈希函数；$m$为哈希表表长；$d_{i}$为增量序列，有下列三种取法：<ol>
<li>$d_{i}=1,2,3,…,m-1$称线性探测再散列；</li>
<li>$d_{i}=1^{2},-1^{2},2^{2},-2^{2},3^{2},…,\pm k^{2},\left (k\leq m/2 \right)$称二次探测再散列；</li>
<li>$d_{i}=伪随机数序列$，称伪随机探测再散列。</li>
</ol>
</li>
<li><strong>再哈希法</strong><script type="math/tex; mode=display">H_{i}=RH_{i}\left (key \right), i=1,2,...,k</script>$RH_{i}$均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不在发生。这种方法不易产生“聚集”，但增加了计算的时间。</li>
<li><strong>链地址法</strong><br>将所有关键字为同义词的记录存储在同一线性链表中。假设某哈希函数产生的哈希地址在区间$\left [ 0,m-1 \right ]$上，则设立一个指针型向量<script type="math/tex; mode=display">ChainHash\left [m \right]</script>其每个分量的初始状态都是空指针。凡哈希地址为$i$的记录都插入到头指针为$ChainHash\left [i \right]$的链表中。在链表中的插入位置可以在表头或表尾；也可在中间，以保持同义词在同一线性链表中按关键字有序。</li>
<li><strong>建立公共溢出区</strong><br>假设哈希函数的值域为$\left [0,m-1 \right]$，则设向量$HashTable\left [0..m-1 \right]$为基本表，每个分量存放一个记录，另设立向量$OverTable\left [0..v \right]$为溢出表。所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</li>
</ul>
<h2 id="哈希表应用算法案例"><a href="#哈希表应用算法案例" class="headerlink" title="哈希表应用算法案例"></a>哈希表应用算法案例</h2><h3 id="两数之和-2-Sum"><a href="#两数之和-2-Sum" class="headerlink" title="两数之和(2 Sum)"></a>两数之和(2 Sum)</h3><p><strong>问题描述</strong>：</p>
<blockquote>
<p>输入一个数组<code>nums</code>和一个数<code>target</code>，返回数组<code>nums</code>中两个数的和为<code>target</code>的这两个数的下标(index),下标从1开始。例子：<br><code>nums = [2, 7, 11, 15]</code>, <code>target = [9]</code><br>返回<code>[1, 2]</code></p>
</blockquote>
<p><strong>问题分析</strong>：<br>有两个输入：<code>nums</code>和<code>target</code>，一个输出：<code>两个下标</code>，目的是找到两个数之和等于<code>target</code>。显而易见的一种方法是写两个for循环嵌套：外部循环从数组的第一个元素开始向后遍历作为第一个数<code>nums[i]</code>，内部循环从第一个数的下一个数<code>nums[i+1]</code>开始向后遍历，判断两个数之和是否等于<code>target</code>，找到后返回两个下标即可。不过这样做有明显的缺点：两个循环的算法时间复杂度为$O\left (n*(n-1)\right)$，那么如果<code>nums</code>中有9个元素，最多会遍历9x8=72次，对于更大的<code>nums</code>遍历次数将更多。所以我们来“算算”怎么简化算法。</p>
<p><strong>解决方案</strong>：<br>我们设找到的两个数中第一个为$x_{i}$，第二个数为$x_{j}$，进行运算：</p>
<script type="math/tex; mode=display">x_{i}+x_{j}=target\tag{1}</script><script type="math/tex; mode=display">x_{j}=target-x_{i}\tag{2}</script><p>进行上述的运算后可以发现等式(1)中的左边部分有两个未知数，而等式右边只有一个未知数，于是我们可以得到一个下标$i$到$j$的映射：$f\left (i\right)=j$，从而我们可以利用等式(2)来重新构造我们的for循环，即使用一次for循环。<br><strong>程序实现</strong>：<br>用python来实现这个算法，其中python中的字典可以作为很好的哈希映射。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_num</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    solve the problem 2 sum</span></span><br><span class="line"><span class="string">    :param nums: the set of some numbers</span></span><br><span class="line"><span class="string">    :param target: the sum of two numbers</span></span><br><span class="line"><span class="string">    :return: the index of two numbers</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    hash_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ind, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> (target - val) <span class="keyword">in</span> hash_map:</span><br><span class="line">            <span class="keyword">return</span> hash_map[target - val]+<span class="number">1</span>, ind+<span class="number">1</span></span><br><span class="line">        hash_map[val] = ind</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans = two_num([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], <span class="number">9</span>)</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>
<p>输出：<code>(1, 2)</code><br><strong>代码分析</strong>：<br>分析代码可知，首先创建一个空的字典，该字典用来实现哈希映射，接着我们对数组的每一个元素进行迭代，获取元素的下标和元素值，接着进行判断：如果另一个元素在字典中，则返回另一个元素在字典中的值和当前元素的下标。<br>否则，更新字典，把元素作为字典的键（这样就不必担心重复的元素），把元素的下标作为值，然后继续循环。回过头来可以发现我们最终返回的就是两个数的下标值。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>由上述案例可知哈希思想作为数据结构的应用带来的算法效能提升，在平时的算法编写中应考虑到时间和空间上的条件，利用数据结构的知识来不断优化算法。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统:存储管理算法(python实现)</title>
    <url>/2019/11/10/memory-alloc/</url>
    <content><![CDATA[<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>该分配方式为用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址<strong>相邻</strong>，体现在内存空间分配是物理地址的<strong>相邻</strong>。连续分配方式可分为四类：</p><a id="more"></a>
<ul>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li><strong>动态分区分配</strong></li>
<li>动态可重定向分配</li>
</ul>
<p>本文仅重点介绍<strong>动态分区分配算法</strong></p>
<h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>动态分区分配又称为可变分区分配，它是根据进程的实际需要，动态地为之分配内存空间。</p>
<h3 id="动态分区分配中的数据结构"><a href="#动态分区分配中的数据结构" class="headerlink" title="动态分区分配中的数据结构"></a>动态分区分配中的数据结构</h3><p>为了实现动态分区分配，系统中必须配置相应的数据结构，用以描述空闲分区和已分配分区的情况，为分配提供依据。常用的数据结构有以下两种形式：</p>
<ol>
<li>空闲分区表。在系统中设置一张空闲分区表，用于记录每个空闲的情况。每个空闲分区占一个表目(行)，表目中包括分区号、分区大小和分区始址等数据项，如下图所示<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_1.png" alt="空闲分区表"></li>
<li><strong>空闲分区链</strong>。为了实现对空闲分区的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接空闲分区的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。为了检索方便，在分区尾部重复设置状态位和分区大小表目。当分区被分配出去以后，把状态位由“0”改为“1”，此时，前、后向指针已无意义。如下图所示<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_2.png" alt="空闲分区链"></li>
</ol>
<p>本文主要针对空闲分区链编写python代码</p>
<h3 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h3><p>在动态分区存储管理方式中，主要的操作是分配内存和回收内存</p>
<ul>
<li>分配内存：系统利用某种<strong>分配算法</strong>，从空闲分区链中找到所需大小的分区。设请求的分区大小为apply.size，表中每个空闲分区的大小表示为part.size。若part.size - apply.size &lt;= min_size(min_size是事先规定的最小剩余)，说明多余的部分太小，可不分割，将整个分区分配个请求者。否则(即多余的部分超过min_size)，说明剩下了很多，便可从该分区中按请求的大小划分出一块内存空间出去，余下的部分仍留在空闲分区链(表)中。最后将分配区的 <strong>首址(address)</strong> 返回给调用者。流程如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_3.png" alt="分配内存"></li>
<li>回收内存：当进程运行完毕释放内存时，系统根据回收区的首址，从空闲链(表)中找到相应的插入点，此时可能出现以下四种情况之一：<ol>
<li>回收区与插入点前一个空闲分区$F_{1}$相邻接。此时应将回收区与$F_{1}$合并。<strong>不必创建新表项</strong>，只需修改其前一分区$F_{1}$的大小。</li>
<li>回收分区与插入点的后一空闲分区$F_{2}$相邻接。此时也将两分区合并。<strong>但回收区的首址作为新空闲区的首址</strong>。</li>
<li>回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，<strong>使用前一个分区的表项和首址，取消后一个分区的表项</strong>。</li>
<li>回收区既与前后两个分区都不邻接。<strong>此时为回收区单独建立一个新表项</strong>，首址和大小分别为回收区的首址和大小。<br>内存回收的流程如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_4.png" alt="回收内存"></li>
</ol>
</li>
</ul>
<h2 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h2><p>为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。所谓顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。基于顺序搜索的动态分区分配算法有如下四种（以下算法讲解皆是基于空闲分区链）：</p>
<ul>
<li><strong>首次适应(first fit, FF)算法</strong>：FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。</li>
<li>循环首次适应(next fit, NF)算法：NF算法不再是每次都从链首开始查找，而是从上一次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区。</li>
<li>最佳适应(best fit, BF)算法：BF算法要求每次为作业分配内存时，总是把能满足要求、又是最小的空间分区分配给作业。同时，为了加速寻找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。</li>
<li>最坏适应(worst fit, WF)算法：WF算法与BF算法相反：它在扫描整个空闲分区链时，总是挑选出一个最大的空闲区，以至于存储器中缺乏大的空闲分区</li>
</ul>
<h3 id="首次适应算法实现"><a href="#首次适应算法实现" class="headerlink" title="首次适应算法实现"></a>首次适应算法实现</h3><p>分析操作系统的内存管理流程后大致可把算法分为以下几个步骤：</p>
<ul>
<li>初始化空闲分区链</li>
<li>发出内存请求</li>
<li>使用算法(FF)分配内存</li>
<li>回收内存</li>
</ul>
<p>用python实现该算法代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionNode</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    a node of idle partition chain</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, loc)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize the node</span></span><br><span class="line"><span class="string">        :param size: the size of this partition</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.prior = <span class="literal">None</span>  <span class="comment"># the prior of this partition</span></span><br><span class="line">        self.part_size = size</span><br><span class="line">        self.loc = loc     <span class="comment"># the begin location of this partition</span></span><br><span class="line">        self.status = <span class="number">0</span>    <span class="comment"># the distribution status of this partition</span></span><br><span class="line">        self.next = <span class="literal">None</span>   <span class="comment"># the next of this partition</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionChain</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize a free partition chain</span></span><br><span class="line"><span class="string">        :param num:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.partition_chain = PartitionNode(np.random.randint(<span class="number">50</span>, <span class="number">151</span>), <span class="number">0</span>)  <span class="comment"># create the head node</span></span><br><span class="line">        self.num = num  <span class="comment"># the number of the partition</span></span><br><span class="line">        self.size = self.partition_chain.part_size</span><br><span class="line">        self.free = <span class="number">0</span>   <span class="comment"># the free space of the partition</span></span><br><span class="line">        self.__init_chain()  <span class="comment"># initialize the partition chain</span></span><br><span class="line">        self.min_remain = <span class="number">25</span>  <span class="comment"># the minimum size of split</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_chain</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize the partition charin</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> range(<span class="number">1</span>, self.num):</span><br><span class="line">            tmp.next = PartitionNode(np.random.randint(<span class="number">50</span>, <span class="number">151</span>), self.size)  <span class="comment"># create the next node</span></span><br><span class="line">            self.size += tmp.next.part_size</span><br><span class="line">            tmp.next.prior = tmp  <span class="comment"># point to the prior node</span></span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        self.free = self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_chain</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        print the infomation of partition chain</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        self.free = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            self.free += tmp.part_size</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        print(<span class="string">"空闲分区链(分区数-%d 大小-%d 空闲-%d):"</span> % (self.num, self.size, self.free), end=<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> tmp.next:</span><br><span class="line">                print(<span class="string">"&lt;AT-%d, S-%d&gt;"</span> % (tmp.loc, tmp.part_size), end=<span class="string">'···'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"&lt;AT-%d, S-%d&gt;"</span> % (tmp.loc, tmp.part_size))</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alloc_memory</span><span class="params">(self, method, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the algorithm of allocate memory</span></span><br><span class="line"><span class="string">        :param method: first fit, next fit, best fit, worst fit</span></span><br><span class="line"><span class="string">        :param m: the memory of application</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">'**需求**:'</span>, m)</span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">'first'</span>:</span><br><span class="line">            tmp = self.partition_chain</span><br><span class="line">            <span class="keyword">while</span> tmp:</span><br><span class="line">                <span class="keyword">if</span> m &lt;= tmp.part_size <span class="keyword">and</span> tmp.status == <span class="number">0</span>:  <span class="comment"># 按顺序找到第一个能满足要求的空闲分区</span></span><br><span class="line">                    <span class="keyword">if</span> tmp.part_size - m &lt;= self.min_remain:  <span class="comment"># 划分后剩余的大小过小，则分出整个分区，并调整分区链结构</span></span><br><span class="line">                        self.num -= <span class="number">1</span>  <span class="comment"># 长度减一</span></span><br><span class="line">                        <span class="keyword">if</span> tmp.prior <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 如果是表头</span></span><br><span class="line">                            self.partition_chain = tmp.next</span><br><span class="line">                            self.partition_chain.prior = <span class="literal">None</span></span><br><span class="line">                        <span class="keyword">elif</span> tmp.next <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果是表尾</span></span><br><span class="line">                            tmp.prior.next = <span class="literal">None</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            tmp.next.prior = tmp.prior</span><br><span class="line">                            tmp.prior.next = tmp.next</span><br><span class="line">                        print(<span class="string">"**Info**: 分配成功^_^, 地址-%d 大小-%d"</span> % (tmp.loc, tmp.part_size))</span><br><span class="line">                        <span class="keyword">return</span> &#123;<span class="string">'Address'</span>: tmp.loc, <span class="string">'Size'</span>: tmp.part_size&#125;</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tmp.part_size -= m</span><br><span class="line">                        print(<span class="string">"**Info**: 分配成功^_^, 地址-%d 大小-%d"</span> % (tmp.loc, m))</span><br><span class="line">                        <span class="keyword">return</span> &#123;<span class="string">'Address'</span>: tmp.loc, <span class="string">'Size'</span>: m&#125;  <span class="comment"># 返回分配区的首地址</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp = tmp.next</span><br><span class="line">            print(<span class="string">'**Info**: 分配失败x_x'</span>)</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">'next'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">'best'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">'fit'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dealloc_memory</span><span class="params">(self, m_dict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        recycle the memeory</span></span><br><span class="line"><span class="string">        :param m_dict: the dict of deallocated memory</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"**Info**: 回收失败x_x"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        loc = m_dict.get(<span class="string">'Address'</span>)</span><br><span class="line">        size = m_dict.get(<span class="string">'Size'</span>)</span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> tmp.prior <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 表头分区</span></span><br><span class="line">                <span class="keyword">if</span> loc &lt;= tmp.loc:</span><br><span class="line">                    <span class="keyword">if</span> loc == tmp.loc:  <span class="comment"># 同一分区</span></span><br><span class="line">                        tmp.part_size += size</span><br><span class="line">                    <span class="keyword">else</span>:  <span class="comment"># 与表头分区不邻接，自己作为表头分区</span></span><br><span class="line">                        new_part = PartitionNode(size, loc)</span><br><span class="line">                        new_part.next = tmp</span><br><span class="line">                        tmp.prior = new_part</span><br><span class="line">                        self.partition_chain = new_part</span><br><span class="line">                        self.num += <span class="number">1</span></span><br><span class="line">                    print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> (tmp.next <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">and</span> (loc &gt;= tmp.loc):  <span class="comment"># 表尾分区, 且在表尾之后</span></span><br><span class="line">                <span class="keyword">if</span> tmp.loc == loc:  <span class="comment"># 与表尾分区邻接，表尾分区在前</span></span><br><span class="line">                    tmp.part_size += size</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 与表尾分区不邻接，自己作为表尾分区</span></span><br><span class="line">                    new_part = PartitionNode(size, loc)</span><br><span class="line">                    tmp.next = new_part</span><br><span class="line">                    new_part.prior = tmp</span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 表中分区，前后皆有分区存在</span></span><br><span class="line">                <span class="keyword">if</span> loc &lt;= tmp.loc:</span><br><span class="line">                    <span class="keyword">if</span> ((loc + size) == tmp.loc) | (loc == tmp.loc):</span><br><span class="line">                        <span class="keyword">if</span> loc == tmp.loc:  <span class="comment"># 同一分区</span></span><br><span class="line">                            tmp.part_size += size</span><br><span class="line">                        <span class="keyword">elif</span> (tmp.prior.loc + tmp.prior.part_size) == loc:  <span class="comment"># 1.同时与前面和后面的分区邻接</span></span><br><span class="line">                            next_part = tmp.next</span><br><span class="line">                            <span class="keyword">if</span> next_part:  <span class="comment"># 如果是不是表尾分区</span></span><br><span class="line">                                next_part.prior = tmp.prior</span><br><span class="line">                            tmp.prior.part_size += size + tmp.part_size</span><br><span class="line">                            tmp.prior.next = next_part</span><br><span class="line">                        <span class="keyword">else</span>:  <span class="comment"># 2.只与后面的分区邻接</span></span><br><span class="line">                            tmp.part_size += size</span><br><span class="line">                        print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> loc == tmp.prior.loc:</span><br><span class="line">                            tmp.prior.part_size += size</span><br><span class="line">                        <span class="keyword">elif</span> (tmp.prior.loc + tmp.prior.part_size) == loc:  <span class="comment"># 3.只与前面的分区邻接</span></span><br><span class="line">                            tmp.prior.part_size += size</span><br><span class="line">                        <span class="keyword">else</span>:  <span class="comment"># 4.与前面和后面的都不邻接</span></span><br><span class="line">                            new_part = PartitionNode(size, loc)</span><br><span class="line">                            new_part.next = tmp</span><br><span class="line">                            new_part.prior = tmp.prior</span><br><span class="line">                            tmp.prior.next = new_part</span><br><span class="line">                            tmp.prior = new_part</span><br><span class="line">                            self.num += <span class="number">1</span></span><br><span class="line">                        print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    my_chain = PartitionChain(<span class="number">5</span>)</span><br><span class="line">    my_chain.print_chain()</span><br><span class="line">    my_apply = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 请求内存</span></span><br><span class="line">        rnd = np.random.randint(<span class="number">80</span>, <span class="number">130</span>)</span><br><span class="line">        my_apply.append(my_chain.alloc_memory(<span class="string">'first'</span>, rnd))</span><br><span class="line">    my_chain.print_chain()</span><br><span class="line">    print(<span class="string">'已经请求的分区:'</span>, my_apply)</span><br><span class="line">    <span class="keyword">for</span> applys <span class="keyword">in</span> my_apply:</span><br><span class="line">        my_chain.dealloc_memory(applys)</span><br><span class="line">    my_chain.print_chain()</span><br></pre></td></tr></table></figure>
<p>运行示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">空闲分区链(分区数-5 大小-484 空闲-484): &lt;AT-0, S-126&gt;···&lt;AT-126, S-132&gt;···&lt;AT-258, S-50&gt;···&lt;AT-308, S-68&gt;···&lt;AT-376, S-108&gt;</span><br><span class="line">**需求**: 118</span><br><span class="line">**Info**: 分配成功^_^, 地址-0 大小-126</span><br><span class="line">**需求**: 86</span><br><span class="line">**Info**: 分配成功^_^, 地址-126 大小-86</span><br><span class="line">**需求**: 82</span><br><span class="line">**Info**: 分配成功^_^, 地址-376 大小-82</span><br><span class="line">空闲分区链(分区数-4 大小-484 空闲-190): &lt;AT-126, S-46&gt;···&lt;AT-258, S-50&gt;···&lt;AT-308, S-68&gt;···&lt;AT-376, S-26&gt;</span><br><span class="line">已经请求的分区: [&#123;&apos;Address&apos;: 0, &apos;Size&apos;: 126&#125;, &#123;&apos;Address&apos;: 126, &apos;Size&apos;: 86&#125;, &#123;&apos;Address&apos;: 376, &apos;Size&apos;: 82&#125;]</span><br><span class="line">**Info**: 大小:126 回收成功^_^</span><br><span class="line">**Info**: 大小:86 回收成功^_^</span><br><span class="line">**Info**: 大小:82 回收成功^_^</span><br><span class="line">空闲分区链(分区数-5 大小-484 空闲-484): &lt;AT-0, S-126&gt;···&lt;AT-126, S-132&gt;···&lt;AT-258, S-50&gt;···&lt;AT-308, S-68&gt;···&lt;AT-376, S-108&gt;</span><br></pre></td></tr></table></figure>
<p>如有不当指出，请多多指教。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>银行家算法(java实现)</title>
    <url>/2019/11/08/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>银行家算法是一种避免进程发生<strong>死锁</strong>的算法。</p><blockquote>
<p>死锁的定义：<br>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么改组进程是死锁的(Deadlock)<br>在死锁避免方法中，把系统的状态分为<strong>安全状态</strong>和<strong>不安全状态</strong>。<br>安全状态和不安全状态：<br>是指系统能按某种进程推进顺序<script type="math/tex">\left ( P_{1},P_{2}, ...,P_{n}\right )</script> 为每个进程<script type="math/tex">P_{i}</script>分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。并称<script type="math/tex">\left ( P_{1},P_{2}, ...,P_{n}\right )</script>为安全序列。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p>
</blockquote><a id="more"></a>

<h2 id="银行家算法中的数据结构"><a href="#银行家算法中的数据结构" class="headerlink" title="银行家算法中的数据结构"></a>银行家算法中的数据结构</h2><p>银行家算法中有四个数据结构：</p>
<ul>
<li>最大需求向量(Max)：是一个长度为m的数组，它定义了系统中每个进程对第m类资源的最大需求</li>
<li>已分配向量(Allocation)：是一个长度为m的数组，它定义了系统中每个进程对每一类资源分配给进程的资源数量。</li>
<li>需求向量(Need)：是一个长度为m的数组，用以表示进程还需要的各类资源数量</li>
<li>可利用资源向量(Available)：是一个长度为m的数组，其中每一个值代表可以当前可利用的资源数目。</li>
</ul>
<p>上述数据中有这样的关系：Need = Max - Allocation</p>
<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>史上最详细的步骤^_^</p>
<ul>
<li>【步骤一】创建进程数组PCB[n] (代表n个进程)</li>
<li>【步骤二】输入并初始化每个进程PCB[i]的Max数组、Allocation数组</li>
<li>【步骤三】利用Max数组和Allocation数组计算出Need数组</li>
<li>【步骤四】输入Available数组</li>
<li>【步骤五】为每个PCB添加完成状态变量Finish(0-未完成，1-完成)，得到Finish数组(全部初始化为0)</li>
<li>【步骤六】初始化表示安全状态变量Safe_Status = 0(0-不安全，1-安全)</li>
<li>【步骤七】循环进行资源分配：</li>
<li>WHILE(SUM(Finish) &lt; n):</li>
<li>Safe_Status = 0</li>
<li>FOR i =  1 TO n</li>
<li>IF PCB[i]中Need的每个值 &lt;= Avaliable的每个值 AND PCB[i].Finish == 0</li>
<li>PCB[i].Finish = 1</li>
<li>将该进程PCB[i]加入安全序列队列</li>
<li>Available = Available + PCB[i].Need</li>
<li>Safe_Status = 1</li>
<li>END IF</li>
<li>END FOR</li>
<li>IF Safe_Status == 0</li>
<li>BREAK</li>
<li>END IF</li>
<li>END WHILE</li>
<li>【步骤八】判断系统是否安全：</li>
<li>IF (SUM(Finish == n))</li>
<li>该系统安全</li>
<li>END IF</li>
<li>【步骤九】输出安全序列队列</li>
</ul>
<h2 id="用Java实现银行家算法"><a href="#用Java实现银行家算法" class="headerlink" title="用Java实现银行家算法"></a>用Java实现银行家算法</h2><h3 id="Proc-java"><a href="#Proc-java" class="headerlink" title="Proc.java"></a>Proc.java</h3><p>表示进程信息的进程类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proc</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name;</span><br><span class="line">	<span class="keyword">int</span> max_res[];</span><br><span class="line">	<span class="keyword">int</span> alloc_res[];</span><br><span class="line">	<span class="keyword">int</span> need_res[];</span><br><span class="line">	<span class="keyword">boolean</span> finish_status = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Proc</span><span class="params">(<span class="keyword">char</span> name , <span class="keyword">int</span> max[], <span class="keyword">int</span> alloc[], <span class="keyword">int</span> need[])</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.max_res = max;</span><br><span class="line">		<span class="keyword">this</span>.alloc_res = alloc;</span><br><span class="line">		<span class="keyword">this</span>.need_res = need;</span><br><span class="line">		<span class="keyword">this</span>.finish_status = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMax_res</span><span class="params">(<span class="keyword">int</span> max_res[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.max_res = max_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] getMax_res() &#123;</span><br><span class="line">		<span class="keyword">return</span> max_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlloc_res</span><span class="params">(<span class="keyword">int</span> alloc_res[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.alloc_res = alloc_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] getAlloc_res() &#123;</span><br><span class="line">		<span class="keyword">return</span> alloc_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNeed_res</span><span class="params">(<span class="keyword">int</span> need_res[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.need_res = need_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] getNeed_res() &#123;</span><br><span class="line">		<span class="keyword">return</span> need_res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BankRR-java"><a href="#BankRR-java" class="headerlink" title="BankRR.java"></a>BankRR.java</h3><p>银行家算法和程序入口所在的类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankRR</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pcb_nums;  <span class="comment">// 进程数量</span></span><br><span class="line">	<span class="keyword">int</span> res_nums;  <span class="comment">// 资源种类数量</span></span><br><span class="line">	Proc pcbs[];   <span class="comment">// 进程数组</span></span><br><span class="line">	<span class="keyword">int</span> max[];     <span class="comment">// 最大需求资源向量</span></span><br><span class="line">	<span class="keyword">int</span> alloc[];   <span class="comment">// 拥有资源数向量</span></span><br><span class="line">	<span class="keyword">int</span> need[];    <span class="comment">// 还需要资源数向量</span></span><br><span class="line">	<span class="keyword">int</span> ava[];     <span class="comment">// 可用资源数向量</span></span><br><span class="line">	<span class="keyword">char</span> safe_seq[];  <span class="comment">// 安全序列数组</span></span><br><span class="line">	<span class="keyword">boolean</span> safe_stauts = <span class="keyword">false</span>;  <span class="comment">// 安全序列</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bank_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// A sample</span></span><br><span class="line">		<span class="comment">/*   Max   Alloc  Need   Avai</span></span><br><span class="line"><span class="comment">		 - a 7 5 3, 0 1 0, 7 4 3, 3 3 2</span></span><br><span class="line"><span class="comment">		 - b 3 2 2, 2 0 0, 1 2 2</span></span><br><span class="line"><span class="comment">		 - c 9 0 2, 3 0 2, 6 0 0</span></span><br><span class="line"><span class="comment">		 - d 2 2 2, 2 1 1, 0 1 1</span></span><br><span class="line"><span class="comment">		 - e 4 3 3, 0 0 2, 4 3 1</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"一共有几个进程："</span>);</span><br><span class="line">		pcb_nums = in.nextInt();</span><br><span class="line">		System.out.println(<span class="string">"一共有几个资源"</span>);</span><br><span class="line">		res_nums = in.nextInt();</span><br><span class="line">		pcbs = <span class="keyword">new</span> Proc[pcb_nums];  <span class="comment">// 创建进程数组</span></span><br><span class="line">		ava = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];     <span class="comment">// 可用资源</span></span><br><span class="line">		safe_seq = <span class="keyword">new</span> <span class="keyword">char</span>[pcb_nums];  <span class="comment">// 安全序列</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcbs.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			max = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];     <span class="comment">// 最大资源</span></span><br><span class="line">			alloc = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];   <span class="comment">// 拥有资源</span></span><br><span class="line">			need = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];    <span class="comment">// 需要资源</span></span><br><span class="line">			System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">			System.out.println(<span class="string">"输入第"</span> + (i+<span class="number">1</span>) + <span class="string">"个进程信息(名字-最大资源-拥有资源)"</span>);</span><br><span class="line">			System.out.println(<span class="string">"名字："</span>);</span><br><span class="line">			<span class="keyword">char</span> name = in.next().charAt(<span class="number">0</span>);</span><br><span class="line">			System.out.println(<span class="string">"最大资源："</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				max[j] = in.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"拥有资源："</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				alloc[j] = in.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				need[j] = max[j] - alloc[j];</span><br><span class="line">			&#125;</span><br><span class="line">			pcbs[i] = <span class="keyword">new</span> Proc(name, max, alloc, need);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"---可用资源---："</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ava[j] = in.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algori</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> safe_count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(safe_count != pcb_nums)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcb_nums; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pcbs[i].finish_status == <span class="keyword">false</span>) <span class="comment">// 判断该pcb是否完成</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">int</span> now_res = pcbs[i].getNeed_res()[j];</span><br><span class="line">						<span class="keyword">if</span> (now_res &lt;= ava[j])</span><br><span class="line">						&#123;</span><br><span class="line">							pcbs[i].finish_status = <span class="keyword">true</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							pcbs[i].finish_status = <span class="keyword">false</span>;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (pcbs[i].finish_status) <span class="comment">// 如果该pcb可以完成，则完成后回收资源</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">						&#123;</span><br><span class="line">							ava[j] += pcbs[i].getNeed_res()[j];</span><br><span class="line">						&#125;</span><br><span class="line">						safe_seq[safe_count] = pcbs[i].getName();</span><br><span class="line">						safe_count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcb_nums; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pcbs[i].finish_status)</span><br><span class="line">				&#123;</span><br><span class="line">					safe_stauts = <span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					safe_stauts = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!safe_stauts) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (safe_stauts) &#123;</span><br><span class="line">			System.out.println(<span class="string">"该系统安全，安全序列为："</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcb_nums; i++) &#123;</span><br><span class="line">				System.out.print(safe_seq[i]+<span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"该系统不安全"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		BankRR test = <span class="keyword">new</span> BankRR();</span><br><span class="line">		test.bank_init();</span><br><span class="line">		test.algori();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><p>进程样例如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/1.png" alt><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一共有几个进程：</span><br><span class="line">5</span><br><span class="line">一共有几个资源</span><br><span class="line">3</span><br><span class="line">-----------------------</span><br><span class="line">输入第1个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">a</span><br><span class="line">最大资源：</span><br><span class="line">7 5 3</span><br><span class="line">拥有资源：</span><br><span class="line">0 1 0</span><br><span class="line">-----------------------</span><br><span class="line">输入第2个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">b</span><br><span class="line">最大资源：</span><br><span class="line">3 2 2</span><br><span class="line">拥有资源：</span><br><span class="line">2 0 0</span><br><span class="line">-----------------------</span><br><span class="line">输入第3个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">c</span><br><span class="line">最大资源：</span><br><span class="line">9 0 2</span><br><span class="line">拥有资源：</span><br><span class="line">3 0 2</span><br><span class="line">-----------------------</span><br><span class="line">输入第4个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">d</span><br><span class="line">最大资源：</span><br><span class="line">2 2 2</span><br><span class="line">拥有资源：</span><br><span class="line">2 1 1</span><br><span class="line">-----------------------</span><br><span class="line">输入第5个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">e</span><br><span class="line">最大资源：</span><br><span class="line">4 3 3</span><br><span class="line">拥有资源：</span><br><span class="line">0 0 2</span><br><span class="line">---可用资源---：</span><br><span class="line">3 3 2</span><br><span class="line">该系统安全，安全序列为：</span><br><span class="line">b d e a c</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>进程死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>用python实现链式队列</title>
    <url>/2019/11/08/python%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列也是一种线性的数据结构，和栈相反的是，队列是一种<strong>先进先出</strong>的线性表。它只允许在表的一端进行插入，而在另一端进行删除元素。与我们现实生活中的排队是一样的：排在队伍最前面的会先完成事情离开队伍。<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%98%9F%E5%88%97/1_1.png" alt><br>在数据结构中抽象为一种<strong>线性链表</strong>，如下所示<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%98%9F%E5%88%97/1_2.png" alt></p><a id="more"></a>
<h2 id="链式队列基本数据结构"><a href="#链式队列基本数据结构" class="headerlink" title="链式队列基本数据结构"></a>链式队列基本数据结构</h2><p>链式队列即是链表构成，通过指针相连。实现过程如下</p>
<h3 id="链式队列基本单元-节点-Node"><a href="#链式队列基本单元-节点-Node" class="headerlink" title="链式队列基本单元: 节点(Node)"></a>链式队列基本单元: 节点(Node)</h3><p>创建<code>Node</code>类</p>
<ul>
<li>值域</li>
<li>指针域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param v: the value of node</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.value = v</span><br><span class="line">        self.pnext = None  # the pointer to point next</span><br></pre></td></tr></table></figure>
<h3 id="链式队列类"><a href="#链式队列类" class="headerlink" title="链式队列类"></a>链式队列类</h3><p>创建<code>LinkedQueue</code>类</p>
<ul>
<li>front: 队头节点</li>
<li>rear: 队尾节点</li>
<li>length: 队列长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LinkedQueue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.front = None  # the head node of queue</span><br><span class="line">        self.rear = None   # the rear node of queue</span><br><span class="line">        self.length = 0    # the length of queue</span><br></pre></td></tr></table></figure>
<h2 id="链式队列操作函数"><a href="#链式队列操作函数" class="headerlink" title="链式队列操作函数"></a>链式队列操作函数</h2><p><code>self</code>参数为对象本身，类似于C++中的<code>this</code>指针</p>
<h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><p>创建<code>queue_empty</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def queue_empty(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if the queue is empty</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.front is None:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p>
<h3 id="获取队首元素"><a href="#获取队首元素" class="headerlink" title="获取队首元素"></a>获取队首元素</h3><p>创建<code>get_head</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_head(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    get the value of head node</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return self.front.value</span><br></pre></td></tr></table></figure></p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>创建<code>enqueue</code>函数</p>
<ul>
<li>val: 节点值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def enqueue(self, val):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    insert value to queue&apos;s rear</span><br><span class="line">    :param val:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.queue_empty():</span><br><span class="line">        self.front = Node(val)</span><br><span class="line">        self.rear = self.front</span><br><span class="line">        self.length += 1</span><br><span class="line">    else:</span><br><span class="line">        self.rear.pnext = Node(val)</span><br><span class="line">        self.rear = self.rear.pnext</span><br><span class="line">        self.length += 1</span><br></pre></td></tr></table></figure>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>创建<code>dequeue</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dequeue(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    delete the value of head node and return its value</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not self.queue_empty():</span><br><span class="line">        val = self.front.value</span><br><span class="line">        self.front = self.front.pnext</span><br><span class="line">        self.length -= 1</span><br><span class="line">        return val</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历队列-队首-队尾"><a href="#遍历队列-队首-队尾" class="headerlink" title="遍历队列(队首-队尾)"></a>遍历队列(队首-队尾)</h3><p>创建<code>queue_traverse</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def queue_traverse(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    traverse the queue</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&apos;队头-&gt;|&apos;, end=&apos; &apos;)</span><br><span class="line">    tmp = self.front</span><br><span class="line">    while tmp:</span><br><span class="line">        print(tmp.value, &apos;|&apos;, end=&apos; &apos;)</span><br><span class="line">        tmp = tmp.pnext</span><br><span class="line">    print(&quot;\n&quot;)</span><br></pre></td></tr></table></figure></p>
<h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>创建程序入口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    my_queue = LinkedQueue()</span><br><span class="line">    my_queue.enqueue([1, 2, 3])</span><br><span class="line">    my_queue.enqueue(456)</span><br><span class="line">    my_queue.enqueue(&apos;hello&apos;)</span><br><span class="line">    my_queue.queue_traverse()</span><br><span class="line">    my_queue.dequeue()</span><br><span class="line">    my_queue.queue_traverse()</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队头-&gt;| [1, 2, 3] | 456 | hello |</span><br><span class="line"></span><br><span class="line">队头-&gt;| 456 | hello |</span><br></pre></td></tr></table></figure></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/SkecisAI/python-DS/blob/master/linked_queue.py" target="_blank" rel="noopener">点击此处访问</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>用python实现链式栈</title>
    <url>/2019/11/06/python-stack/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种线性的数据结构。栈的定义是：限定仅在表尾进行插入或删除操作的线性表(线性表的介绍参见我的另一篇<a href="https://skecis.top/2019/11/01/python%E9%93%BE%E8%A1%A8/#more" target="_blank" rel="noopener">博文</a>)。直观一点来看，如下图<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%A0%88/1.png" alt><br>即最后进栈的元素最先出来，又称为<strong>后进先出</strong>的线性表</p><a id="more"></a>
<h2 id="链式栈基本数据结构"><a href="#链式栈基本数据结构" class="headerlink" title="链式栈基本数据结构"></a>链式栈基本数据结构</h2><p>链式栈即是链式表构成的，通过指针相连。实现过程如下</p>
<h3 id="链式栈基本单元-节点-Node"><a href="#链式栈基本单元-节点-Node" class="headerlink" title="链式栈基本单元: 节点(Node)"></a>链式栈基本单元: 节点(Node)</h3><p>创建<code>Node</code>类</p>
<ul>
<li>值域</li>
<li>指针域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param v: the value of node</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.value = v</span><br><span class="line">        self.pnext = None  # the pointer to point next</span><br></pre></td></tr></table></figure>
<h3 id="链式栈类"><a href="#链式栈类" class="headerlink" title="链式栈类"></a>链式栈类</h3><p>创建<code>LinkedStack</code>类</p>
<ul>
<li>top: 栈顶节点</li>
<li>bottom: 栈底节点</li>
<li>length: 栈长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LinkedStack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.top = None  # the top node</span><br><span class="line">        self.bottom = None  # the bottom node</span><br><span class="line">        self.length = 0  # the length of this stack</span><br></pre></td></tr></table></figure>
<h2 id="链式栈操作函数"><a href="#链式栈操作函数" class="headerlink" title="链式栈操作函数"></a>链式栈操作函数</h2><p><code>self</code>参数为对象本身，类似于C++中的<code>this</code>指针</p>
<h3 id="压栈"><a href="#压栈" class="headerlink" title="压栈"></a>压栈</h3><p>创建<code>push</code>函数</p>
<ul>
<li>val: 节点值域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def push(self, val):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    add a value to stack</span><br><span class="line">    :param val: the value</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not self.stack_empty():</span><br><span class="line">        self.top.pnext = Node(val)</span><br><span class="line">        self.top = self.top.pnext</span><br><span class="line">        self.length += 1</span><br><span class="line">    else:</span><br><span class="line">        self.top = Node(val)</span><br><span class="line">        self.bottom = self.top</span><br><span class="line">        self.length += 1</span><br></pre></td></tr></table></figure>
<h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><p>创建<code>pop</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def pop(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    delete the node at the top and return its value</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    tmp_top = self.top</span><br><span class="line">    tmp_bottom = self.bottom</span><br><span class="line">    for i in range(1, self.length+1):</span><br><span class="line">        if i == self.length - 1:</span><br><span class="line">            self.top = tmp_bottom</span><br><span class="line">            self.top.pnext = None</span><br><span class="line">            self.length -= 1</span><br><span class="line">        else:</span><br><span class="line">            tmp_bottom = tmp_bottom.pnext</span><br><span class="line">    return tmp_top.value</span><br></pre></td></tr></table></figure></p>
<h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><p>创建<code>stack_empty</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def stack_empty(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if the stack is empty</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.top is None:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p>
<h3 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><p>创建<code>get_top</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_top(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return the value of top</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return self.top.value</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历栈-栈底-栈顶"><a href="#遍历栈-栈底-栈顶" class="headerlink" title="遍历栈(栈底-栈顶)"></a>遍历栈(栈底-栈顶)</h3><p>创建<code>stack_traverse</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def stack_traverse(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    traverse the stack</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    tmp = self.bottom</span><br><span class="line">    tmp_list = []</span><br><span class="line">    while tmp:</span><br><span class="line">        tmp_list.append(tmp.value)</span><br><span class="line">        tmp = tmp.pnext</span><br><span class="line">    tmp_list = tmp_list[::-1]</span><br><span class="line">    print(&quot;\n-----栈顶-----&quot;)</span><br><span class="line">    for val in tmp_list:</span><br><span class="line">        print(val)</span><br><span class="line">    print(&quot;--------------\n&quot;)</span><br></pre></td></tr></table></figure></p>
<h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>创建程序入口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    my_stack = LinkedStack()</span><br><span class="line">    my_stack.push([&apos;start&apos;])</span><br><span class="line">    my_stack.push(12)</span><br><span class="line">    my_stack.push(2323)</span><br><span class="line">    my_stack.push([&apos;end&apos;])</span><br><span class="line">    my_stack.stack_traverse()</span><br><span class="line">    print(my_stack.pop())</span><br><span class="line">    my_stack.stack_traverse()</span><br><span class="line">    print(my_stack.length)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-----栈顶-----</span><br><span class="line">[&apos;end&apos;]</span><br><span class="line">2323</span><br><span class="line">12</span><br><span class="line">[&apos;start&apos;]</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line">[&apos;end&apos;]</span><br><span class="line"></span><br><span class="line">-----栈顶-----</span><br><span class="line">2323</span><br><span class="line">12</span><br><span class="line">[&apos;start&apos;]</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/SkecisAI/python-DS/blob/master/linked_stack.py" target="_blank" rel="noopener">点击此处访问</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas数据操作：分组和聚合</title>
    <url>/2019/11/06/pandas-groupby/</url>
    <content><![CDATA[<h2 id="导入必要的库"><a href="#导入必要的库" class="headerlink" title="导入必要的库"></a>导入必要的库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure><h2 id="导入数据集"><a href="#导入数据集" class="headerlink" title="导入数据集"></a>导入数据集</h2><p>我下载了seaborn中的<a href="https://github.com/mwaskom/seaborn-data" target="_blank" rel="noopener">数据集</a>(都是小型的数据集)，选择了其中的航班数据集<code>flight.csv</code>，并放入了本地seaborn_dataset文件夹(该文件夹放在项目根目录)中<br>导入flight数据集(使用<code>read_csv</code>函数)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flight_df = pd.read_csv(&apos;seaborn_dataset/flights.csv&apos;)</span><br></pre></td></tr></table></figure></p><a id="more"></a>

<p>粗略看看该数据集(使用<code>head</code>函数)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(flight_df.head())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   year     month  passengers</span><br><span class="line">0  1949   January         112</span><br><span class="line">1  1949  February         118</span><br><span class="line">2  1949     March         132</span><br><span class="line">3  1949     April         129</span><br><span class="line">4  1949       May         121</span><br></pre></td></tr></table></figure></p>
<p>再看看数据类型(使用<code>info</code>函数)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(flight_df.info())</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;</span><br><span class="line">RangeIndex: 144 entries, 0 to 143</span><br><span class="line">Data columns (total 3 columns):</span><br><span class="line">year          144 non-null int64</span><br><span class="line">month         144 non-null object</span><br><span class="line">passengers    144 non-null int64</span><br><span class="line">dtypes: int64(2), object(1)</span><br><span class="line">memory usage: 3.5+ KB</span><br><span class="line">None</span><br></pre></td></tr></table></figure></p>
<p>注意其中的<code>year</code>和<code>passengers</code>为int型数据</p>
<h2 id="根据单个column的值分组"><a href="#根据单个column的值分组" class="headerlink" title="根据单个column的值分组"></a>根据单个column的值分组</h2><h3 id="使用groupby函数"><a href="#使用groupby函数" class="headerlink" title="使用groupby函数"></a>使用<code>groupby</code>函数</h3><p>参数为column名，可代入单个column名，或column名组成的列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grouped = flight_df.groupby(&apos;year&apos;)</span><br><span class="line">print(grouped)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002783D62D860&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看到返回的是一个pandas的<strong>分组对象</strong><code>DataFrameGroupBy</code>(或者<code>SeriesGroupBy</code>)</p>
<h3 id="获取分组数量"><a href="#获取分组数量" class="headerlink" title="获取分组数量"></a>获取分组数量</h3><p>使用分组对象的<code>ngroups</code>属性，类型为一个int型数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.ngroups)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure></p>
<h3 id="获取分组内容"><a href="#获取分组内容" class="headerlink" title="获取分组内容"></a>获取分组内容</h3><p>利用分组对象的<code>groups</code>属性，类型为一个字典(dict)，字典的键(key)为组名，值(value)为每一组所有的对应的索引(index)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.groups)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1949: Int64Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], dtype=&apos;int64&apos;), 1950: Int64Index([12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], dtype=&apos;int64&apos;), 1951: Int64Index([24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35], dtype=&apos;int64&apos;), 1952: Int64Index([36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], dtype=&apos;int64&apos;), 1953: Int64Index([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59], dtype=&apos;int64&apos;), 1954: Int64Index([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71], dtype=&apos;int64&apos;), 1955: Int64Index([72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83], dtype=&apos;int64&apos;), 1956: Int64Index([84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95], dtype=&apos;int64&apos;), 1957: Int64Index([96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107], dtype=&apos;int64&apos;), 1958: Int64Index([108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119], dtype=&apos;int64&apos;), 1959: Int64Index([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131], dtype=&apos;int64&apos;), 1960: Int64Index([132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143], dtype=&apos;int64&apos;)&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="访问分组结果"><a href="#访问分组结果" class="headerlink" title="访问分组结果"></a>访问分组结果</h2><h3 id="输出每个组的细节"><a href="#输出每个组的细节" class="headerlink" title="输出每个组的细节"></a>输出每个组的细节</h3><p>编写一个有利于输出分组内容的函数(function)，并调用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_groups(group_object):</span><br><span class="line">    for name, group in group_object:</span><br><span class="line">        print(name)</span><br><span class="line">        print(group)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_groups(grouped)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1949</span><br><span class="line">    year      month  passengers</span><br><span class="line">0   1949    January         112</span><br><span class="line">1   1949   February         118</span><br><span class="line">2   1949      March         132</span><br><span class="line">3   1949      April         129</span><br><span class="line">4   1949        May         121</span><br><span class="line">5   1949       June         135</span><br><span class="line">6   1949       July         148</span><br><span class="line">7   1949     August         148</span><br><span class="line">8   1949  September         136</span><br><span class="line">9   1949    October         119</span><br><span class="line">10  1949   November         104</span><br><span class="line">11  1949   December         118</span><br><span class="line">1950</span><br><span class="line">    year      month  passengers</span><br><span class="line">12  1950    January         115</span><br><span class="line">13  1950   February         126</span><br><span class="line">14  1950      March         141</span><br><span class="line">15  1950      April         135</span><br><span class="line">16  1950        May         125</span><br><span class="line">17  1950       June         149</span><br><span class="line">18  1950       July         170</span><br><span class="line">19  1950     August         170</span><br><span class="line">20  1950  September         158</span><br><span class="line">21  1950    October         133</span><br><span class="line">22  1950   November         114</span><br><span class="line">23  1950   December         140</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">1960</span><br><span class="line">     year      month  passengers</span><br><span class="line">132  1960    January         417</span><br><span class="line">133  1960   February         391</span><br><span class="line">134  1960      March         419</span><br><span class="line">135  1960      April         461</span><br><span class="line">136  1960        May         472</span><br><span class="line">137  1960       June         535</span><br><span class="line">138  1960       July         622</span><br><span class="line">139  1960     August         606</span><br><span class="line">140  1960  September         508</span><br><span class="line">141  1960    October         461</span><br><span class="line">142  1960   November         390</span><br><span class="line">143  1960   December         432</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组元素的数量"><a href="#获取每个组元素的数量" class="headerlink" title="获取每个组元素的数量"></a>获取每个组元素的数量</h3><p>使用<code>size</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(gruoped.size())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">year</span><br><span class="line">1949    12</span><br><span class="line">1950    12</span><br><span class="line">1951    12</span><br><span class="line">1952    12</span><br><span class="line">1953    12</span><br><span class="line">1954    12</span><br><span class="line">1955    12</span><br><span class="line">1956    12</span><br><span class="line">1957    12</span><br><span class="line">1958    12</span><br><span class="line">1959    12</span><br><span class="line">1960    12</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组中每个column的元素数量"><a href="#获取每个组中每个column的元素数量" class="headerlink" title="获取每个组中每个column的元素数量"></a>获取每个组中每个column的元素数量</h3><p>使用<code>count</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.count())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      month  passengers</span><br><span class="line">year</span><br><span class="line">1949     12          12</span><br><span class="line">1950     12          12</span><br><span class="line">1951     12          12</span><br><span class="line">1952     12          12</span><br><span class="line">1953     12          12</span><br><span class="line">1954     12          12</span><br><span class="line">1955     12          12</span><br><span class="line">1956     12          12</span><br><span class="line">1957     12          12</span><br><span class="line">1958     12          12</span><br><span class="line">1959     12          12</span><br><span class="line">1960     12          12</span><br></pre></td></tr></table></figure></p>
<h3 id="获取指定组名的组的数据"><a href="#获取指定组名的组的数据" class="headerlink" title="获取指定组名的组的数据"></a>获取指定组名的组的数据</h3><p>使用<code>get_group</code>函数，参数为组的名字。因为这里的<code>year</code>是整型数据，故代入整数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.get_group(1950))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    year      month  passengers</span><br><span class="line">12  1950    January         115</span><br><span class="line">13  1950   February         126</span><br><span class="line">14  1950      March         141</span><br><span class="line">15  1950      April         135</span><br><span class="line">16  1950        May         125</span><br><span class="line">17  1950       June         149</span><br><span class="line">18  1950       July         170</span><br><span class="line">19  1950     August         170</span><br><span class="line">20  1950  September         158</span><br><span class="line">21  1950    October         133</span><br><span class="line">22  1950   November         114</span><br><span class="line">23  1950   December         140</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组中前两个个元素"><a href="#获取每个组中前两个个元素" class="headerlink" title="获取每个组中前两个个元素"></a>获取每个组中前两个个元素</h3><p>使用<code>head</code>函数，参数为元素数量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.head(2))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     year     month  passengers</span><br><span class="line">0    1949   January         112</span><br><span class="line">1    1949  February         118</span><br><span class="line">12   1950   January         115</span><br><span class="line">13   1950  February         126</span><br><span class="line">24   1951   January         145</span><br><span class="line">25   1951  February         150</span><br><span class="line">36   1952   January         171</span><br><span class="line">37   1952  February         180</span><br><span class="line">48   1953   January         196</span><br><span class="line">49   1953  February         196</span><br><span class="line">60   1954   January         204</span><br><span class="line">61   1954  February         188</span><br><span class="line">72   1955   January         242</span><br><span class="line">73   1955  February         233</span><br><span class="line">84   1956   January         284</span><br><span class="line">85   1956  February         277</span><br><span class="line">96   1957   January         315</span><br><span class="line">97   1957  February         301</span><br><span class="line">108  1958   January         340</span><br><span class="line">109  1958  February         318</span><br><span class="line">120  1959   January         360</span><br><span class="line">121  1959  February         342</span><br><span class="line">132  1960   January         417</span><br><span class="line">133  1960  February         391</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组的第3行数据"><a href="#获取每个组的第3行数据" class="headerlink" title="获取每个组的第3行数据"></a>获取每个组的第3行数据</h3><p>使用<code>nth</code>函数，参数为行号<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.nth(3))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      month  passengers</span><br><span class="line">year</span><br><span class="line">1949  April         129</span><br><span class="line">1950  April         135</span><br><span class="line">1951  April         163</span><br><span class="line">1952  April         181</span><br><span class="line">1953  April         235</span><br><span class="line">1954  April         227</span><br><span class="line">1955  April         269</span><br><span class="line">1956  April         313</span><br><span class="line">1957  April         348</span><br><span class="line">1958  April         348</span><br><span class="line">1959  April         396</span><br><span class="line">1960  April         461</span><br></pre></td></tr></table></figure></p>
<h3 id="根据多个column分组"><a href="#根据多个column分组" class="headerlink" title="根据多个column分组*"></a>根据多个column分组*</h3><p>根据两个column分组，传入column名字列表(list)。并用前面的<code>print_groups</code>函数打印组信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mcg = flight_df.groupby([&apos;year&apos;, &apos;month&apos;])</span><br><span class="line">print_groups(mcg)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1949, &apos;April&apos;)</span><br><span class="line">   year  month  passengers</span><br><span class="line">3  1949  April         129</span><br><span class="line">(1949, &apos;August&apos;)</span><br><span class="line">   year   month  passengers</span><br><span class="line">7  1949  August         148</span><br><span class="line">(1949, &apos;December&apos;)</span><br><span class="line">    year     month  passengers</span><br><span class="line">11  1949  December         118</span><br><span class="line">(1949, &apos;February&apos;)</span><br><span class="line">   year     month  passengers</span><br><span class="line">1  1949  February         118</span><br><span class="line">(1949, &apos;January&apos;)</span><br><span class="line">   year    month  passengers</span><br><span class="line">0  1949  January         112</span><br><span class="line">(1949, &apos;July&apos;)</span><br><span class="line">   year month  passengers</span><br><span class="line">6  1949  July         148</span><br><span class="line">(1949, &apos;June&apos;)</span><br><span class="line">   year month  passengers</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">138  1960  July         622</span><br><span class="line">(1960, &apos;June&apos;)</span><br><span class="line">     year month  passengers</span><br><span class="line">137  1960  June         535</span><br><span class="line">(1960, &apos;March&apos;)</span><br><span class="line">     year  month  passengers</span><br><span class="line">134  1960  March         419</span><br><span class="line">(1960, &apos;May&apos;)</span><br><span class="line">     year month  passengers</span><br><span class="line">136  1960   May         472</span><br><span class="line">(1960, &apos;November&apos;)</span><br><span class="line">     year     month  passengers</span><br><span class="line">142  1960  November         390</span><br><span class="line">(1960, &apos;October&apos;)</span><br><span class="line">     year    month  passengers</span><br><span class="line">141  1960  October         461</span><br><span class="line">(1960, &apos;September&apos;)</span><br><span class="line">     year      month  passengers</span><br><span class="line">140  1960  September         508</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组的描述性统计变量"><a href="#获取每个组的描述性统计变量" class="headerlink" title="获取每个组的描述性统计变量"></a>获取每个组的描述性统计变量</h3><p>使用<code>describe</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mcg.describe())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               passengers</span><br><span class="line">                    count   mean std    min    25%    50%    75%    max</span><br><span class="line">year month</span><br><span class="line">1949 April            1.0  129.0 NaN  129.0  129.0  129.0  129.0  129.0</span><br><span class="line">     August           1.0  148.0 NaN  148.0  148.0  148.0  148.0  148.0</span><br><span class="line">     December         1.0  118.0 NaN  118.0  118.0  118.0  118.0  118.0</span><br><span class="line">     February         1.0  118.0 NaN  118.0  118.0  118.0  118.0  118.0</span><br><span class="line">     January          1.0  112.0 NaN  112.0  112.0  112.0  112.0  112.0</span><br><span class="line">...                   ...    ...  ..    ...    ...    ...    ...    ...</span><br><span class="line">1960 March            1.0  419.0 NaN  419.0  419.0  419.0  419.0  419.0</span><br><span class="line">     May              1.0  472.0 NaN  472.0  472.0  472.0  472.0  472.0</span><br><span class="line">     November         1.0  390.0 NaN  390.0  390.0  390.0  390.0  390.0</span><br><span class="line">     October          1.0  461.0 NaN  461.0  461.0  461.0  461.0  461.0</span><br><span class="line">     September        1.0  508.0 NaN  508.0  508.0  508.0  508.0  508.0</span><br><span class="line"></span><br><span class="line">[144 rows x 8 columns]</span><br></pre></td></tr></table></figure></p>
<p>分析结果可知，每个组仅有一行数据</p>
<h2 id="使用等级制的索引分组"><a href="#使用等级制的索引分组" class="headerlink" title="使用等级制的索引分组"></a>使用等级制的索引分组</h2><p>创建一个原数据的浅复制，使用<code>copy</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mi = flight_df.copy()</span><br></pre></td></tr></table></figure></p>
<h3 id="使用set-index函数"><a href="#使用set-index函数" class="headerlink" title="使用set_index函数"></a>使用<code>set_index</code>函数</h3><p>参数为column名字列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mi = mi.set_index([&apos;year&apos;, &apos;month&apos;])</span><br><span class="line">print(mi)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1949 January           112</span><br><span class="line">     February          118</span><br><span class="line">     March             132</span><br><span class="line">     April             129</span><br><span class="line">     May               121</span><br><span class="line">...                    ...</span><br><span class="line">1960 August            606</span><br><span class="line">     September         508</span><br><span class="line">     October           461</span><br><span class="line">     November          390</span><br><span class="line">     December          432</span><br><span class="line"></span><br><span class="line">[144 rows x 1 columns]</span><br></pre></td></tr></table></figure></p>
<h3 id="使用第一个等级的索引分组"><a href="#使用第一个等级的索引分组" class="headerlink" title="使用第一个等级的索引分组"></a>使用第一个等级的索引分组</h3><p>使用了<code>groupby</code>函数中的<code>level</code>参数，类型为int型。最后使用<code>print_groups</code>函数输出组详情。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mig_11 = mi.groupby(level=0)</span><br><span class="line">print_groups(mig_11)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1949</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1949 January           112</span><br><span class="line">     February          118</span><br><span class="line">     March             132</span><br><span class="line">     April             129</span><br><span class="line">     May               121</span><br><span class="line">     June              135</span><br><span class="line">     July              148</span><br><span class="line">     August            148</span><br><span class="line">     September         136</span><br><span class="line">     October           119</span><br><span class="line">     November          104</span><br><span class="line">     December          118</span><br><span class="line">1950</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1950 January           115</span><br><span class="line">     February          126</span><br><span class="line">     March             141</span><br><span class="line">     April             135</span><br><span class="line">     May               125</span><br><span class="line">     June              149</span><br><span class="line">     July              170</span><br><span class="line">     August            170</span><br><span class="line">     September         158</span><br><span class="line">     October           133</span><br><span class="line">     November          114</span><br><span class="line">     December          140</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">1959</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1959 January           360</span><br><span class="line">     February          342</span><br><span class="line">     March             406</span><br><span class="line">     April             396</span><br><span class="line">     May               420</span><br><span class="line">     June              472</span><br><span class="line">     July              548</span><br><span class="line">     August            559</span><br><span class="line">     September         463</span><br><span class="line">     October           407</span><br><span class="line">     November          362</span><br><span class="line">     December          405</span><br><span class="line">1960</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1960 January           417</span><br><span class="line">     February          391</span><br><span class="line">     March             419</span><br><span class="line">     April             461</span><br><span class="line">     May               472</span><br><span class="line">     June              535</span><br><span class="line">     July              622</span><br><span class="line">     August            606</span><br><span class="line">     September         508</span><br><span class="line">     October           461</span><br><span class="line">     November          390</span><br><span class="line">     December          432</span><br></pre></td></tr></table></figure></p>
<h3 id="使用多个等级的索引分组"><a href="#使用多个等级的索引分组" class="headerlink" title="使用多个等级的索引分组"></a>使用多个等级的索引分组</h3><p>向<code>level</code>参数赋值索引列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mig_12 = mi.groupby(level=[&apos;year&apos;, &apos;month&apos;])</span><br><span class="line">print_groups(mig_12)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1949, &apos;April&apos;)</span><br><span class="line">            passengers</span><br><span class="line">year month</span><br><span class="line">1949 April         129</span><br><span class="line">(1949, &apos;August&apos;)</span><br><span class="line">             passengers</span><br><span class="line">year month</span><br><span class="line">1949 August         148</span><br><span class="line">(1949, &apos;December&apos;)</span><br><span class="line">               passengers</span><br><span class="line">year month</span><br><span class="line">1949 December         118</span><br><span class="line">(1949, &apos;February&apos;)</span><br><span class="line">               passengers</span><br><span class="line">year month</span><br><span class="line">1949 February         118</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">(1960, &apos;November&apos;)</span><br><span class="line">               passengers</span><br><span class="line">year month</span><br><span class="line">1960 November         390</span><br><span class="line">(1960, &apos;October&apos;)</span><br><span class="line">              passengers</span><br><span class="line">year month</span><br><span class="line">1960 October         461</span><br><span class="line">(1960, &apos;September&apos;)</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1960 September         508</span><br></pre></td></tr></table></figure></p>
<h2 id="使用聚合函数agg：参数为函数名"><a href="#使用聚合函数agg：参数为函数名" class="headerlink" title="使用聚合函数agg：参数为函数名"></a>使用聚合函数<code>agg</code>：参数为函数名</h2><h3 id="计算组的平均值"><a href="#计算组的平均值" class="headerlink" title="计算组的平均值"></a>计算组的平均值</h3><p>传入<code>np.mean</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mig_12.agg(np.mean))</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1949 April             129</span><br><span class="line">     August            148</span><br><span class="line">     December          118</span><br><span class="line">     February          118</span><br><span class="line">     January           112</span><br><span class="line">...                    ...</span><br><span class="line">1960 March             419</span><br><span class="line">     May               472</span><br><span class="line">     November          390</span><br><span class="line">     October           461</span><br><span class="line">     September         508</span><br><span class="line"></span><br><span class="line">[144 rows x 1 columns]</span><br></pre></td></tr></table></figure></p>
<p>不创建索引，使用<code>groupby</code>函数的<code>as_index</code>参数(设置为<code>False</code>，创建索引设置为<code>True</code>)，类型为布尔型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = flight_df.groupby([&apos;year&apos;, &apos;month&apos;], as_index=False).agg(np.mean)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     year      month  passengers</span><br><span class="line">0    1949      April         129</span><br><span class="line">1    1949     August         148</span><br><span class="line">2    1949   December         118</span><br><span class="line">3    1949   February         118</span><br><span class="line">4    1949    January         112</span><br><span class="line">..    ...        ...         ...</span><br><span class="line">139  1960      March         419</span><br><span class="line">140  1960        May         472</span><br><span class="line">141  1960   November         390</span><br><span class="line">142  1960    October         461</span><br><span class="line">143  1960  September         508</span><br><span class="line"></span><br><span class="line">[144 rows x 3 columns]</span><br></pre></td></tr></table></figure></p>
<h3 id="一次使用多个函数"><a href="#一次使用多个函数" class="headerlink" title="一次使用多个函数"></a>一次使用多个函数</h3><p>向参数<code>as_index</code>传入函数名列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mig_12.agg([np.mean, np.std]))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               passengers</span><br><span class="line">                     mean std</span><br><span class="line">year month</span><br><span class="line">1949 April            129 NaN</span><br><span class="line">     August           148 NaN</span><br><span class="line">     December         118 NaN</span><br><span class="line">     February         118 NaN</span><br><span class="line">     January          112 NaN</span><br><span class="line">...                   ...  ..</span><br><span class="line">1960 March            419 NaN</span><br><span class="line">     May              472 NaN</span><br><span class="line">     November         390 NaN</span><br><span class="line">     October          461 NaN</span><br><span class="line">     September        508 NaN</span><br><span class="line"></span><br><span class="line">[144 rows x 2 columns]</span><br></pre></td></tr></table></figure></p>
<h3 id="对不同的column应用不同的函数"><a href="#对不同的column应用不同的函数" class="headerlink" title="对不同的column应用不同的函数"></a>对不同的column应用不同的函数</h3><p>通过对<code>as_index</code>参数传入字典(dict)实现，字典键(key)为column名，值(value)为函数名。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = mig_12.agg(&#123;&apos;passengers&apos;: np.mean&#125;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1949 April             129</span><br><span class="line">     August            148</span><br><span class="line">     December          118</span><br><span class="line">     February          118</span><br><span class="line">     January           112</span><br><span class="line">...                    ...</span><br><span class="line">1960 March             419</span><br><span class="line">     May               472</span><br><span class="line">     November          390</span><br><span class="line">     October           461</span><br><span class="line">     September         508</span><br><span class="line"></span><br><span class="line">[144 rows x 1 columns]</span><br></pre></td></tr></table></figure></p>
<h3 id="只对指定的column应用函数"><a href="#只对指定的column应用函数" class="headerlink" title="只对指定的column应用函数"></a>只对指定的column应用函数</h3><p>对分组对象使用[ ]运算符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mig_12[&apos;passengers&apos;].mean())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">year  month</span><br><span class="line">1949  April        129</span><br><span class="line">      August       148</span><br><span class="line">      December     118</span><br><span class="line">      February     118</span><br><span class="line">      January      112</span><br><span class="line">                  ...</span><br><span class="line">1960  March        419</span><br><span class="line">      May          472</span><br><span class="line">      November     390</span><br><span class="line">      October      461</span><br><span class="line">      September    508</span><br><span class="line">Name: passengers, Length: 144, dtype: int64</span><br></pre></td></tr></table></figure></p>
<p>返回的是一个<code>Series</code>对象</p>
]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫实践:下载壁纸</title>
    <url>/2019/11/02/python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="导入必要的包-package"><a href="#导入必要的包-package" class="headerlink" title="导入必要的包(package)"></a>导入必要的包(package)</h2><p>若没有下列的包，可使用<code>pip install 包名</code>命令安装</p><ul>
<li>re: 使用正则表达式</li>
<li>requests: 向网站发出请求</li>
<li>bs4: 解析网页内容</li>
<li>time: 计算时间</li>
</ul><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br></pre></td></tr></table></figure>
<h2 id="任务要求-批量下载某网站的壁纸"><a href="#任务要求-批量下载某网站的壁纸" class="headerlink" title="任务要求: 批量下载某网站的壁纸"></a>任务要求: 批量下载某网站的壁纸</h2><h3 id="访问壁纸网站"><a href="#访问壁纸网站" class="headerlink" title="访问壁纸网站"></a>访问壁纸网站</h3><p>我选择的是壁纸质量高的wallpapers home<a href="https://wallpapershome.com" target="_blank" rel="noopener">点击此处访问</a>，网站主页如下<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_1.png" alt></p>
<h3 id="寻找关键页面"><a href="#寻找关键页面" class="headerlink" title="寻找关键页面"></a>寻找关键页面</h3><p>点击主页上的<a href="https://wallpapershome.com/?page=1" target="_blank" rel="noopener">View All Wallpapers</a>注意网址变化<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_2.png" alt><br>目标页面，出现了参数<code>page=1</code>，<strong>每个页面有12张壁纸信息</strong><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_3.png" alt></p>
<h3 id="查看页面请求头"><a href="#查看页面请求头" class="headerlink" title="查看页面请求头"></a>查看页面请求头</h3><p>寻找<code>Host</code>信息和<code>Headers</code>信息，使用开发者工具操作，如下<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_7.png" alt></p>
<h3 id="定位壁纸信息"><a href="#定位壁纸信息" class="headerlink" title="定位壁纸信息"></a>定位壁纸信息</h3><p>选择元素，找到图片的准确信息，操作步骤如下图<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_4.png" alt></p>
<h3 id="找到壁纸信息"><a href="#找到壁纸信息" class="headerlink" title="找到壁纸信息"></a>找到壁纸信息</h3><p>壁纸所在的<code>div</code>标签的类名为<code>class=pics</code><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_5.png" alt></p>
<h3 id="准确定位壁纸的地址"><a href="#准确定位壁纸的地址" class="headerlink" title="准确定位壁纸的地址"></a>准确定位壁纸的地址</h3><p>在上述页面中点击任意一张壁纸，会出现新页面，在新页面中将鼠标移至<code>Download</code>处，选择分辨率<code>1920x1080</code>，浏览器左下角将会出现壁纸的地址信息如下<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_6.png" alt></p>
<h2 id="任务分析"><a href="#任务分析" class="headerlink" title="任务分析"></a>任务分析</h2><h3 id="定制请求头和初始变量"><a href="#定制请求头和初始变量" class="headerlink" title="定制请求头和初始变量"></a>定制请求头和初始变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36&apos;,</span><br><span class="line">    &apos;Host&apos;: &apos;wallpapershome.com&apos;</span><br><span class="line">&#125;</span><br><span class="line">size = &apos;1920x1080&apos;  # 分辨率</span><br><span class="line">save_path = &apos;wallpapers_src/&apos;  # 本地存储地址</span><br><span class="line">start = time.time()  # 程序开始时刻</span><br></pre></td></tr></table></figure>
<h3 id="目标网页的网址规律"><a href="#目标网页的网址规律" class="headerlink" title="目标网页的网址规律"></a>目标网页的网址规律</h3><p>因为不仅仅抓取一个页面的壁纸，故可利用<code>page</code>参数设置请求地址，查看页面数量可知一共有1502张页面，故可如下操作即可访问每个页面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(1502):</span><br><span class="line">    wallpaper_name = []  # 存储每张页面的壁纸名字</span><br><span class="line">    url = &quot;https://wallpapershome.com/?page=&quot; + str(i+1)</span><br><span class="line">    r = requests.get(url, headers=headers)</span><br><span class="line">    print(&quot;状态响应码:&quot;, r.status_code)</span><br></pre></td></tr></table></figure></p>
<h3 id="解析壁纸的地址信息"><a href="#解析壁纸的地址信息" class="headerlink" title="解析壁纸的地址信息"></a>解析壁纸的地址信息</h3><p>通过先前的壁纸的地址信息分析可知，每张壁纸存贮在地址<code>https://wallpapershome.com/images/wallpapers/</code>下，壁纸格式形如<code>分类-分辨率-清晰度-名字.jpg</code>，故利用获取到的壁纸名，再通过设定分辨率，组合可得到壁纸地址<br>创建一个处理壁纸名的函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def handle_name(line):</span><br><span class="line">    sep = &apos;-&apos;</span><br><span class="line">    m = re.match(&apos;(.*)/(.*).html$&apos;, line)</span><br><span class="line">    name = m.group(2)</span><br><span class="line">    name = name.split(&apos;-&apos;)</span><br><span class="line">    name.insert(-2, size)</span><br><span class="line">    name = sep.join(name)</span><br><span class="line">    return name</span><br></pre></td></tr></table></figure></p>
<p>再获取每页12张壁纸全名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(r.content, &apos;lxml&apos;)</span><br><span class="line">wallpaper_list = soup.find(&apos;div&apos;, class_=&apos;pics&apos;)</span><br><span class="line">for j in range(12):</span><br><span class="line">    wallpaper_name.append(handle_name(wallpaper_list.contents[j].a.get(&apos;href&apos;)))</span><br></pre></td></tr></table></figure></p>
<h3 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h3><p>检测运行状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;正在下载第&quot; + str(i+1) + &quot;个页面&quot;)</span><br><span class="line">cost = time.time() - start</span><br><span class="line">print(&quot;已运行时间:&quot; + str(cost) + &apos;秒&apos;)</span><br></pre></td></tr></table></figure></p>
<h3 id="下载每张壁纸"><a href="#下载每张壁纸" class="headerlink" title="下载每张壁纸"></a>下载每张壁纸</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for j in range(12):</span><br><span class="line">    src_url = &apos;https://wallpapershome.com/images/wallpapers/&apos; + wallpaper_name[j] + &apos;.jpg&apos;</span><br><span class="line">    with open(save_path+wallpaper_name[j]+&apos;.jpg&apos;, &apos;wb&apos;) as f:</span><br><span class="line">        img = requests.get(src_url).content</span><br><span class="line">        f.write(img)</span><br><span class="line">        print(&apos;+&apos;, end=&apos;&apos;)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>
<h2 id="运行效果如下"><a href="#运行效果如下" class="headerlink" title="运行效果如下"></a>运行效果如下</h2><p>可能因为是国外网站的原因，下载速度慢得… -.-  部分运行结果如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">状态响应码: 200</span><br><span class="line">正在下载第69个页面</span><br><span class="line">已运行时间:3.5130293369293213秒</span><br><span class="line">++++++++++++</span><br><span class="line"></span><br><span class="line">状态响应码: 200</span><br><span class="line">正在下载第70个页面</span><br><span class="line">已运行时间:85.50803112983704秒</span><br><span class="line">++</span><br></pre></td></tr></table></figure></p>
<h3 id="大量精美壁纸-free-收入囊中"><a href="#大量精美壁纸-free-收入囊中" class="headerlink" title="大量精美壁纸(free)收入囊中"></a>大量精美壁纸(free)收入囊中</h3><p>岂不美哉，妈妈再也不用担心我没有壁纸换了(手动滑稽)<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_8.png" alt></p>
<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/SkecisAI/python-project/blob/master/get_wallpapers.py" target="_blank" rel="noopener">点击此处访问</a></p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>用python实现线性链表</title>
    <url>/2019/11/01/python%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="线性链表概览"><a href="#线性链表概览" class="headerlink" title="线性链表概览"></a>线性链表概览</h2><h3 id="单节点链表"><a href="#单节点链表" class="headerlink" title="单节点链表"></a>单节点链表</h3><p>头指针和尾指针为同一节点，<strong>尾指针中的指针域为空(None)</strong><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%93%BE%E8%A1%A8/1_1.png" alt></p><h3 id="一般链表"><a href="#一般链表" class="headerlink" title="一般链表"></a>一般链表</h3><p><strong>尾指针中的指针域为空(None)</strong><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%93%BE%E8%A1%A8/1_2.png" alt></p><a id="more"></a>

<h2 id="链表基本数据结构"><a href="#链表基本数据结构" class="headerlink" title="链表基本数据结构"></a>链表基本数据结构</h2><h3 id="链表基本单元：节点-Node"><a href="#链表基本单元：节点-Node" class="headerlink" title="链表基本单元：节点(Node)"></a>链表基本单元：节点(Node)</h3><p>创建<code>Node</code>类</p>
<ul>
<li>值域</li>
<li>指针域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    the basic element of a linked list</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, val, pnext):</span><br><span class="line">        self.value = val</span><br><span class="line">        self.pnext = pnext</span><br></pre></td></tr></table></figure>
<h3 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h3><p>创建<code>LinkedList</code>类</p>
<ul>
<li>head: 头指针</li>
<li>tail: 尾指针</li>
<li>length: 链表长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LinkedList:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    a linked list object</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.head = None</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        self.length = 0</span><br></pre></td></tr></table></figure>
<h2 id="链表操作函数"><a href="#链表操作函数" class="headerlink" title="链表操作函数"></a>链表操作函数</h2><p><code>self</code>参数为对象本身，类似于C++中的<code>this</code>指针</p>
<h3 id="向链表中插入节点"><a href="#向链表中插入节点" class="headerlink" title="向链表中插入节点"></a>向链表中插入节点</h3><p>创建<code>insert_value</code>函数</p>
<ul>
<li>val: 节点值域</li>
<li>loc: 节点位置，默认为None</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def insert_value(self, val, loc=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    insert node to the list</span><br><span class="line">    :param val: insert value</span><br><span class="line">    :param loc: insert with index</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.list_empty():</span><br><span class="line">        # if the list is empty</span><br><span class="line">        self.head = Node(val, None)</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        self.length = 1</span><br><span class="line">    else:</span><br><span class="line">        if (not loc) | (loc == self.length):</span><br><span class="line">            # if insert element without location or at the tail</span><br><span class="line">            new_node = Node(val, None)</span><br><span class="line">            self.tail.pnext = new_node</span><br><span class="line">            self.tail = new_node</span><br><span class="line">            self.length += 1</span><br><span class="line">        else:</span><br><span class="line">            new_node = Node(val, None)</span><br><span class="line">            last_node = self.head</span><br><span class="line">            for index in range(self.length):</span><br><span class="line">                if index == (loc - 1) - 1:</span><br><span class="line">                    break</span><br><span class="line">                else:</span><br><span class="line">                    last_node = last_node.pnext</span><br><span class="line">            next_node = last_node.pnext</span><br><span class="line">            last_node.pnext = new_node</span><br><span class="line">            new_node.pnext = next_node</span><br><span class="line">            self.length += 1</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h3><p>创建<code>delete_value</code>函数</p>
<ul>
<li>loc: 删除的节点位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def delete_value(self, loc=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    delete value from list</span><br><span class="line">    :param loc: the location of list</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not self.list_empty():</span><br><span class="line">        if loc:</span><br><span class="line">            last_node = self.head</span><br><span class="line">            for index in range(self.length):</span><br><span class="line">                if index == (loc - 1) - 1:</span><br><span class="line">                    break</span><br><span class="line">                else:</span><br><span class="line">                    last_node = last_node.pnext</span><br><span class="line">            next_node = last_node.pnext.pnext</span><br><span class="line">            last_node.pnext = next_node</span><br><span class="line">        else:</span><br><span class="line">            now_node = self.head</span><br><span class="line">            while now_node:</span><br><span class="line">                if now_node.pnext.pnext is None:</span><br><span class="line">                    now_node.pnext = None</span><br><span class="line">                    break</span><br><span class="line">                else:</span><br><span class="line">                    now_node = now_node.pnext</span><br><span class="line">        self.length -= 1</span><br></pre></td></tr></table></figure>
<h3 id="判断链表是否为空"><a href="#判断链表是否为空" class="headerlink" title="判断链表是否为空"></a>判断链表是否为空</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def list_empty(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if the list is empty</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.head is None:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h3 id="打印链表内容"><a href="#打印链表内容" class="headerlink" title="打印链表内容"></a>打印链表内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def list_traverse(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    visit all elements of the list</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not self.list_empty():</span><br><span class="line">        now_node = self.head</span><br><span class="line">        print(&apos;-&apos;*15)</span><br><span class="line">        while now_node:</span><br><span class="line">            print(&quot;value: &quot;, now_node.value)</span><br><span class="line">            now_node = now_node.pnext</span><br></pre></td></tr></table></figure>
<h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>创建程序入口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    my_linkedlist = LinkedList()</span><br><span class="line">    for i in range(5):</span><br><span class="line">        my_linkedlist.insert_value(i)</span><br><span class="line">    my_linkedlist.list_traverse()</span><br><span class="line">    my_linkedlist.insert_value([&apos;this&apos;, &apos;is&apos;, &apos;a&apos;, &apos;list&apos;], 3)</span><br><span class="line">    my_linkedlist.list_traverse()</span><br><span class="line">    my_linkedlist.delete_value(2)</span><br><span class="line">    my_linkedlist.list_traverse()</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------</span><br><span class="line">value:  0</span><br><span class="line">value:  1</span><br><span class="line">value:  2</span><br><span class="line">value:  3</span><br><span class="line">value:  4</span><br><span class="line">---------------</span><br><span class="line">value:  0</span><br><span class="line">value:  1</span><br><span class="line">value:  [&apos;this&apos;, &apos;is&apos;, &apos;a&apos;, &apos;list&apos;]</span><br><span class="line">value:  2</span><br><span class="line">value:  3</span><br><span class="line">value:  4</span><br><span class="line">---------------</span><br><span class="line">value:  0</span><br><span class="line">value:  [&apos;this&apos;, &apos;is&apos;, &apos;a&apos;, &apos;list&apos;]</span><br><span class="line">value:  2</span><br><span class="line">value:  3</span><br><span class="line">value:  4</span><br></pre></td></tr></table></figure></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/SkecisAI/python-DS/blob/master/linked_list.py" target="_blank" rel="noopener">点击此处访问</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>CFPS数据分析案例</title>
    <url>/2019/10/24/CFPS%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="文献引用"><a href="#文献引用" class="headerlink" title="文献引用"></a>文献引用</h2><p><a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFDLAST2018&amp;filename=ZGQL201712007&amp;uid=WEEvREcwSlJHSldTTEYzU3EydDVHeHMyVC9Rc1FKVFNDOFJmRVM4alNqdz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MDM1NzVUcldNMUZyQ1VSTE9lWitSckZDbm5WTC9CUHlyYVlyRzRIOWJOclk5Rlk0UjhlWDFMdXhZUzdEaDFUM3E=" target="_blank" rel="noopener"><strong>刘保中.我国城乡家庭教育投入状况的比较研究——基于CFPS(2014)数据的实证分析[J].中国青年研究,2017(12):45-52.</strong></a></p><a id="more"></a>
<h2 id="文献简要"><a href="#文献简要" class="headerlink" title="文献简要"></a>文献简要</h2><p>使用<strong>CFPS2014</strong>年的数据，在<strong>教育期望、教育支出</strong>和<strong>教育参与</strong>三个维度上对当前我国城乡家庭教育投入状况进行了比较分析，详细摘要内容如下:<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_1.png" alt></p>
<h2 id="数据处理-Python"><a href="#数据处理-Python" class="headerlink" title="数据处理(Python)"></a>数据处理(Python)</h2><h3 id="数据概要"><a href="#数据概要" class="headerlink" title="数据概要"></a>数据概要</h3><p>该文献使用的是cfps2014年的数据，且着重使用的是<strong>儿童数据</strong>，文献中的数据部分摘要如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_2.png" alt></p>
<h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>导入必要的包<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import statsmodels.api as sm</span><br><span class="line">from pandas.io.stata import StataReader</span><br></pre></td></tr></table></figure></p>
<h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><p>导入了儿童数据和家庭数据(均为stata文件)，使用StataReader函数读入该类型文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_stata = StataReader(&apos;cfps2014child.dta&apos;, convert_categoricals=False)</span><br><span class="line">famecon_stata = StataReader(&apos;cfps2014famecon.dta&apos;, convert_categoricals=False)</span><br></pre></td></tr></table></figure></p>
<p>上述方式得到的是stata数据，接着将其转化为Pandas中的DataFrame格式，使用read函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df = child_stata.read()</span><br><span class="line">fam_df = famecon_stata.read()</span><br></pre></td></tr></table></figure></p>
<p>数据概览<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(child_df.head())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">           pid  proxyrpt  ...  cfps2014eduy_im  releaseversion</span><br><span class="line">0  100453401.0       1.0  ...              0.0             2.0</span><br><span class="line">1  103924504.0       1.0  ...              0.0             2.0</span><br><span class="line">2  106561502.0       1.0  ...              0.0             2.0</span><br><span class="line">3  107624502.0       1.0  ...              0.0             2.0</span><br><span class="line">4  110011103.0       1.0  ...              8.0             2.0</span><br></pre></td></tr></table></figure></p>
<h4 id="变量引入及预处理"><a href="#变量引入及预处理" class="headerlink" title="变量引入及预处理"></a>变量引入及预处理</h4><p>使用的变量及处理方式：父母对孩子的教育期望（分为高等教育期望和非高等教育期望，以及等价转化为教育年限）、家庭全年教育支出、家庭教育课外补习支出、家庭教育参与（共六个变量，程度从低到高划为1-5分）。控制变量：孩子户口（0-农业户口，1-非农业户口）、孩子性别（0-女，1-男），孩子年龄、孩子目前上学阶段（小学及以上）、家庭年收入（取对数）。文献中使用的变量详情（部分划线的变量未引入）：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_3.png" alt><br>特征变量详情列表如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_col = [&apos;fid14&apos;,  # 14年家庭编码</span><br><span class="line">             &apos;wd2&apos;,  # 家庭教育期望</span><br><span class="line">             &apos;wd503m&apos;, &apos;wd5ckp&apos;, &apos;wd5total_m&apos;, &apos;wd5total&apos;,  # 家庭教育支出： 课外辅导费用，是否确认教育支出，新教育支出，旧教育支出</span><br><span class="line">             &apos;wf601m&apos;, &apos;wf602m&apos;, &apos;wf603m&apos;, &apos;wf604m&apos;, &apos;wf605m&apos;, &apos;wf606m&apos;,  # 家庭教育参与： 频率从低到高（赋值1-5分）</span><br><span class="line">             &apos;wa4&apos;, &apos;cfps2014_age&apos;, &apos;cfps_gender&apos;,  # 控制变量： 户口(1:农, 3:非农)，年龄，性别</span><br><span class="line">             &apos;wf301m&apos;]  # 上哪级学校</span><br><span class="line">family_col = [&apos;fid14&apos;,</span><br><span class="line">              &apos;finc&apos;]  # 家庭年收入</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>使用家庭收入变量连接两表<br>为了在儿童数据中引入家庭数据的收入变量，需根据家庭编码链接两个表，使用join函数，键值设为家庭编码<code>fid14</code>。<strong>特别要注意的是，因为不是每一个儿童在家庭表中的都有年收入这个数据，故连接后无年收入数据的儿童该值将为空，此时抛弃空值。并抛弃不符合要求的数据（-1）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取家庭年收入变量</span><br><span class="line">child_df = child_df.join(fam_df.set_index(&apos;fid14&apos;), on=&apos;fid14&apos;)  # 根据家庭编码链接两个表</span><br><span class="line">child_df = child_df.dropna()</span><br><span class="line">child_df.drop(child_df[child_df[&apos;finc&apos;] &lt; 0].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理家庭收入变量<br>进行取对数处理，自定义函数<code>cal_finc</code>进行映射。<br>自定义函数<code>cal_finc</code>如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def cal_finc(finc):</span><br><span class="line">    # 家庭年收入取对数</span><br><span class="line">    if finc == 0:</span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        return np.log(finc)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>将函数映射到数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df[&apos;finc&apos;] = child_df[&apos;finc&apos;].map(cal_finc)      # 处理家庭年收入</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>处理户口变量<br>将原来的数据中农业户口和非农业户口映射为0和1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">city_code = &#123;1: 0, 3: 1&#125;  # 户口重新编码</span><br><span class="line">child_df[&apos;wa4&apos;] = child_df[&apos;wa4&apos;].map(city_code)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删去不符合条件的数据<br>删去既不是农业户口或非农业户口的，再删去上学阶段不符合要求的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop_cond = (child_df[&apos;wa4&apos;] &lt; 1) | (child_df[&apos;wa4&apos;] &gt; 3)  # 删去户口不符合要求的</span><br><span class="line">child_df.drop(child_df[drop_cond].index, inplace=True)</span><br><span class="line">drop_cond1 = (child_df[&apos;wf301m&apos;] &lt;= 2)  # 删去上学阶段不符合要求的</span><br><span class="line">child_df.drop(child_df[drop_cond1].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="处理教育期望"><a href="#处理教育期望" class="headerlink" title="处理教育期望"></a>处理教育期望</h3><ol>
<li><p>首先删去不符合要求的教育期望样本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop_cond2 = (child_df[&apos;wd2&apos;] &lt; 0)</span><br><span class="line">child_df.drop(child_df[drop_cond2].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>教育期望的分布以及样本量<br>打印出教育期望的分布及样本数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(child_df[&apos;wd2&apos;].value_counts(), &apos;count: &apos;, child_df[&apos;wd2&apos;].count())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6.0    2394</span><br><span class="line">4.0     546</span><br><span class="line">8.0     296</span><br><span class="line">5.0     280</span><br><span class="line">7.0     145</span><br><span class="line">3.0      88</span><br><span class="line">2.0      18</span><br><span class="line">9.0       1</span><br><span class="line">Name: wd2, dtype: int64 count:  3768</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>将教育期望映射为两类：1-高等教育期望，0-非高等教育期望</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df[&apos;high_edu&apos;] = child_df.apply(lambda row: 1 if row[&apos;wd2&apos;] &gt;= 5 else 0, axis=1)  # 是否为高等教育期望</span><br></pre></td></tr></table></figure>
</li>
<li><p>将教育期望映射为教育年限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edu_code = &#123;9: 0, 8: 23, 7: 19, 6: 16, 5: 15, 4: 12, 3: 9, 2: 6&#125;  # 教育期望重新编码</span><br><span class="line">child_df[&apos;wd2_years&apos;] = child_df[&apos;wd2&apos;].map(edu_code)</span><br></pre></td></tr></table></figure>
</li>
<li><p>各个教育期望年限和高等教育期望的样本量、均值和百分比</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">village_df = child_df[child_df[&apos;wa4&apos;] == 0]  # 农业户口</span><br><span class="line">city_df = child_df[child_df[&apos;wa4&apos;] == 1]  # 非农业户口</span><br><span class="line">expect_total_mean = child_df[&apos;wd2_years&apos;].mean()</span><br><span class="line">village_expect_mean = village_df[&apos;wd2_years&apos;].mean()</span><br><span class="line">print(&apos;total   city   village&apos;)</span><br><span class="line">print(&apos;count: &apos;, child_df.shape[0], city_df.shape[0], village_df.shape[0])</span><br><span class="line">print(&apos;years_mean: &apos;, expect_total_mean, city_expect_mean, village_expect_mean)</span><br><span class="line">print(&apos;high_edu_percent: &apos;,</span><br><span class="line">      child_df[&apos;high_edu&apos;].value_counts(normalize=True).loc[1]*100,</span><br><span class="line">      city_df[&apos;high_edu&apos;].value_counts(normalize=True).loc[1]*100,</span><br><span class="line">      village_df[&apos;high_edu&apos;].value_counts(normalize=True).loc[1]*100)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total   city   village</span><br><span class="line">count:  3768 808 2960</span><br><span class="line">years_mean:  15.795912951167729 16.521039603960396 15.597972972972974</span><br><span class="line">high_edu_percent:  82.6963906581741 93.6881188118812 79.69594594594595</span><br></pre></td></tr></table></figure></p>
<p>原文中教育期望的数据分布如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_4.png" alt></p>
<h3 id="处理教育支出"><a href="#处理教育支出" class="headerlink" title="处理教育支出"></a>处理教育支出</h3><p>课外辅导数据较为正常，不需要处理</p>
<ol>
<li><p>获取最终的全年教育支出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df[&apos;edu_expense&apos;] = child_df.apply(lambda row: row[&apos;wd5total_m&apos;] if (row[&apos;wd5ckp&apos;] == 1) | (row[&apos;wd5ckp&apos;] == 3) else row[&apos;wd5total&apos;], axis=1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删去不符合条件的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df.drop(child_df[child_df[&apos;edu_expense&apos;] &lt; 0].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>各个全年教育指出和课外辅导的样本量、均值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 教育支出: 课外辅导</span><br><span class="line">coach_total_mean = child_df[&apos;wd503m&apos;].mean()</span><br><span class="line">village_coach_mean = village_df[&apos;wd503m&apos;].mean()</span><br><span class="line">city_coach_mean = city_df[&apos;wd503m&apos;].mean()</span><br><span class="line"># 教育支出： 总支出</span><br><span class="line">expense_total_mean = child_df[&apos;edu_expense&apos;].mean()</span><br><span class="line">village_expense_mean = village_df[&apos;edu_expense&apos;].mean()</span><br><span class="line">city_expense_mean = city_df[&apos;edu_expense&apos;].mean()</span><br><span class="line">child_df.to_csv(&apos;2014child.csv&apos;, index=False)</span><br><span class="line">print(&apos;total   city   village&apos;)</span><br><span class="line">print(&apos;count: &apos;, child_df.shape[0], city_df.shape[0], village_df.shape[0])</span><br><span class="line">print(&apos;expense_mean: &apos;, expense_total_mean, city_expense_mean, village_expense_mean)</span><br><span class="line">print(&apos;coach_mean: &apos;, coach_total_mean, city_coach_mean, village_coach_mean)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total   city   village</span><br><span class="line">count:  3774 808 2966</span><br><span class="line">expense_mean:  3179.1073131955486 5691.209158415842 2494.7585974376266</span><br><span class="line">coach_mean:  787.992315845257 2657.6992574257424 278.64531355360754</span><br></pre></td></tr></table></figure></p>
<p>原文中教育支出的数据分布如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_5.png" alt></p>
<h3 id="处理教育参与"><a href="#处理教育参与" class="headerlink" title="处理教育参与"></a>处理教育参与</h3><p>教育参与相关变量列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li = [&apos;wf601m&apos;, &apos;wf602m&apos;, &apos;wf603m&apos;, &apos;wf604m&apos;, &apos;wf605m&apos;, &apos;wf606m&apos;]</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>删去不符合条件的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nan_cond = False</span><br><span class="line">for col in child_df.columns:</span><br><span class="line">    if col in li:</span><br><span class="line">        nan_cond = nan_cond | (child_df[col] == -8) | (child_df[col] == -1)</span><br><span class="line">child_df.drop(child_df[nan_cond].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据关心程度从大到小编码（5-1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">care_code = &#123;1: 5, 2: 4, 3: 3, 4: 2, 5: 1&#125;  # 教育关心程度重新编码</span><br><span class="line">for col in child_df.columns:</span><br><span class="line">    if col in li:</span><br><span class="line">        child_df[col] = child_df[col].map(care_code)</span><br></pre></td></tr></table></figure>
</li>
<li><p>关怀程度在2次以上的各个比例及样本量<br>首先将频次变量映射为0-1变量，满足条件的为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 频次在两次以上，即&gt;=4</span><br><span class="line">for col in child_df.columns:</span><br><span class="line">    if col in li:</span><br><span class="line">        child_df[col] = child_df[col].map(lambda val: 1 if val &gt;= 4 else 0)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>进行统计<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&apos;total   city   village&apos;)</span><br><span class="line">print(&apos;count: &apos;, child_df.shape[0], city_df.shape[0], village_df.shape[0])</span><br><span class="line">for col in child_df.columns:</span><br><span class="line">    if col in li:</span><br><span class="line">        print(child_df[col].value_counts(normalize=True).loc[1]*100,</span><br><span class="line">              city_df[col].value_counts(normalize=True).loc[1]*100,</span><br><span class="line">              village_df[col].value_counts(normalize=True).loc[1]*100)</span><br></pre></td></tr></table></figure></p>
<p>输出(顺序与原文一致)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total   city   village</span><br><span class="line">count:  3746 802 2944</span><br><span class="line">72.61078483715964 79.30174563591022 70.78804347826086</span><br><span class="line">54.00427122263748 63.71571072319202 51.358695652173914</span><br><span class="line">87.26641751201282 88.5286783042394 86.9225543478261</span><br><span class="line">56.620395088093964 66.20947630922693 54.00815217391305</span><br><span class="line">65.02936465563268 66.08478802992519 64.74184782608695</span><br><span class="line">38.57447944474106 40.64837905236908 38.00951086956522</span><br></pre></td></tr></table></figure></p>
<p>原文中教育参与的变量分布如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_6.png" alt></p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4>]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>CFPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas数据结构-Series(二)</title>
    <url>/2019/10/16/Pandas-Series2/</url>
    <content><![CDATA[<h2 id="导入必要的包"><a href="#导入必要的包" class="headerlink" title="导入必要的包"></a>导入必要的包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure><h2 id="通过索引对齐值的特性"><a href="#通过索引对齐值的特性" class="headerlink" title="通过索引对齐值的特性"></a>通过索引对齐值的特性</h2><a id="more"></a>
<h3 id="用”-”操作实现"><a href="#用”-”操作实现" class="headerlink" title="用”+”操作实现"></a>用”+”操作实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s6 = pd.Series([1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])</span><br><span class="line">s7 = pd.Series([4, 3, 2, 1], index=[&apos;d&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;])</span><br><span class="line">print(s6 + s7)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    2</span><br><span class="line">b    4</span><br><span class="line">c    6</span><br><span class="line">d    8</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<p>Serise的相加是基于索引匹配的<br><strong>如果存在无法匹配的标签，运算结果将为NaN</strong></p>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="将所有值乘以一个数"><a href="#将所有值乘以一个数" class="headerlink" title="将所有值乘以一个数"></a>将所有值乘以一个数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s6 * 2)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    2</span><br><span class="line">b    4</span><br><span class="line">c    6</span><br><span class="line">d    8</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="两个Series相乘"><a href="#两个Series相乘" class="headerlink" title="两个Series相乘"></a>两个Series相乘</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t = pd.Series(2, s6.index)</span><br><span class="line">print(s6 * t)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    2</span><br><span class="line">b    4</span><br><span class="line">c    6</span><br><span class="line">d    8</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h2 id="存在NaN值的情况"><a href="#存在NaN值的情况" class="headerlink" title="存在NaN值的情况"></a>存在NaN值的情况</h2><h3 id="忽略NaN值"><a href="#忽略NaN值" class="headerlink" title="忽略NaN值"></a>忽略NaN值</h3><p>使用了mean()函数求平均<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.array([1, 2, 3, 4, np.nan]))</span><br><span class="line">print(s.mean())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.5</span><br></pre></td></tr></table></figure></p>
<p>不忽略NaN值<br>使用mean()函数的skipna参数，类型为布尔型(boolean)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.mean(skipna=False))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nan</span><br></pre></td></tr></table></figure></p>
<h2 id="布尔选择"><a href="#布尔选择" class="headerlink" title="布尔选择"></a>布尔选择</h2><p>用到的Series<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.arange(0, 10))</span><br></pre></td></tr></table></figure></p>
<p>s:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0    0</span><br><span class="line">1    1</span><br><span class="line">2    2</span><br><span class="line">3    3</span><br><span class="line">4    4</span><br><span class="line">5    5</span><br><span class="line">6    6</span><br><span class="line">7    7</span><br><span class="line">8    8</span><br><span class="line">9    9</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<h3 id="使用布尔运算符"><a href="#使用布尔运算符" class="headerlink" title="使用布尔运算符"></a>使用布尔运算符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s &gt; 5)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0    False</span><br><span class="line">1    False</span><br><span class="line">2    False</span><br><span class="line">3    False</span><br><span class="line">4    False</span><br><span class="line">5    False</span><br><span class="line">6     True</span><br><span class="line">7     True</span><br><span class="line">8     True</span><br><span class="line">9     True</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure></p>
<p><strong>得到的结果类型仍为Series</strong></p>
<h3 id="使用逻辑型数值的Series作为索引"><a href="#使用逻辑型数值的Series作为索引" class="headerlink" title="使用逻辑型数值的Series作为索引"></a>使用逻辑型数值的Series作为索引</h3><p>利用了对方括号运算符[ ]的重载，最终只返回对应索引的值为true的对应值的Series片段<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bigger_loc = s &gt; 5</span><br><span class="line">print(s[bigger_loc])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6    6</span><br><span class="line">7    7</span><br><span class="line">8    8</span><br><span class="line">9    9</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<p>更简介的语法：<code>s[s &gt; 5]</code></p>
<h3 id="使用复合的布尔运算表达式"><a href="#使用复合的布尔运算表达式" class="headerlink" title="使用复合的布尔运算表达式"></a>使用复合的布尔运算表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[(s &gt; 5) &amp; (s &lt; 8)])</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6    6</span><br><span class="line">7    7</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<p><strong>特别注意这里单一的运算周围用的括号()是必须的，否则会报类似下面的错误：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()</span><br></pre></td></tr></table></figure></p>
<h3 id="函数：all-和any"><a href="#函数：all-和any" class="headerlink" title="函数：all()和any()"></a>函数：all()和any()</h3><p>all()函数：单一逻辑间的<code>且</code>运算<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print((s &gt;= 0).all())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p>any()函数：单一逻辑间的<code>或</code>运算<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print((s &lt; 2).any())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h2 id="重定义Series的索引"><a href="#重定义Series的索引" class="headerlink" title="重定义Series的索引"></a>重定义Series的索引</h2><h3 id="使用index属性"><a href="#使用index属性" class="headerlink" title="使用index属性"></a>使用index属性</h3><p>将一个索引列表(list)传给index属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.random.randn(5))</span><br><span class="line">s.index = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a   -0.623722</span><br><span class="line">b   -0.906193</span><br><span class="line">c   -0.424337</span><br><span class="line">d   -0.486135</span><br><span class="line">e   -0.075073</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="修整连接Series后的索引"><a href="#修整连接Series后的索引" class="headerlink" title="修整连接Series后的索引"></a>修整连接Series后的索引</h3><p>连接后的索引<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series(np.random.randn(3))</span><br><span class="line">s2 = pd.Series(np.random.randn(3))</span><br><span class="line">combined = pd.concat([s1, s2])</span><br><span class="line">print(combined)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0    0.565139</span><br><span class="line">1    0.033748</span><br><span class="line">2   -1.315617</span><br><span class="line">0    1.064170</span><br><span class="line">1   -1.524376</span><br><span class="line">2    0.391475</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<p>修整索引<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">combined.index = np.arange(0, len(combined))</span><br><span class="line">print(combined)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   -0.169124</span><br><span class="line">1   -1.167542</span><br><span class="line">2   -0.431747</span><br><span class="line">3    0.879552</span><br><span class="line">4   -1.460969</span><br><span class="line">5    0.119569</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="使用reindex-函数"><a href="#使用reindex-函数" class="headerlink" title="使用reindex()函数"></a>使用reindex()函数</h3><p>参数为索引的列表(list)，<strong>特别要注意的是reindex()函数将会返回一个新的Series实例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series(np.random.randn(4), [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])</span><br><span class="line">s2 = s1.reindex([&apos;a&apos;, &apos;c&apos;, &apos;g&apos;])</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a   -0.644808</span><br><span class="line">c    1.309109</span><br><span class="line">g         NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<p>当索引不存在时，会被填充NaN，若要修改填充值，可使用fill_value参数<br>或者使用填充方法参数<code>method</code>：有向前填充(‘ffill’)和向后填充(‘bfill’)两种选择<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s3 = pd.Series([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;], index=[0, 3, 5])</span><br><span class="line">s3 = s3.reindex(np.arange(0, 7), method=&apos;ffill&apos;)</span><br><span class="line">print(s3)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0      red</span><br><span class="line">1      red</span><br><span class="line">2      red</span><br><span class="line">3    green</span><br><span class="line">4    green</span><br><span class="line">5     blue</span><br><span class="line">6     blue</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure></p>
<h2 id="在本体-in-place-上操作"><a href="#在本体-in-place-上操作" class="headerlink" title="在本体(in-place)上操作"></a>在本体(in-place)上操作</h2><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>直接通过索引赋值<br><code>Series[index] = val</code></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用del函数<br><code>del(Series[index])</code></p>
<h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.arange(100, 110), index=np.arange(10, 20))</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>s:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10    100</span><br><span class="line">11    101</span><br><span class="line">12    102</span><br><span class="line">13    103</span><br><span class="line">14    104</span><br><span class="line">15    105</span><br><span class="line">16    106</span><br><span class="line">17    107</span><br><span class="line">18    108</span><br><span class="line">19    109</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<h3 id="形式一：Series-start-end-interval"><a href="#形式一：Series-start-end-interval" class="headerlink" title="形式一：Series[start: end: interval]"></a>形式一：Series[start: end: interval]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[0:6:2])</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10    100</span><br><span class="line">12    102</span><br><span class="line">14    104</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<p>等价于<code>s.iloc[[0, 2, 4]]</code></p>
<h3 id="形式二：Series-start-end"><a href="#形式二：Series-start-end" class="headerlink" title="形式二：Series[start: end]"></a>形式二：Series[start: end]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[:5])</span><br></pre></td></tr></table></figure>
<p>等价于<code>s.head(5)</code></p>
<h3 id="巧妙利用切片"><a href="#巧妙利用切片" class="headerlink" title="巧妙利用切片"></a>巧妙利用切片</h3><p>倒序Series<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[::-1])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19    109</span><br><span class="line">18    108</span><br><span class="line">17    107</span><br><span class="line">16    106</span><br><span class="line">15    105</span><br><span class="line">14    104</span><br><span class="line">13    103</span><br><span class="line">12    102</span><br><span class="line">11    101</span><br><span class="line">10    100</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<p>从开始位置4，倒叙<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[4::-2])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14    104</span><br><span class="line">12    102</span><br><span class="line">10    100</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas数据结构-Series(一)</title>
    <url>/2019/10/15/Pandas-Series/</url>
    <content><![CDATA[<h2 id="导入必要的包"><a href="#导入必要的包" class="headerlink" title="导入必要的包"></a>导入必要的包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure><h2 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h2><a id="more"></a>
<h3 id="创建只含一个元素的Series"><a href="#创建只含一个元素的Series" class="headerlink" title="创建只含一个元素的Series"></a>创建只含一个元素的Series</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series(16)</span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0    16</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="通过索引获取值"><a href="#通过索引获取值" class="headerlink" title="通过索引获取值"></a>通过索引获取值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val = s1[0]</span><br><span class="line">print(val)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure></p>
<h3 id="通过列表创建Series"><a href="#通过列表创建Series" class="headerlink" title="通过列表创建Series"></a>通过列表创建Series</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s2 = pd.Series([7, 8, 9, 10, 11])</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0     7</span><br><span class="line">1     8</span><br><span class="line">2     9</span><br><span class="line">3    10</span><br><span class="line">4    11</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="获取Series的所有值或索引"><a href="#获取Series的所有值或索引" class="headerlink" title="获取Series的所有值或索引"></a>获取Series的所有值或索引</h3><p>使用Series实例的两个属性：values和index<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s2.values) # 获取值</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ 7  8  9 10 11]</span><br></pre></td></tr></table></figure></p>
<p>使用index属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s2.index) # 获取索引</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RangeIndex(start=0, stop=5, step=1)</span><br></pre></td></tr></table></figure></p>
<h3 id="指定值和索引创建Series"><a href="#指定值和索引创建Series" class="headerlink" title="指定值和索引创建Series"></a>指定值和索引创建Series</h3><p>使用了参数index，参数类型为列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s3 = pd.Series([1, 2, 3], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">print(s3)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a    1</span><br><span class="line">b    2</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="使用已存在的Series索引创建Series"><a href="#使用已存在的Series索引创建Series" class="headerlink" title="使用已存在的Series索引创建Series"></a>使用已存在的Series索引创建Series</h3><p>将已存在Series的索引(使用index属性)赋值给参数index<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s4 = pd.Series(2, index=s3.index)</span><br><span class="line">print(s4)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a    2</span><br><span class="line">b    2</span><br><span class="line">c    2</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<p>值的数量不足时，将会依每个索引把值复制一遍</p>
<h3 id="使用5个正态随机数生成Series"><a href="#使用5个正态随机数生成Series" class="headerlink" title="使用5个正态随机数生成Series"></a>使用5个正态随机数生成Series</h3><p>这里用了numpy的1-darray类型来创建<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">s5 = pd.Series(dict1)</span><br><span class="line">print(s5)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a    1</span><br><span class="line">b    2</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h2 id="关于Series值的属性、函数和方法"><a href="#关于Series值的属性、函数和方法" class="headerlink" title="关于Series值的属性、函数和方法"></a>关于Series值的属性、函数和方法</h2><p>首先创建一个带有NaN值的Series<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series([0, 1, 1, 2, 3, 4, 5, 6, 7, np.nan])</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0    0.0</span><br><span class="line">1    1.0</span><br><span class="line">2    1.0</span><br><span class="line">3    2.0</span><br><span class="line">4    3.0</span><br><span class="line">5    4.0</span><br><span class="line">6    5.0</span><br><span class="line">7    6.0</span><br><span class="line">8    7.0</span><br><span class="line">9    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="Series的长度"><a href="#Series的长度" class="headerlink" title="Series的长度"></a>Series的长度</h3><p>使用len()函数或size属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(len(s))</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.size)</span><br></pre></td></tr></table></figure></p>
<p>都将输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure></p>
<h3 id="Series的尺寸"><a href="#Series的尺寸" class="headerlink" title="Series的尺寸"></a>Series的尺寸</h3><p>使用shape属性，会得到一个元组<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.shape)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(10,)</span><br></pre></td></tr></table></figure></p>
<h3 id="统计Series中非NaN的值的数量"><a href="#统计Series中非NaN的值的数量" class="headerlink" title="统计Series中非NaN的值的数量"></a>统计Series中非NaN的值的数量</h3><p>使用count()方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.count())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></p>
<h3 id="获取Series中的所有的唯一值"><a href="#获取Series中的所有的唯一值" class="headerlink" title="获取Series中的所有的唯一值"></a>获取Series中的所有的唯一值</h3><p>使用unique()方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.unique())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ 0.  1.  2.  3.  4.  5.  6.  7. nan]</span><br></pre></td></tr></table></figure></p>
<h2 id="预览数据的一部分"><a href="#预览数据的一部分" class="headerlink" title="预览数据的一部分"></a>预览数据的一部分</h2><h3 id="预览数据的开头部分"><a href="#预览数据的开头部分" class="headerlink" title="预览数据的开头部分"></a>预览数据的开头部分</h3><p>使用head()函数，可选参数<code>n</code>：需要预览的行数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.head(3))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0    0.0</span><br><span class="line">1    1.0</span><br><span class="line">2    1.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="预览数据的结尾部分"><a href="#预览数据的结尾部分" class="headerlink" title="预览数据的结尾部分"></a>预览数据的结尾部分</h3><p>使用tail()函数，可选参数<code>n</code>：需要预览的行数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.tail(4))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6    5.0</span><br><span class="line">7    6.0</span><br><span class="line">8    7.0</span><br><span class="line">9    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="预览数据的指定部分"><a href="#预览数据的指定部分" class="headerlink" title="预览数据的指定部分"></a>预览数据的指定部分</h3><p>使用take()函数，参数：索引组成的列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.take([2, 3, 6]))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2    1.0</span><br><span class="line">3    2.0</span><br><span class="line">6    5.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h2 id="在Series中查找值"><a href="#在Series中查找值" class="headerlink" title="在Series中查找值"></a>在Series中查找值</h2><p>引用<code>s3</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a    1</span><br><span class="line">b    2</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="通过索引名查找"><a href="#通过索引名查找" class="headerlink" title="通过索引名查找"></a>通过索引名查找</h3><p>索引名可为列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s3[&apos;a&apos;])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h3 id="通过位置-从0开始-查找"><a href="#通过位置-从0开始-查找" class="headerlink" title="通过位置(从0开始)查找"></a>通过位置(从0开始)查找</h3><p>位置可为列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s3[1])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3 id="强行只通过索引名查找"><a href="#强行只通过索引名查找" class="headerlink" title="强行只通过索引名查找"></a>强行只通过索引名查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s5 = pd.Series([1, 2, 3], index=[10, 11, 12])</span><br></pre></td></tr></table></figure>
<p><code>s5</code>结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10    1</span><br><span class="line">11    2</span><br><span class="line">13    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<p>使用loc[]属性，列表类型，可传入列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s5.loc[12])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>如果索引名不存在会返回NaN，且不能传入位置</p>
<h3 id="强行只通过位置查找"><a href="#强行只通过位置查找" class="headerlink" title="强行只通过位置查找"></a>强行只通过位置查找</h3><p>使用iloc[]属性，列表类型，可传入列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s5.iloc[1])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>如果位置不存在会报错，且不能传入索引名</p>
<h3 id="位置和索引名兼容查找-不推荐"><a href="#位置和索引名兼容查找-不推荐" class="headerlink" title="位置和索引名兼容查找(不推荐)"></a>位置和索引名兼容查找(不推荐)</h3><p>使用ix[]属性，列表类型，可传入列表(list)。</p>
]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语法</title>
    <url>/2019/10/12/MySQL%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; CREATE DATABASE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; DROP DATABASE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><a id="more"></a>

<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; USE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS &lt;表名&gt; (字段名1 字段1类型定义, [...]);</span><br></pre></td></tr></table></figure>
<p>以下代码创建了一个学生成绩表：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS student_grade</span><br><span class="line">(</span><br><span class="line">    id    INT AUTO_INCREMENT,</span><br><span class="line">    name  CHAR(10),</span><br><span class="line">    sex   CHAR(5),</span><br><span class="line">    age   INT(2),</span><br><span class="line">    grade INT(2),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) CHARSET = utf8;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; DROP TABLE &lt;表名&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="向表中插入记录"><a href="#向表中插入记录" class="headerlink" title="向表中插入记录"></a>向表中插入记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; INSERT INTO &lt;表名&gt; (字段名1, [...]) VALUES (值1, [...]);</span><br></pre></td></tr></table></figure>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SELECT &lt;字段名&gt;, [...] FROM &lt;表名&gt; [WHERE字句] [LIMIT字句];</span><br></pre></td></tr></table></figure>
<ul>
<li>可用<code>*</code>替换字段名表示查询所有字段</li>
<li>WHERE字句包含了查询条件</li>
<li>LIMIT字句包含了需要返回的记录数量</li>
</ul>
<h4 id="WHERE字句"><a href="#WHERE字句" class="headerlink" title="WHERE字句"></a>WHERE字句</h4><p>格式<br><code>WHERE 对象1[关系]对象1的值 [AND|OR] [...]</code><br>例如：查询男生的成绩<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SELECT grade FROM student_grade WHERE sex=<span class="string">'男'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; UPDATE &lt;表名&gt; SET &lt;字段名&gt;=&lt;值&gt;, [...] [WHERE字句];</span><br></pre></td></tr></table></figure>
<h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; DELETE FROM &lt;表名&gt; [WHERE字句];</span><br></pre></td></tr></table></figure>
<h3 id="模糊查询：LIKE子句"><a href="#模糊查询：LIKE子句" class="headerlink" title="模糊查询：LIKE子句"></a>模糊查询：LIKE子句</h3><p>例如查询李姓同学的记录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM student_grade WHERE name LIKE <span class="string">'李'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="修改字段信息：ALTER命令"><a href="#修改字段信息：ALTER命令" class="headerlink" title="修改字段信息：ALTER命令"></a>修改字段信息：ALTER命令</h3><p>删除字段<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;;</span><br></pre></td></tr></table></figure></p>
<p>添加字段：ADD子句<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ALTER TABLE &lt;表名&gt; ADD &lt;字段名&gt;&lt;类型&gt;[AFTER &lt;已有字段名&gt;|FIRST];</span><br></pre></td></tr></table></figure></p>
<p>修改字段类型<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;类型定义&gt;;</span><br></pre></td></tr></table></figure></p>
<p>修改字段名<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ALTER TABLE &lt;表名&gt; CHANGE &lt;需修改字段名&gt; &lt;新字段名&gt; &lt;类型定义&gt;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL安装</title>
    <url>/2019/10/11/mysql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Windows下安装MySQL"><a href="#Windows下安装MySQL" class="headerlink" title="Windows下安装MySQL"></a>Windows下安装MySQL</h2><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL官网下载地址</a></p><h3 id="下载MySQL安装文件"><a href="#下载MySQL安装文件" class="headerlink" title="下载MySQL安装文件"></a>下载MySQL安装文件</h3><p>在下载页面中<code>Select Platform</code>选择<code>Microsoft Windows</code>, 然后在下方的下载选项中选择点击第一个<code>Downloads</code>下载:<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/mysql_install_1_1.png" alt="1.1"><br>跳转到另一个个页面后点击左下角<code>No thanks, just start my download.</code>:<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/mysql_install_1_2.png" alt="1.2"><br>开始下载。下载后得到一个.zip文件。将其解压得到类似<code>mysql-8.0.17-winx64</code>这样的文件夹。<br>将得到的文件夹放入C盘中的DB文件夹中(这里的DB为新建文件夹)得到mysql安装路径为<code>C:\DB\mysql-8.0.17-winx64</code></p><a id="more"></a>

<h3 id="MySQL配置文件"><a href="#MySQL配置文件" class="headerlink" title="MySQL配置文件"></a>MySQL配置文件</h3><ol>
<li>打开文件夹<code>C:\DB\mysql-8.0.17-winx64</code>,新建<code>my.ini</code>配置文件</li>
<li>编辑 my.ini 配置以下基本信息,其中的<code>basedir</code>设置为自己安装文件的路径：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line">port = 3306</span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line">basedir=C:\DB\mysql-8.0.17-winx64</span><br><span class="line"><span class="comment"># 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</span></span><br><span class="line"><span class="comment"># datadir=C:\\web\\sqldata</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=20</span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="启动MySQL"><a href="#启动MySQL" class="headerlink" title="启动MySQL"></a>启动MySQL</h3><p>注：以下命令最好在有管理员权限的cmd中运行<br>切换目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\DB\mysql-8.0.17-winx64\bin</span><br></pre></td></tr></table></figure></p>
<p>初始化数据库<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure></p>
<p>执行完成后，会输出 root 用户的初始默认密码，如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2019-05-10T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated <span class="keyword">for</span> root@localhost: APsCY5wg&amp;hgQ</span><br></pre></td></tr></table></figure></p>
<p><code>APsCY5wg&amp;hgQ</code>即为localhost主机下root用户名的初始密码<br>安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld install</span><br></pre></td></tr></table></figure></p>
<p>启动服务<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure></p>
<h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h 主机名 -u 用户名 -p</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>世界那么大-出去看看</title>
    <url>/2019/10/11/science-internet/</url>
    <content><![CDATA[<p>知识不分边界，在这广袤的土地上寻求知识吧</p><h2 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h2><h3 id="购买一台VPS服务器"><a href="#购买一台VPS服务器" class="headerlink" title="购买一台VPS服务器"></a>购买一台VPS服务器</h3><p><a href="https://bwh88.net/index.php" target="_blank" rel="noopener">BanWaGong</a>挺不错</p><h3 id="远程登录服务器"><a href="#远程登录服务器" class="headerlink" title="远程登录服务器"></a>远程登录服务器</h3><a id="more"></a>

<p>Windows可用<a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">Xshell</a>等远程工具</p>
<h3 id="为服务器部署linux系统，最合适的系统为Centos-6-x86-64-bbr"><a href="#为服务器部署linux系统，最合适的系统为Centos-6-x86-64-bbr" class="headerlink" title="为服务器部署linux系统，最合适的系统为Centos 6 x86_64-bbr"></a>为服务器部署linux系统，最合适的系统为<code>Centos 6 x86_64-bbr</code></h3><h2 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h2><h3 id="安装基本工具"><a href="#安装基本工具" class="headerlink" title="安装基本工具"></a>安装基本工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install wget</span><br></pre></td></tr></table></figure>
<h3 id="安装核心工具SS"><a href="#安装核心工具SS" class="headerlink" title="安装核心工具SS"></a>安装核心工具SS</h3><p>下载工具SS，在服务器终端以root身份执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget — no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="修改执行权限"><a href="#修改执行权限" class="headerlink" title="修改执行权限"></a>修改执行权限</h3><p>执行命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod +x shadowsocks.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="运行安装"><a href="#运行安装" class="headerlink" title="运行安装"></a>运行安装</h3><p>执行命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure></p>
<h3 id="安装过程中"><a href="#安装过程中" class="headerlink" title="安装过程中"></a>安装过程中</h3><p>执行刚刚的命令后，开始安装SS，安装过程中会有修改端口、密码等提示，可修改也可遵从默认，接着会选择加密方式，这里选择<code>aes-256-cfb</code></p>
<h3 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h3><p>完成安装后，会显示你的所有配置信息:端口，密码，加密方式等以供记忆。</p>
<h2 id="三、写在后面"><a href="#三、写在后面" class="headerlink" title="三、写在后面"></a>三、写在后面</h2><p>请合理使用SS工具，学习自己所需要的知识，毕竟工具开发原作者曾被请去喝茶，之后便不再维护了。</p>
<h4 id="爱祖国，爱社会"><a href="#爱祖国，爱社会" class="headerlink" title="爱祖国，爱社会"></a>爱祖国，爱社会</h4>]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>get小技能</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/2019/10/10/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>记录学习的一些Git常用命令</p><h2 id="git本地操作"><a href="#git本地操作" class="headerlink" title="git本地操作"></a>git本地操作</h2><h3 id="生成git仓库"><a href="#生成git仓库" class="headerlink" title="生成git仓库"></a>生成git仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><h3 id="从当前git仓库添加并提交文件"><a href="#从当前git仓库添加并提交文件" class="headerlink" title="从当前git仓库添加并提交文件"></a>从当前git仓库添加并提交文件</h3><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add . | git add &lt;filename&gt;</span><br><span class="line">$ git commit -m <span class="string">"注释"</span></span><br></pre></td></tr></table></figure>
<p>上述第一条命令的作用为添加目录下所有文件到仓库或者添加单个文件到暂存仓库，第二条命令的作用是提交添加的所有文件到当前分支。<br>每一次修改，如果不用git add将其放入仓库，则在使用git commit时则不会对其提交</p>
<h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><ol>
<li><p>查看git仓库的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件的改动信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ol>
<li><p>查看日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>回退上一个版本：HEAD^  回退上上一个版本：HEAD^^（HEAD^n）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看历史命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ol>
<li><p>撤销工作区的修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销暂存区的修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>从版本库中删除并提交<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;filename&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><h3 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure>
<h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">"邮箱"</span></span><br><span class="line">$ git config --global user.name <span class="string">"用户名"</span></span><br></pre></td></tr></table></figure>
<h3 id="提交文件到远程仓库"><a href="#提交文件到远程仓库" class="headerlink" title="提交文件到远程仓库"></a>提交文件到远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin master git@github.com:username/repository.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>第二行命令有可选参数<code>-f</code>意为强制提交</p>
<h3 id="另一方使用同一仓库，在push前需要拉取最新版本"><a href="#另一方使用同一仓库，在push前需要拉取最新版本" class="headerlink" title="另一方使用同一仓库，在push前需要拉取最新版本"></a>另一方使用同一仓库，在push前需要拉取最新版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull --rebase origin master</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>get小技能</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-模型实现</title>
    <url>/2019/09/15/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>基于周志华西瓜书中的数据集和各个机器学习模型的算法原理，采用python编写代码</p>
<h2 id="一-模型清单"><a href="#一-模型清单" class="headerlink" title="一. 模型清单"></a>一. 模型清单</h2><ul>
<li><strong>逻辑回归</strong></li>
<li><strong>线性判别分析</strong></li>
<li><strong>决策树</strong><ol>
<li>划分选择<ol>
<li>基于信息增益</li>
<li>基于基尼指数</li>
</ol>
</li>
<li>剪枝<ol>
<li>预剪枝</li>
<li>后剪枝 <a id="more"></a></li>
</ol>
</li>
</ol>
</li>
<li><strong>神经网络</strong><ol>
<li>标准BP算法</li>
</ol>
</li>
<li><strong>（待续）</strong><h2 id="二-代码清单"><a href="#二-代码清单" class="headerlink" title="二. 代码清单"></a>二. 代码清单</h2>代码中重要的部分都配有蹩脚的英文注释（T.T苦学英语ing），具体使用的数据集内容请参考代码引用和数据集清单。</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/logistic_regression.py" target="_blank" rel="noopener">logistic_regression</a>: 逻辑回归实现。</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/linear_discriminant_analysis.py" target="_blank" rel="noopener">linear_discriminant_analysis</a>: 线性判别分析实现。</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/decision_tree.py" target="_blank" rel="noopener">decision_tree</a>: 决策树实现，集成各个思想，包含划分方式有<code>信息增益</code>、<code>基尼指数</code>，连续值的处理方式有<code>平均值法</code>、<code>二分法</code>，以及剪枝方法有<code>预剪枝</code>、<code>后剪枝</code>。</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/neural_network.py" target="_blank" rel="noopener">neural_network</a>: 神经网络实现，标准BP算法。</li>
<li>（待续）<h2 id="三-数据集清单"><a href="#三-数据集清单" class="headerlink" title="三. 数据集清单"></a>三. 数据集清单</h2>均为csv文件，内容如下</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/watermelon.csv" target="_blank" rel="noopener">西瓜数据集3.0alpha</a></li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/watermelon4.csv" target="_blank" rel="noopener">西瓜数据集2.0</a></li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/watermelon3.csv" target="_blank" rel="noopener">西瓜数据集3.0</a></li>
</ul>
<p><em>才疏学浅，以上资料仅供参考，交流。</em></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
