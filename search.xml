<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>线性回归</title>
    <url>/2020/06/01/linear-reg/</url>
    <content><![CDATA[<h2 id="线性模型的推导-参考自西瓜书"><a href="#线性模型的推导-参考自西瓜书" class="headerlink" title="线性模型的推导(参考自西瓜书)"></a>线性模型的推导(参考自西瓜书)</h2><p>原问题：假设有$m$个样本$D=\left\{(\mathbf{x}_{1},y_{1}),(\mathbf{x}_{2},y_{2}),…,(\mathbf{x}_{m},y_{m}) \right\}$，每个样本$\mathbf{x}_{i}=\left ( x_{1},x_{2},…,x_{d} \right )$有$d$个特征，一个目标值$y_{i}=y$</p><a id="more"></a>
<h3 id="单变量的线性回归"><a href="#单变量的线性回归" class="headerlink" title="单变量的线性回归"></a>单变量的线性回归</h3><p>考虑最简单的只有<strong>一个特征</strong>的样本$(x_{i}, y_{i})$，线性回归试图学习：</p>
<script type="math/tex; mode=display">
f(x_{i})=wx_{i}+b,使得f(x_{i})渐进等于y_{i}</script><p>为了求得$w$和$b$，则需使用均方误差作为性能度量，并使均方误差最小化：</p>
<script type="math/tex; mode=display">
(w, b) = \arg\limits_{(w, b)}\min\sum_{i=1}^{m}\left(wx_{i}+b-y_{i} \right)^{2}</script><p>$<br>令E(w,b)=\sum_{i=1}^{m}\left(wx_{i}+b-y_{i} \right)^{2}<br>$<br>分别对$w$和$b$求偏导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial E(w,b)}{\partial w}&=2\cdot x_{i}\cdot \sum_{i=1}^{m}(wx_{i}+b-y_{i})
\\&=2\sum_{i=1}^{m}(wx_{i}^{2}+bx_{i}-x_{i}y_{i})
\\&=2(\sum_{i=1}^{m}wx_{i}^{2}+\sum_{i=1}^{m}x_{i}(b-y_{i})) \tag{1}
\end{aligned}</script><p>对$b$<br>&lt;!— $$<br>\begin{aligned}<br>\frac{\partial E(w,b)}{\partial b}&amp;=2\cdot \sum_{i=1}^{m}(wx_{i}+b-y_{i})<br>\\&amp;=2(\sum_{i=1}^{m}wx_{i}+\sum_{i=1}^{m}b-\sum_{i=1}^{m}y_{i})<br>\\&amp;=2(\sum_{i=1}^{m}wx_{i}+mb-\sum_{i=1}^{m}y_{i})\tag{2}<br>\end{aligned}</p>
<script type="math/tex; mode=display">-->
从以上$w$和$b$的导函数中可以看出相关变量的系数$\sum_{i=1}^{m}x_{i}^{2}$与$m$d都为**正数**，故对应的导函数都为**增函数**，故当导函数值取0时对应的极值为。令$(1)$式和$(2)$式为值为0，可推导出$w$和$b$的表达式。$先令x的均值\bar{x}=\frac{1}{m}\sum_{i=1}^{m}x_{i}$，先推导$b$的表达式：</script><p>令\frac{\partial E(w,b)}{\partial b}=0 \\<br>\Rightarrow \sum_{i=1}^{m}wx_{i}+mb-\sum_{i=1}^{m}y_{i}=0 \\<br>\Rightarrow b=\frac{1}{m}\sum_{i=1}^{m}y_{i}-\frac{1}{m}\sum_{i=1}^{m}wx_{i} \tag{3}</p>
<script type="math/tex; mode=display">
再推导$w$的表达式：</script><p>令\frac{\partial E(w,b)}{\partial w}=0 \\<br>\Rightarrow \sum_{i}^{m}wx_{i}^{2}+\sum_{i=1}^{m}x_{i}b-\sum_{i=1}^{m}x_{i}y_{i}=0<br>\\ 带入(3)\Rightarrow \sum_{i=1}^{m}wx_{i}^{2}+\sum_{i=1}^{m}x_{i}(\frac{1}{m}\sum_{i=1}^{m}y_{i}-\frac{1}{m}\sum_{i=1}^{m}wx_{i})-\sum_{i=1}^{m}x_{i}y_{i}=0<br>\\ 化简 \Rightarrow \sum_{i=1}^{m}wx_{i}^{2}+\frac{1}{m}\sum_{i=1}^{m}x_{i}\sum_{i=1}^{m}y_{i}-\frac{w}{m}(\sum_{i=1}^{m}x_{i})^{2}-\sum_{i=1}^{m}x_{i}y_{i}=0<br>\\ 化简合并 \Rightarrow w(\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2})+\sum_{i=1}^{m}(\bar{x}-x_{i})y_{i}=0<br>\\ \Rightarrow w = \frac{\sum_{i=1}^{m}y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2}}</p>
<script type="math/tex; mode=display">
求得的两个表达式为：</script><p>w = \frac{\sum_{i=1}^{m}y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2}}, \qquad<br>b=\frac{1}{m}\sum_{i=1}^{m}y_{i}-\frac{1}{m}\sum_{i=1}^{m}wx_{i}</p>
<script type="math/tex; mode=display">

### 多元线性回归

考虑多个特征的样本$\mathbf{x}_{i}=\left ( x_{1},x_{2},...,x_{d} \right )$，多元线性回归试图学习：</script><p>f(x_{i})=w^{T}x_{i}+b,使得f(x_{i})渐进等于y_{i}</p>
<script type="math/tex; mode=display">
为了便于向量的运算，令$\hat{w}=(w;b)=\binom{w}{b}$，把数据集$D$表示为一个$m\times(d+1)大小的矩阵：$</script><p>X=\begin{Bmatrix}<br> &amp;x_{11}  &amp;x_{12}&amp;…&amp;x_{1d} &amp;1\\<br> &amp;x_{21}  &amp;x_{22}&amp;…&amp;x_{2d} &amp;1\\<br> &amp;…  &amp;…  &amp;…  &amp;… &amp;…\\<br> &amp;x_{m1}  &amp;x_{m2}  &amp;…  &amp;x_{md} &amp;1<br>\end{Bmatrix}=\begin{pmatrix}<br>\mathbf{x}_{1}^{T} &amp;1\\<br>\mathbf{x}_{2}^{T} &amp;1\\<br>… &amp;…\\<br>\mathbf{x}_{m}^{T} &amp;1<br>\end{pmatrix}</p>
<script type="math/tex; mode=display">
再把目标值也写成向量的形式：$\mathbf{y}=\begin{pmatrix}
y_{1}\\
y_{2}\\
...\\
y_{m}
\end{pmatrix}$，则类似有：</script><p>\hat{w}=\arg\min(\mathbf{y}-X\hat{w})^{T}(\mathbf{y}-X\hat{w})</p>
<script type="math/tex; mode=display">
令$E_{\hat{w}}=(\mathbf{y}-X\hat{w})^{T}(\mathbf{y}-X\hat{w})$,对$\hat{w}$求导得：</script><p>\begin{aligned}<br>\frac{\partial E_{\hat{w}}}{\partial \hat{w}}&amp;=\triangledown_{\hat{w}}(\mathbf{y}^{T}-\hat{w}^{T}X^{T})(\mathbf{y}-X\hat{w})<br>\\ &amp;=\triangledown_{\hat{w}}(\mathbf{y}^{T}\mathbf{y}-y^{T}X\hat{w}-\hat{w}^{T}X^{T}\mathbf{y}+\hat{w}^{T}X^{T}X\hat{w})<br>\\ &amp;=0-(\mathbf{y}^{T}X)^{T}-X^{T}\mathbf{y}+(X^{T}X\hat{w}+(\hat{w}X^{T}X)^{T})<br>\\ &amp;=-2X^{T}\mathbf{y}+2X^{T}X\hat{w}<br>\\ &amp;=2X^{T}(X\hat{w}-\mathbf{y})<br>\end{aligned}<br>\\ 这里的矩阵求导法则用了如下两个公式: \\<br>\frac{\partial(A^{T}WB)}{\partial W}=AB^{T},\frac{\partial(A^{T}W^{T}B)}{\partial W}=BA^{T}</p>
<script type="math/tex; mode=display">
令上式为零即可推导出$\hat{w}$的表达式：</script><p>2X^{T}(X\hat{w}-\mathbf{y})=0<br>\Rightarrow X^{T}X\hat{w}=X^{T}\mathbf{y}<br>\\ \Rightarrow \hat{w}=(X^{T}X)^{-1}X^{T}\mathbf{y}</p>
<script type="math/tex; mode=display">
令每个样本为$\hat{x}_{i}=(\mathbf{x}_{i},1)$，得最终的多元线性回归模型：</script><p>\begin{aligned}<br>f(\hat{x}_{i})&amp;=(\mathbf{x}_{i},1)\begin{pmatrix}<br>w\\<br>b<br>\end{pmatrix}=\hat{x}_{i}\hat{w}\\&amp;=\hat{x}_{i}(X^{T}X)^{-1}X^{T}\mathbf{y}<br>\end{aligned}</p>
<script type="math/tex; mode=display">
显然，上式能成立的基本条件就是矩阵$X^{T}X$可逆（即满秩矩阵），**当特征的数量大于样本的数量时矩阵就不可逆了**。

### 广义线性模型</script><p>g(y)=w^{T}x+b\\ \Rightarrow \\<br>y = g^{-1}(w^{T}x+b)</p>
<p>$$</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>linear regression</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶</title>
    <url>/2020/04/27/python%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="python类特殊方法"><a href="#python类特殊方法" class="headerlink" title="python类特殊方法"></a>python类特殊方法</h2><ol>
<li><p>__init__ 和 __new__</p>
<p>init方法<strong>不是类的构造方法，其作用是返回实例</strong>，new方法才是<strong>类的构造方法</strong>，通过继承<strong>object</strong>类重写改方法</p>
</li>
<li><p>__enter__ 和 __exit__</p>
<p>enter作用是<strong>初始化后返回实例</strong>，exit作用是<strong>退出with语句后做处理，例如清理内存，关闭文件，删除冗余等</strong></p>
</li>
<li><p>__str__ 和 __repr__</p>
<p>str方法是用于<strong>将实例的信息以字符串的形式输出</strong>，repr方法与str作用相同，不同在于<strong>repr方法用于交互式环境调试</strong></p>
</li>
<li><p>__setattr__ 、__getattr__、__getattribute__ 、__delattr__</p>
<p>setattr用于<strong>设置属性</strong>，getattr用于<strong>获取不存在的属性</strong>，getattribute用于<strong>访问存在的属性</strong>，delattr用于<strong>删除属性</strong></p>
</li>
</ol><a id="more"></a>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><ul>
<li>迭代器：可迭代对象皆为迭代器，用户自定义对象通过实现iter方法和next方法实现迭代器。</li>
<li>生成器：特殊的迭代器，更节省内存（call for need）</li>
</ul>
<h2 id="args和-kwargs"><a href="#args和-kwargs" class="headerlink" title="*args和**kwargs"></a>*args和**kwargs</h2><ul>
<li>*args：表示多个<strong>无名参数</strong>，返回其组成的tuple</li>
<li>**kwargs：表示<strong>key=value关键字型参数</strong>，返回一个dict</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ol>
<li><p>普通装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decoration</span><span class="params">(func)</span>:</span>  <span class="comment"># 装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125; is running."</span>.format(func__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 返回被包装函数</span></span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>带参数的装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_param</span><span class="params">(level)</span>:</span>  <span class="comment"># 带参数的装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_decoration</span><span class="params">(func)</span>:</span>  <span class="comment"># 内部装饰器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"&#123;&#125; is running."</span>.format(func.__name__))</span><br><span class="line">            print(<span class="string">"this level is &#123;&#125;"</span>.format(level))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 返回被包装函数</span></span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装函数</span></span><br><span class="line">    <span class="keyword">return</span> my_decoration  <span class="comment"># 返回装饰器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span>  <span class="comment"># 类装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"this is class decorator."</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        print(<span class="string">"ending..."</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>functools.wraps:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decoration</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 负责保护原函数的doc和name的装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
</li>
<li><p>装饰器的执行顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="meta">@d3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>等价于<code>func = d1(d2(d3(func)))</code></p>
</li>
<li><p>内部装饰器</p>
<ul>
<li>@staticmethod: 将类中函数修饰为静态方法不需要额外的参数（self等），<strong>不能访问类中的参数</strong></li>
<li>@classmethod: 函数必须包含一个类参数<strong>cls</strong>，返回一个实例，<strong>可访问类中的成员</strong></li>
<li>@property: <strong>将函数作为类的属性</strong>，进而使函数拥有setter方法和deletter方法，其本身是getter方法</li>
</ul>
</li>
<li><p>协程、多线程、多进程</p>
<ul>
<li>async</li>
<li>threading</li>
<li>multiprocessing</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫：豆瓣短评</title>
    <url>/2019/11/28/python%E7%88%AC%E8%99%AB%E8%B1%86%E7%93%A3%E7%9F%AD%E8%AF%84/</url>
    <content><![CDATA[<h2 id="导入必要的包-package"><a href="#导入必要的包-package" class="headerlink" title="导入必要的包(package)"></a>导入必要的包(package)</h2><p>若没有下列的包，可使用<code>pip install 包名</code>命令安装</p><ul>
<li>re: 使用正则表达式</li>
<li>json: 解析json内容</li>
<li>time: 爬虫间歇时间控制</li>
<li>jieba: 中文分词库</li>
<li>urlib: 将中文关键字编码(百分号+数字)</li>
<li>requests: 向网站发出请求</li>
<li>bs4: 解析网页内容</li>
<li>wordcloud: 生成词云</li>
</ul><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<h2 id="项目需求：爬取豆瓣的书评和影评概要"><a href="#项目需求：爬取豆瓣的书评和影评概要" class="headerlink" title="项目需求：爬取豆瓣的书评和影评概要"></a>项目需求：爬取豆瓣的书评和影评概要</h2><ul>
<li><strong>输入指定的书籍名称和电影名称，返回其评论构成的词云。</strong></li>
</ul>
<h3 id="网站分析-豆瓣电影和豆瓣读书"><a href="#网站分析-豆瓣电影和豆瓣读书" class="headerlink" title="网站分析(豆瓣电影和豆瓣读书)"></a>网站分析(豆瓣电影和豆瓣读书)</h3><p>我们豆瓣电影为例，爬取豆瓣读书原理相仿。</p>
<ul>
<li><strong>豆瓣电影</strong>：主页网址<a href="https://movie.douban.com/" target="_blank" rel="noopener">https://movie.douban.com/</a>，其页面如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_1.png" alt="movie.com">  </li>
</ul>
<p>首先我们打开谷歌浏览器的开发者工具，如果我们要搜索电影则在搜索框中键入搜索关键字是最近刚出的电影<strong>小丑</strong>，则会弹出下拉列表，并且旁边的Network中会显示出刚刚的响应：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_2.png" alt="xiaochou"><br>我们可以发现出现了一个json文件，这个json文件即是下拉列表的信息：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_3.png" alt="list"><br>我们再看看它的url，也就是我们爬虫目标网址，同时我们也能找到需要的请求头headers，可以发现它将我们的搜索关键字重新编码了(%+数字)，这个我们稍后用urllib处理编码：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_6.png" alt="head"><br>继续分析json文件，json文件中的内容就是每个电影的网址，列表中第一个地址即是我们要找的<strong>小丑</strong>的网址主页：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_4.png" alt="xiaochou"><br>我们点进小丑的主页进行验证，网址中的那串数字就是我们需要解析出来的电影唯一标识：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_5.png" alt="zhuye"><br>最后我们来看我们的目的地评论的网址，往下翻，点击全部评论：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_7.png" alt="com"><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_8.png" alt="com1"><br>发现网址并没有什么规律，我们继续点击评论的下一页，规律出现了。每增加一页，start参数增加20，这便是我们批量爬取评论的根据：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_9.png" alt="page"><br>好，我们继续看评论在html文件中的位置：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/2.png" alt="loc"><br>ok，分析完毕，爬虫抓取大概就是这个流程，最终的目的就是找到<strong>需求信息的位置</strong>。</p>
<h3 id="爬虫设计"><a href="#爬虫设计" class="headerlink" title="爬虫设计"></a>爬虫设计</h3><p>根据以上的分析，我们这样来设计我们的爬虫的爬虫流程：</p>
<ol>
<li>将我们输入的关键字编码成网址中的编码类型。</li>
<li>获取json中电影的真实地址信息。</li>
<li>生成我们要访问的评论所在的网页地址</li>
<li>抓取评论信息。</li>
</ol>
<h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>接下来给出几个关键步骤的代码说明</p>
<h3 id="汉字编码"><a href="#汉字编码" class="headerlink" title="汉字编码"></a>汉字编码</h3><p>使用<code>urllib.parse</code>中的<code>quote</code>函数进行编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__handle_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    编码中文关键字(%+[00-99])</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> str(quote(name))</span><br></pre></td></tr></table></figure>
<h3 id="解析json获取地址"><a href="#解析json获取地址" class="headerlink" title="解析json获取地址"></a>解析json获取地址</h3><p>使用<code>json</code>库中的<code>loads</code>函数解析json文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__find_url</span><span class="params">(self, url, tp)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取真实主页地址和编号id</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    r = requests.get(url, headers=self.headers[tp])</span><br><span class="line">    json_data = json.loads(r.text)</span><br><span class="line">    address_num = re.search(<span class="string">'[0-9]+'</span>, json_data[<span class="number">0</span>][<span class="string">'url'</span>])</span><br><span class="line">    <span class="keyword">if</span> tp == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> self.movie_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取电影地址</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.book_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取书籍地址</span></span><br></pre></td></tr></table></figure>
<h3 id="使用WordCloud生成词云"><a href="#使用WordCloud生成词云" class="headerlink" title="使用WordCloud生成词云"></a>使用WordCloud生成词云</h3><p>使用<code>WordCloud</code>生成词云，用<code>jieba</code>进行中文分词。该函数中有两个变量需要解释：</p>
<ul>
<li>bg_image: 为词云添加背景图片。</li>
<li>scale: 词云图片的清晰度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__plot_wordcloud</span><span class="params">(self, name, bg_image=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    绘制词云</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    file_name = str(name) + <span class="string">'.txt'</span></span><br><span class="line">    f = open(file_name, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>).read()</span><br><span class="line">    cut_text = <span class="string">" "</span>.join(jieba.cut(f))  <span class="comment"># 中文分词</span></span><br><span class="line">    print(<span class="string">"正在生成词云..."</span>)</span><br><span class="line">    word_cloud = WordCloud(</span><br><span class="line">        scale=<span class="number">10</span>,</span><br><span class="line">        font_path=<span class="string">'C:/Windows/Fonts/simfang.ttf'</span>,</span><br><span class="line">        background_color=<span class="string">"white"</span>, width=<span class="number">1000</span>, height=<span class="number">1000</span></span><br><span class="line">    ).generate(cut_text)</span><br><span class="line">    plt.imshow(word_cloud, interpolation=<span class="string">'bilinear'</span>)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="完整代码及运行示例"><a href="#完整代码及运行示例" class="headerlink" title="完整代码及运行示例"></a>完整代码及运行示例</h2><p>将整个爬虫过程封装，根据上述爬取电影评论的方法同时也实现了爬取数据评论的方法，最后爬取了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanCrawl</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, info_type)</span>:</span></span><br><span class="line">        self.info_type = info_type</span><br><span class="line">        self.headers = [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'movie.douban.com'</span></span><br><span class="line">            &#125;,  <span class="comment"># movie's headers</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'book.douban.com'</span></span><br><span class="line">            &#125;  <span class="comment"># book's headers</span></span><br><span class="line">        ]</span><br><span class="line">        self.movie_search_url = <span class="string">"https://movie.douban.com/j/subject_suggest?q="</span></span><br><span class="line">        self.movie_url = <span class="string">"https://movie.douban.com/subject/%s/"</span></span><br><span class="line">        self.movie_comment_url = <span class="string">"https://movie.douban.com/subject/%s/comments?start=%d&amp;limit=20&amp;sort=new_score&amp;status=P"</span></span><br><span class="line"></span><br><span class="line">        self.book_search_url = <span class="string">"https://book.douban.com/j/subject_suggest?q="</span></span><br><span class="line">        self.book_url = <span class="string">"https://book.douban.com/subject/%s/"</span></span><br><span class="line">        self.book_comment_url = <span class="string">"https://book.douban.com/subject/%s/comments/hot?p=%d"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_crawl</span><span class="params">(self, name, bg_image=None)</span>:</span></span><br><span class="line">        name_str = self.__handle_name(name)  <span class="comment"># 获取url的gbk编码</span></span><br><span class="line">        text_list = []</span><br><span class="line">        <span class="keyword">if</span> self.info_type == <span class="string">"movie"</span>:</span><br><span class="line">            print(<span class="string">"-----爬取电影短评-----"</span>)</span><br><span class="line">            self.movie_search_url += name_str</span><br><span class="line">            self.movie_url, num_str = self.__find_url(self.movie_search_url, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">15</span>):</span><br><span class="line">                url = self.movie_comment_url % (num_str, i*<span class="number">20</span>)</span><br><span class="line">                time.sleep(np.random.randint(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 间隔1~3秒</span></span><br><span class="line">                print(<span class="string">"正在获取第%d个页面"</span> % i)</span><br><span class="line">                r = requests.get(url, headers=self.headers[<span class="number">0</span>])</span><br><span class="line">                soup = BeautifulSoup(r.content, <span class="string">'lxml'</span>)</span><br><span class="line">                comment_list = soup.find_all(<span class="string">'span'</span>, class_=<span class="string">'short'</span>)</span><br><span class="line">                <span class="keyword">for</span> ct <span class="keyword">in</span> comment_list:</span><br><span class="line">                    text_list.append(ct.text)</span><br><span class="line">            self.__comment_to_txt(name, text_list)  <span class="comment"># 存储评论文字</span></span><br><span class="line">            self.__plot_wordcloud(name, bg_image)  <span class="comment"># 绘制词云</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"-----爬取书籍短评-----"</span>)</span><br><span class="line">            self.book_search_url += name_str</span><br><span class="line">            self.book_url, num_str = self.__find_url(self.book_search_url, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">20</span>):</span><br><span class="line">                url = self.book_comment_url % (num_str, i)</span><br><span class="line">                time.sleep(np.random.randint(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 间隔1~3秒</span></span><br><span class="line">                print(<span class="string">"正在获取第%d个页面"</span> % i)</span><br><span class="line">                r = requests.get(url, headers=self.headers[<span class="number">1</span>])</span><br><span class="line">                soup = BeautifulSoup(r.content, <span class="string">'lxml'</span>)</span><br><span class="line">                comment_list = soup.find_all(<span class="string">'span'</span>, class_=<span class="string">'short'</span>)</span><br><span class="line">                <span class="keyword">for</span> ct <span class="keyword">in</span> comment_list:</span><br><span class="line">                    text_list.append(ct.text)</span><br><span class="line">            self.__comment_to_txt(name, text_list)</span><br><span class="line">            self.__plot_wordcloud(name, bg_image)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__plot_wordcloud</span><span class="params">(self, name, bg_image=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        绘制词云</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :param bg_image:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        file_name = str(name) + <span class="string">'.txt'</span></span><br><span class="line">        f = open(file_name, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>).read()</span><br><span class="line">        cut_text = <span class="string">" "</span>.join(jieba.cut(f))</span><br><span class="line">        print(<span class="string">"正在生成词云..."</span>)</span><br><span class="line">        word_cloud = WordCloud(</span><br><span class="line">            scale=<span class="number">10</span>,</span><br><span class="line">            font_path=<span class="string">'C:/Windows/Fonts/simfang.ttf'</span>,</span><br><span class="line">            background_color=<span class="string">"white"</span>, width=<span class="number">1000</span>, height=<span class="number">1000</span></span><br><span class="line">        ).generate(cut_text)</span><br><span class="line">        plt.imshow(word_cloud, interpolation=<span class="string">'bilinear'</span>)</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__comment_to_txt</span><span class="params">(self, name, clist)</span>:</span></span><br><span class="line">        file_name = str(name) + <span class="string">'.txt'</span></span><br><span class="line">        <span class="keyword">with</span> open(file_name, <span class="string">'a+'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> clist:</span><br><span class="line">                f.write(c)</span><br><span class="line">            f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__handle_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        编码中文关键字</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> str(quote(name))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__find_url</span><span class="params">(self, url, tp)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取真实主页地址和编号id</span></span><br><span class="line"><span class="string">        :param url:</span></span><br><span class="line"><span class="string">        :param tp:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        r = requests.get(url, headers=self.headers[tp])</span><br><span class="line">        json_data = json.loads(r.text)</span><br><span class="line">        address_num = re.search(<span class="string">'[0-9]+'</span>, json_data[<span class="number">0</span>][<span class="string">'url'</span>])</span><br><span class="line">        <span class="keyword">if</span> tp == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.movie_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取电影地址</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.book_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取书籍地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    my_crawl = DoubanCrawl(<span class="string">"movie"</span>)</span><br><span class="line">    my_crawl.info_crawl(<span class="string">'千与千寻'</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-----爬取电影短评-----</span><br><span class="line">正在获取第0个页面</span><br><span class="line">正在获取第1个页面</span><br><span class="line">正在获取第2个页面</span><br><span class="line">正在获取第3个页面</span><br><span class="line">正在获取第4个页面</span><br><span class="line">正在获取第5个页面</span><br><span class="line">正在获取第6个页面</span><br><span class="line">正在获取第7个页面</span><br><span class="line">正在获取第8个页面</span><br><span class="line">正在获取第9个页面</span><br><span class="line">正在获取第10个页面</span><br><span class="line">正在获取第11个页面</span><br><span class="line">正在获取第12个页面</span><br><span class="line">正在获取第13个页面</span><br><span class="line">正在获取第14个页面</span><br><span class="line">Building prefix dict from the default dictionary ...</span><br><span class="line">Loading model from cache C:\Users\SkecisAI\AppData\Local\Temp\jieba.cache</span><br><span class="line">Loading model cost 0.879 seconds.</span><br><span class="line">Prefix dict has been built succesfully.</span><br><span class="line">正在生成词云...</span><br></pre></td></tr></table></figure>
<p><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/2_1.png" alt="cloud"></p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之道</title>
    <url>/2019/11/22/python%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本文使用python实现了一些常用的排序方法。文章结构如下如下：</p><ol>
<li><a href="#直接插入排序">直接插入排序</a></li>
<li><a href="#希尔排序">希尔排序</a></li>
<li><a href="#冒泡排序">冒泡排序</a></li>
<li><a href="#快速排序">快速排序</a></li>
<li><a href="#简单选择排序">简单选择排序</a></li>
<li><a href="#堆排序">堆排序</a></li>
<li><a href="#归并排序">归并排序</a></li>
<li><a href="#基数排序">基数排序</a></li>
</ol><a id="more"></a>

<p><strong>上述所有的排序均写在一个python自定义类中，作为成员函数。</strong></p>
<h2 id="排序方法详细介绍"><a href="#排序方法详细介绍" class="headerlink" title="排序方法详细介绍"></a>排序方法详细介绍</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><strong>直接插入排序</strong>(Straight Insertion Sort)是一种最简单的排序方法，它的基本操作是一个值插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/insert.png" alt="insert"><br>由上图可知若最初始的有序表即为数组的第一个元素。用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">straight_insertion_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    直接插入排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> self.__straight_insert(value_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__straight_insert</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    sorted_list = []</span><br><span class="line">    sorted_list.append(value_list.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(value_list)):</span><br><span class="line">        tail = <span class="literal">True</span>  <span class="comment"># 是否在尾部插入</span></span><br><span class="line">        insert_loc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(sorted_list)):</span><br><span class="line">            <span class="keyword">if</span> value_list[i] &lt;= sorted_list[j]:</span><br><span class="line">                tail = <span class="literal">False</span></span><br><span class="line">                insert_loc = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        sorted_list.append(value_list[i])  <span class="comment"># 先将值插入尾部</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">            <span class="comment"># 移动值</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(sorted_list) - <span class="number">1</span>, insert_loc, <span class="number">-1</span>):</span><br><span class="line">                tmp = sorted_list[j]</span><br><span class="line">                sorted_list[j] = sorted_list[j - <span class="number">1</span>]</span><br><span class="line">                sorted_list[j - <span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><strong>希尔排序</strong>(Shell’s Sort)又称“缩小增量排序”(Diminishing Incerement Sort)，它也是一种数插入排序的方法，但在时间效率上较前面的排序方法有较大的改进。它的基本思想是：先将整个待排记录序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/shell.png" alt="shell"><br>即根据增量将原序列分割成多个子序列进行直接插入排序。<strong>增量应不断减小，且最后一个增量为1</strong>。用python实现如下(其中用到的子函数见前文)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shells_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    gap = len(value_list) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt;= <span class="number">1</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i + gap) &lt; len(value_list):</span><br><span class="line">            start = i</span><br><span class="line">            gap_list = []</span><br><span class="line">            <span class="keyword">while</span> start &lt; len(value_list):</span><br><span class="line">                gap_list.append(value_list[start])</span><br><span class="line">                start = start + gap</span><br><span class="line">            gap_list = self.__straight_insert(gap_list)</span><br><span class="line">            start = i</span><br><span class="line">            <span class="keyword">while</span> start &lt; len(value_list):</span><br><span class="line">                value_list[start] = gap_list.pop(<span class="number">0</span>)</span><br><span class="line">                start = start + gap</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的过程很简单。首先将第一个记录的关键字和第二个记录的关键字进行比较，若逆序(与需要的顺序相反)，则将两个记录交换之，然后比较第二个记录和第三个记录的关键字，以此类推。为第一趟冒泡结束，接着对前$n-1$个记录继续进行上述的过程。这样重复的过程直至$n-1=1$结束。排序过程如下所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/buble.png" alt="buble"><br>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubule_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value_list) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(value_list)):</span><br><span class="line">            <span class="keyword">if</span> value_list[i] &gt; value_list[j]:</span><br><span class="line">                tmp = value_list[j]</span><br><span class="line">                value_list[j] = value_list[i]</span><br><span class="line">                value_list[i] = tmp</span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>快速排序</strong>(Quick Sort)是对冒泡排序的的一种改进。它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，已达到整个序列有序。其排序思想如下：</p>
<blockquote>
<p>首先任意选取一个记录（通常可选第一个记录）作为<strong>枢轴</strong>，然后按下述原则重新排列记录：将所有关键字较它小的记录都安置在它的位置之前，将所有关键字较它大的记录都安置在它的位置之后。一趟快速排序的具体做法是：设两个指针low和high，他们的初值分别为最低位置的下一个位置和最高位，设最低位置位枢轴的关键字为pivotkey，则首先从high所指位置起像前搜索找到第一个关键字小于pivotkey的记录和枢轴记录互相交换。<strong>发生了交换后</strong>才从low所指向的位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录互相交换。重复这两步直至low=how为止</p>
</blockquote>
<p>如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/quick.png" alt="quick"><br>特别要注意换方向的时机是<strong>发生了交换后</strong>，用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(value_list) - <span class="number">1</span></span><br><span class="line">    self.__qsort(value_list, low, high)</span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__qsort</span><span class="params">(self, val_list, low, high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序辅助函数</span></span><br><span class="line"><span class="string">    :param val_list: 无序列表</span></span><br><span class="line"><span class="string">    :param low: 低位</span></span><br><span class="line"><span class="string">    :param high: 高位</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pivot_key = low</span><br><span class="line">    tmp_low = pivot_key</span><br><span class="line">    tmp_high = high</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:  <span class="comment"># 分成一边比轴（pivot）大，一边比轴（pivot）小的顺序</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">if</span> val_list[high] &lt; val_list[pivot_key]:</span><br><span class="line">                tmp = val_list[high]</span><br><span class="line">                val_list[high] = val_list[pivot_key]</span><br><span class="line">                val_list[pivot_key] = tmp</span><br><span class="line">                pivot_key = high</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 发生交换后，就换方向</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">if</span> val_list[low] &gt; val_list[pivot_key]:</span><br><span class="line">                tmp = val_list[low]</span><br><span class="line">                val_list[low] = val_list[pivot_key]</span><br><span class="line">                val_list[pivot_key] = tmp</span><br><span class="line">                pivot_key = low</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 发生交换后，就换方向</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">    self.__qsort(val_list, tmp_low, pivot_key - <span class="number">1</span>)</span><br><span class="line">    self.__qsort(val_list, pivot_key + <span class="number">1</span>, tmp_high)</span><br></pre></td></tr></table></figure>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>选择排序的基本思想是：每一趟在$n-i+1(i=1,2,…,n-1)$个记录中选取关键字最小的记录作为有序序列中第$i$个记录。简单选择排序：通过$n-1$次关键字的比较，从$n-i+1$个记录中选出关键字最小的记录，并和第$i(1\leq i\leq n)$个记录交换之。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/selection.png" alt="simple"><br>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_selection_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    简单选择排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value_list)):</span><br><span class="line">        min_val = <span class="number">9999999</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(value_list)):</span><br><span class="line">            <span class="keyword">if</span> min_val &gt; value_list[j]:</span><br><span class="line">                min_val = value_list[j]</span><br><span class="line">        count = <span class="number">0</span>  <span class="comment"># 如果有多个相同的最小值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(value_list)):</span><br><span class="line">            <span class="keyword">if</span> min_val == value_list[j]:</span><br><span class="line">                tmp = value_list[j]</span><br><span class="line">                value_list[j] = value_list[i + count]</span><br><span class="line">                value_list[i + count] = tmp</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>堆</strong>的定义如下：$n$个元素的序列$\left \{k_{1},k_{2}, …k_{n} \right \}$当且仅当满足一下关系时，称之为堆。</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
k_{i}\leq k_{2i}\\
k_{i}\leq k_{2i+1}
\end{matrix}\right.或\left\{\begin{matrix}
k_{i}\geq k_{2i}\\
k_{i}\geq k_{2i+1}
\end{matrix}\right.</script><p><strong>若将序列看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端节点均不大于（或不小于）其左、右孩子节点的值。由此，若序列是堆，则堆顶元素必为序列中的最小值（或最大值）</strong>。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/heap.png" alt="heap"><br>至此，我们可以给出<strong>堆排序</strong>的过程：<strong>若在输出堆顶的最小值后，使得剩余$n-1$个元素的序列又建成一个堆，则得到$n$个元素中的次小值。如此反复执行，便能得到一个有序序列。</strong><br>故整个堆排序可以大致分为两个过程：</p>
<ul>
<li>将无序序列建成堆。</li>
<li>输出堆顶元素后，用类似建堆的方法调整堆。</li>
</ul>
<p>如下两个图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/construct_heap.png" alt="1"><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/heap_sort.png" alt="2"><br>根据堆排序的特点总结出两点注意事项：</p>
<ol>
<li>利用把堆看成完全二叉树的特点，用<strong>完全二叉树的性质</strong>解决算法问题</li>
<li>建堆的过程是从树种的<strong>最后一个非终端节点</strong>逆序开始调整的。</li>
<li>每调整一次需要检查前后是否依然保持<strong>堆的特征</strong>。</li>
</ol>
<p>本文利用了二叉树的<strong>孩子兄弟表示法</strong>来生成二叉树(堆)的。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">__CldSibNode</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    私有内部类：孩子兄弟二叉链表节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.value = val</span><br><span class="line">        self.child = <span class="literal">None</span></span><br><span class="line">        self.sibling = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">堆排序</span></span><br><span class="line"><span class="string">:param value_list: 无序列表</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">sorted_list = []</span><br><span class="line">root_node = self.__CldSibNode(<span class="literal">None</span>)</span><br><span class="line">self.__child_sibling(root_node, value_list, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> ct <span class="keyword">in</span> range(<span class="number">1</span>, len(value_list) // <span class="number">2</span> + <span class="number">1</span>):  <span class="comment"># 建堆</span></span><br><span class="line">    self.__adjust_heap(root_node, len(value_list) // <span class="number">2</span> + <span class="number">1</span> - ct, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(value_list) + <span class="number">1</span>):  <span class="comment"># 堆排序</span></span><br><span class="line">    sorted_list.append(root_node.value)  <span class="comment"># 输出堆顶元素</span></span><br><span class="line">    head = root_node</span><br><span class="line">    self.__shrink_heap(root_node, len(value_list) + <span class="number">1</span> - i, <span class="number">1</span>, head)  <span class="comment"># 收缩堆</span></span><br><span class="line">    self.__adjust_heap(root_node, <span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 调整堆</span></span><br><span class="line"><span class="keyword">return</span> sorted_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__child_sibling</span><span class="params">(self, node, value_list, ind)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建完全二叉树的左孩子右兄弟二叉链表</span></span><br><span class="line"><span class="string">    :param node: 当前节点</span></span><br><span class="line"><span class="string">    :param value_list:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> ind &gt;= len(value_list):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    node.value = value_list[ind]</span><br><span class="line">    <span class="keyword">if</span> (ind * <span class="number">2</span> + <span class="number">1</span>) &lt; len(value_list):</span><br><span class="line">        node.child = self.__CldSibNode(<span class="literal">None</span>)  <span class="comment"># 孩子</span></span><br><span class="line">        self.__child_sibling(node.child, value_list, ind * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (ind * <span class="number">2</span> + <span class="number">2</span>) &lt; len(value_list):</span><br><span class="line">        node.child.sibling = self.__CldSibNode(<span class="literal">None</span>)  <span class="comment"># 兄弟</span></span><br><span class="line">        self.__child_sibling(node.child.sibling, value_list, ind * <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__adjust_heap</span><span class="params">(self, root_node, last_ind, now_ind)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        内部函数：交换两个变量值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> y, x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> root_node) <span class="keyword">or</span> (<span class="keyword">not</span> root_node.child):  <span class="comment"># 不为空且有孩子</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> now_ind == last_ind:  <span class="comment"># 需要调整的非终端节点</span></span><br><span class="line">        tmp = root_node</span><br><span class="line">        cg = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> tmp.child:</span><br><span class="line">            <span class="keyword">if</span> tmp.value &gt; tmp.child.value:  <span class="comment"># 如果大于左子树根节点</span></span><br><span class="line">                tmp.value, tmp.child.value = change(tmp.value, tmp.child.value)</span><br><span class="line">                cg = <span class="literal">True</span>  <span class="comment"># 发生交换</span></span><br><span class="line">            <span class="keyword">if</span> tmp.child.sibling:</span><br><span class="line">                <span class="keyword">if</span> tmp.value &gt; tmp.child.sibling.value:</span><br><span class="line">                    <span class="keyword">if</span> cg:  <span class="comment"># 如果发生过交换</span></span><br><span class="line">                        tmp.value, tmp.child.value = change(tmp.value, tmp.child.value)</span><br><span class="line">                    tmp.value, tmp.child.sibling.value = change(tmp.value, tmp.child.sibling.value)</span><br><span class="line">                    tmp = tmp.child.sibling</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> cg:  <span class="comment"># 如果发生过交换</span></span><br><span class="line">                        tmp = tmp.child</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    self.__adjust_heap(root_node.child, last_ind, now_ind * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> root_node.child.sibling:</span><br><span class="line">        self.__adjust_heap(root_node.child.sibling, last_ind, now_ind * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__shrink_heap</span><span class="params">(self, root_node, last_ind, now_ind, head)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> root_node) <span class="keyword">or</span> (now_ind * <span class="number">2</span> &gt; last_ind):  <span class="comment"># 不为空</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> last_ind == (now_ind * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        head.value = root_node.child.sibling.value</span><br><span class="line">        root_node.child.sibling = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> last_ind == (now_ind * <span class="number">2</span>):</span><br><span class="line">        head.value = root_node.child.value</span><br><span class="line">        root_node.child = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> root_node.child:</span><br><span class="line">        self.__shrink_heap(root_node.child, last_ind, now_ind * <span class="number">2</span>, head)</span><br><span class="line">        self.__shrink_heap(root_node.child.sibling, last_ind, now_ind * <span class="number">2</span> + <span class="number">1</span>, head)</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序(Merging)，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假设初始序列有$n$个记录，则可看成是$n$个有序的子序列，每个子序列的长度为1，然后两两归并，得到$\left \lceil \frac{n}{2} \right \rceil$个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为$n$的有序序列为止，这种排序方法称为<strong>2-路归并排序</strong>。算法的基本思想如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/merge.png" alt="merge"><br>其中两个子序列的合并大有学问，基本思想就是：<strong>分别在两个序列头设置指针，比较两个序列指针所指的值的大小，将满足要求的值提取出来形成新列表，并将指针右移。当其中一个指针指向结尾之后时，表示其中一个列表已取尽，接着直接在新列表尾部连接另一个列表</strong>。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/merge1.png" alt="mege_1"><br>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merging_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    归并排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> np.power(<span class="number">2</span>, i) &lt; len(value_list):</span><br><span class="line">        count = np.power(<span class="number">2</span>, i)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        outer_tmp = []</span><br><span class="line">        <span class="keyword">while</span> start &lt; len(value_list):</span><br><span class="line">            other = start + count  <span class="comment"># 定位另一边</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">if</span> other &gt;= len(value_list):  <span class="comment"># 另一边不存在</span></span><br><span class="line">                outer_tmp.extend(value_list[start:start + count])  <span class="comment"># 直接合并</span></span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 结束</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; count) <span class="keyword">or</span> (right &lt; count):</span><br><span class="line">                <span class="keyword">if</span> other + right &gt;= len(value_list):  <span class="comment"># 右边提前结束</span></span><br><span class="line">                    tmp.extend(value_list[start + left:start + count])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> value_list[start + left] &lt; value_list[other + right]:  <span class="comment"># 左边更小</span></span><br><span class="line">                    tmp.append(value_list[start + left])</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> left == count:  <span class="comment"># 左边遍历结束</span></span><br><span class="line">                        tmp.extend(value_list[other + right:other + count])  <span class="comment"># 合并右边</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 右边更小</span></span><br><span class="line">                    tmp.append(value_list[other + right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> right == count:  <span class="comment"># 右边遍历结束</span></span><br><span class="line">                        tmp.extend(value_list[start + left:start + count])  <span class="comment"># 合并左边</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            outer_tmp.extend(tmp)</span><br><span class="line">            start += count * <span class="number">2</span></span><br><span class="line">        value_list = outer_tmp</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序</strong>(Radix Sort)是利用了多关键字排序的思想，分为从低位关键字开始排序的<strong>最低位优先法</strong>(Least Significant Digit first)和从高位关键字开始排序的<strong>高位优先法</strong>(Most Signficant Digit first)。基数排序是借助“分配”和“收集”两种操作对单逻辑关键字进行排序的一种内部排序方法。</p>
<blockquote>
<p>如对三位数(0~999，即有三个关键字)进行最低位优先法排序：<strong>首先以静态链表存储$n$个待排记录，并另表头指针指向第一个记录；第一趟分配对低位关键字个位数进行，初始化10个空队列，每个队列中记录关键字的个位数相等。第一趟收集是改变所有费控队列的队尾指针域，令其指向下一个非空队列的队头，重新将10个队列链接成一个链表。第二次、第三次分别对十位和百位进行同样的操作</strong>，直至排序结束。</p>
</blockquote>
<p>如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/radix.png" alt="radix"><br>排序时有两点需要注意：</p>
<ol>
<li>每完成一趟排序，要清空队列。</li>
<li>队列的连接要找到第一个不为空的队列作为头，和绕开所有空队列。</li>
</ol>
<p>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    基数排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_n</span><span class="params">(num, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        内部函数：得到数的第n位</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        remainder = num % np.power(<span class="number">10</span>, n)</span><br><span class="line">        quotient = remainder // np.power(<span class="number">10</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> quotient</span><br><span class="line"></span><br><span class="line">    max_val = <span class="number">-99999</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> value_list:</span><br><span class="line">        <span class="keyword">if</span> val &gt; max_val:</span><br><span class="line">            max_val = val</span><br><span class="line">    iter_nums = <span class="number">0</span>  <span class="comment"># 最大位数</span></span><br><span class="line">    <span class="keyword">while</span> max_val &gt; <span class="number">0</span>:</span><br><span class="line">        iter_nums += <span class="number">1</span></span><br><span class="line">        max_val = max_val // <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> bit <span class="keyword">in</span> range(<span class="number">1</span>, iter_nums + <span class="number">1</span>):  <span class="comment"># 开始排序</span></span><br><span class="line">        tmp_list = []</span><br><span class="line">        qs = []  <span class="comment"># 创建新的链式队列数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            qs.append(que.LinkedQueue())</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> value_list:</span><br><span class="line">            qs[get_n(val, bit)].enqueue(val)  <span class="comment"># 按位数入队</span></span><br><span class="line">        qhead = <span class="literal">None</span></span><br><span class="line">        tmp_q = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> qs[j].front <span class="keyword">and</span> (qhead <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">                qhead = qs[j]  <span class="comment"># 寻找重组队列头</span></span><br><span class="line">                tmp_q = qhead</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> qs[j].front:</span><br><span class="line">                tmp_q.rear.pnext = qs[j].front  <span class="comment"># 将队列按顺序连接</span></span><br><span class="line">                tmp_q = qs[j]</span><br><span class="line">        tmp = qhead.front  <span class="comment"># 链接队列头</span></span><br><span class="line">        <span class="keyword">while</span> tmp:  <span class="comment"># 更新数组列表</span></span><br><span class="line">            tmp_list.append(tmp.value)</span><br><span class="line">            tmp = tmp.pnext</span><br><span class="line">        value_list = tmp_list</span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>编写测试代码和运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 排序之道</span></span><br><span class="line">    li = list(np.random.randint(<span class="number">1</span>, <span class="number">1000</span>, <span class="number">30</span>))</span><br><span class="line">    my_sort = MySort()</span><br><span class="line">    print(<span class="string">'original sequence: '</span>, li)</span><br><span class="line">    print(<span class="string">'-'</span> * <span class="number">170</span>)</span><br><span class="line">    print(<span class="string">'1.'</span>, my_sort.straight_insertion_sort.__name__, <span class="string">':'</span>, my_sort.straight_insertion_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'2.'</span>, my_sort.shells_sort.__name__, <span class="string">':            '</span>, my_sort.shells_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'3.'</span>, my_sort.bubule_sort.__name__, <span class="string">':            '</span>, my_sort.bubule_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'4.'</span>, my_sort.quick_sort.__name__, <span class="string">':             '</span>, my_sort.quick_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'5.'</span>, my_sort.simple_selection_sort.__name__, <span class="string">':  '</span>, my_sort.simple_selection_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'6.'</span>, my_sort.heap_sort.__name__, <span class="string">':              '</span>, my_sort.heap_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'7.'</span>, my_sort.merging_sort.__name__, <span class="string">':           '</span>, my_sort.merging_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'8.'</span>, my_sort.radix_sort.__name__, <span class="string">':             '</span>, my_sort.radix_sort(li.copy()))</span><br></pre></td></tr></table></figure>
<p>测试运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">original sequence:  [758, 74, 857, 781, 831, 719, 489, 785, 405, 621, 165, 568, 915, 939, 886, 4, 966, 461, 385, 757, 263, 505, 793, 259, 107, 437, 296, 702, 240, 644]</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">1. straight_insertion_sort : [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">2. shells_sort :             [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">3. bubule_sort :             [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">4. quick_sort :              [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">5. simple_selection_sort :   [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">6. heap_sort :               [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">7. merging_sort :            [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">8. radix_sort :              [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各个排序效率见下图：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/time_zone.png" alt="time"><br>可以得出以下几个结论：</p>
<ol>
<li>从平均时间性能而言，<strong>快速排序</strong>最佳。</li>
<li><strong>堆排序</strong>适用于$n$较大的数据。</li>
<li><strong>基数排序</strong>是稳定的，时间复杂度较大的<strong>简单排序</strong>方法也是稳定的。</li>
<li>稳定性是由方法本身决定的。</li>
<li>没有最好的排序方法，视情况而定。</li>
</ol>
<h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><ol>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L16" target="_blank" rel="noopener">直接插入排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L44" target="_blank" rel="noopener">希尔排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L69" target="_blank" rel="noopener">冒泡排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L84" target="_blank" rel="noopener">快速排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L131" target="_blank" rel="noopener">简单选择排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L152" target="_blank" rel="noopener">堆排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L237" target="_blank" rel="noopener">归并排序</a></li>
<li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L278" target="_blank" rel="noopener">基数排序</a></li>
</ol>
<p>仅供参考。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树(BST)</title>
    <url>/2019/11/18/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>二叉排序树又称为二叉查找树(Binary Sort Tree or Binary Search Tree, 简称BST)</strong>，或者是一颗空树，或者是具有下列性质的二叉树：</p><a id="more"></a>
<ol>
<li>若它的左子树不为空，则左子树上所有的节点的值均小于它的根节点的值。</li>
<li>若它的右子树不为空，则右子树上所有的节点的值均大于它的根节点的值。</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ol>
<p>如下例所示的二叉排序树：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/1.png" alt="二叉排序树"><br>根据上述定义的二叉排序树结构特点可见它的查找过程：当二叉排序树不为空时，首先将给定值和根节点的关键字比较，若相等，则查找成功，否则将依据给定值和根节点的关键字之间的大小关系，分别在左子树或右子树上继续进行查找。最后可见，<strong>二叉排序树的中序遍历结果即为从小到大的排序结果。</strong></p>
<h2 id="二叉排序树实现-python"><a href="#二叉排序树实现-python" class="headerlink" title="二叉排序树实现(python)"></a>二叉排序树实现(python)</h2><p>对给定的序列<code>list=[51, 12, 34, 5, 54, 89, 25, 11, 45, 67, 31, 22, 99, 79]</code>按顺序生成二叉排序树</p>
<h3 id="二叉树的节点"><a href="#二叉树的节点" class="headerlink" title="二叉树的节点"></a>二叉树的节点</h3><p>二叉树的节点分为三个部分：左子树指针域，数据域，右子树指针域。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/1_1.png" alt="node"><br>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the node of tree</span></span><br><span class="line"><span class="string">        :param v: the value of node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.value = v</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>生成一个二叉排序树的算法如下：</p>
<blockquote>
<p>初始化：生成一个空树$Tree$，即根节点为空：$Tree.root=None$<br>输入：一个数据$v$<br>步骤：  </p>
<ol>
<li>判断根节点$Tree.root$是否为空。若是，则生成根节点$Tree.root=Node(v)$，否则执行步骤2。</li>
<li>另当前节点为$NowNode=Tree.root$。</li>
<li>判断$v$与当前节点值$NowNode.value$的大小，如果$v&gt;NowNode.value$，执行步骤4，否则执行步骤5.</li>
<li>判断当前节点的右子树$NowNode.right$是否为空，如果$NowNode.right=None$，则生成新节点$NewNode(v)$，执行步骤6，否则另$NowNode=NowNode.right$，执行步骤3。</li>
<li>判断当前节点的左子树$NowNode.left$是否为空，如果$NowNode.left=None$，则生成新节点$NewNode(v)$，执行步骤6，否则另$NowNode=NowNode.left$，执行步骤3。</li>
<li>结束</li>
</ol>
</blockquote>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>用python实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, seq=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param seq: the optional parameter, to initialize the tree</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.insert(seq)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val_list)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        insert value into the tree</span></span><br><span class="line"><span class="string">        :param val_list: integer or list, the value waiting for inserting</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(val_list, list):</span><br><span class="line">            <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.root = Node(val_list.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> val_list:</span><br><span class="line">                self.__ins(v)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(val_list, int):</span><br><span class="line">            self.__ins(val_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ins</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        insert a value into the tree</span></span><br><span class="line"><span class="string">        :param v: interger</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_node = Node(v)</span><br><span class="line">        tmp = self.root</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> v &gt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.right:</span><br><span class="line">                    tmp = tmp.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.right = new_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> v &lt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.left:</span><br><span class="line">                    tmp = tmp.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.left = new_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        find the specific value</span></span><br><span class="line"><span class="string">        :param val:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.root</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> val == tmp.value:</span><br><span class="line">                print(<span class="string">"查找成功^_^"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> val &gt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.right:</span><br><span class="line">                    tmp = tmp.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"查找失败x_x"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> val &lt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.left:</span><br><span class="line">                    tmp = tmp.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"查找失败x_x"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        preorder traversal</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">            self.pre_order(node.left)</span><br><span class="line">            self.pre_order(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        inorder traversal</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.in_order(node.left)</span><br><span class="line">            print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">            self.in_order(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        postorder traversal</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.post_order(node.left)</span><br><span class="line">            self.post_order(node.right)</span><br><span class="line">            print(node.value, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<p>其中还包括了二叉排序树的<strong>遍历算法</strong>。<strong>其中中序遍历的结果即为排序结果</strong>。</p>
<h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h3><p>使用前面的列表<code>list</code>生成二叉排序树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    li = [<span class="number">51</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">54</span>, <span class="number">89</span>, <span class="number">25</span>, <span class="number">11</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">79</span>]</span><br><span class="line">    my_tree = BST(li)</span><br><span class="line">    my_tree.in_order(my_tree.root)</span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    my_tree.insert([<span class="number">23</span>, <span class="number">1</span>])</span><br><span class="line">    my_tree.in_order(my_tree.root)</span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    my_tree.search(<span class="number">23</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5 11 12 22 25 31 34 45 51 54 67 79 89 99 </span><br><span class="line">1 5 11 12 22 23 25 31 34 45 51 54 67 79 89 99 </span><br><span class="line">查找成功^_^</span><br></pre></td></tr></table></figure>
<p>生成的二叉排序树图示如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/2.png" alt="result"></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>KNN算法-python实现</title>
    <url>/2019/11/18/knn%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="k-近邻算法"><a href="#k-近邻算法" class="headerlink" title="$k$近邻算法"></a>$k$近邻算法</h2><p>$k$近邻(k-Nearest Neighbor, KNN)分类算法，是机器学习中最简单的算法之一。该算法的基本思路是：在一个未知的样本附近选取k个距离最短的已知样本（有类别标签），将这k个已知样本中数量最多的类别（标签）作为未知样本的类别（标签）。直观一点，如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/knn%E7%AE%97%E6%B3%95/1.png" alt="knn示例"><br>可以看到上图选取了$k=5$个距离未知样本最近的已知样本，5个已知样本中有三个红色矩形和两个蓝色矩形，由算法的基本思路可知，未知样本应标记为<strong>红色</strong>。</p><a id="more"></a>
<h2 id="距离的度量"><a href="#距离的度量" class="headerlink" title="距离的度量"></a>距离的度量</h2><p>$x$和$y$分别为两个样本，$n$为特征总数。一般用到的是以下两种距离：</p>
<ul>
<li><strong>欧式距离</strong>：<script type="math/tex; mode=display">d\left ( x,y \right )=\sqrt{\sum_{k=1}^{n}\left ( x_{k}-y_{k} \right )^{2}}</script></li>
<li><strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">d\left ( x,y \right )=\sqrt{\sum_{k=1}^{n}\left | x_{k}-y_{k} \right |}</script></li>
</ul>
<p>无论用那种距离，目的都是为了刻画已知样本和未知样本的<strong>相似度</strong>，从而描述预知样本的特征。</p>
<h2 id="用python实现算法"><a href="#用python实现算法" class="headerlink" title="用python实现算法"></a>用python实现算法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><blockquote>
<p>初始化：已知类别标签的样本集$X_{n}$和最多近邻数$k$，<br>输入：未知样本$x$<br>步骤：</p>
<ol>
<li>对于每个样本集中的样本$X_{i}$和未知样本$x$计算距离$d_{i}$。得到距离集$D_{n}$。</li>
<li>将距离集$D_{n}$中的数从小到大排序，选择前$k$个距离数据。</li>
<li>根据步骤2的$k$距离数据中的样本下标，得到对应的类别标签集$C_{k}$</li>
<li>选择$C_{k}$中数量最多的类别标签$c_{max}$作为未知样本$x$的类别标签$c$</li>
</ol>
</blockquote>
<h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><p>python实现knn算法的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the k of KNN</span></span><br><span class="line"><span class="string">        :param k: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.samples_nums = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, x_train, y_train, test)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        predict the categorie of test sample</span></span><br><span class="line"><span class="string">        :param x_train: the set of train sample</span></span><br><span class="line"><span class="string">        :param y_train: the label set of train sample</span></span><br><span class="line"><span class="string">        :param test: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x_train = np.array(x_train)</span><br><span class="line">        self.samples_nums = x_train.shape[<span class="number">0</span>]</span><br><span class="line">        y_train = np.array(y_train)</span><br><span class="line">        sorted_k_v = self.__cal_dist(x_train, test)</span><br><span class="line">        lab_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind <span class="keyword">in</span> range(self.k):</span><br><span class="line">            s = sorted_k_v[ind]</span><br><span class="line">            <span class="keyword">if</span> y_train[s[<span class="number">0</span>]] <span class="keyword">not</span> <span class="keyword">in</span> lab_dict.keys():</span><br><span class="line">                lab_dict[y_train[s[<span class="number">0</span>]]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lab_dict[y_train[s[<span class="number">0</span>]]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(lab_dict, key=lab_dict.get)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cal_dist</span><span class="params">(self, x_train, x_test)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        calculate the distance between train set and test sample</span></span><br><span class="line"><span class="string">        :param x_train: </span></span><br><span class="line"><span class="string">        :param x_test: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind <span class="keyword">in</span> range(self.samples_nums):</span><br><span class="line">            d[ind] = np.sqrt(sum(np.power(x_train[ind, :] - x_test, <span class="number">2</span>)))</span><br><span class="line">        sort_list = sorted(d.items(), key=<span class="keyword">lambda</span> itm: itm[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> sort_list</span><br></pre></td></tr></table></figure>
<p>测试案例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    my_knn = KNN(<span class="number">3</span>)</span><br><span class="line">    x = [[<span class="number">0.1</span>, <span class="number">0.2</span>], [<span class="number">-1.5</span>, <span class="number">-1.1</span>], [<span class="number">0.7</span>, <span class="number">1.9</span>], [<span class="number">-0.3</span>, <span class="number">1.0</span>]]</span><br><span class="line">    y = [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>]</span><br><span class="line">    print(my_knn.predict(x, y, [<span class="number">1</span>, <span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>输出：<code>b</code></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--哈希表</title>
    <url>/2019/11/14/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>在介绍哈希表之前，先介绍一下<strong>查找表</strong></p><h2 id="查找表-Search-Table"><a href="#查找表-Search-Table" class="headerlink" title="查找表(Search Table)"></a>查找表(Search Table)</h2><blockquote>
<p>查找表是由同一类型的数据元素(或记录)构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵活的数据结构</p>
</blockquote><a id="more"></a>

<h3 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h3><ol>
<li>查询某个“特定的”的数据元素是否在查找表中。</li>
<li>检索某个“特定的”数据元素的各种属性。</li>
<li>在查找表中插入一个数据元素</li>
<li>从查找表中删去某个元素。</li>
</ol>
<p>查找表根据其操作的不同又分为以下两种：</p>
<ul>
<li>若对查找表只作前两种统称为“查找”的操作，则称此类查找表为<strong>静态查找表(Static Search Table)</strong>。</li>
<li>若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素，则称此类表为<strong>动态查找表(Dynamic Search Table)</strong></li>
</ul>
<h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><p>为了解释“特定的”，引入了<strong>关键字</strong>:</p>
<blockquote>
<p>关键字是数据元素(或记录)中某个数据项的值，用它可以标识一个数据元素(或记录)。</p>
</blockquote>
<p>接着定义<strong>查找</strong>:</p>
<blockquote>
<p>根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。</p>
</blockquote>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>查找的效率依赖于查找过程中所进行的比较次数。</p>
<h3 id="哈希-Hash-函数"><a href="#哈希-Hash-函数" class="headerlink" title="哈希(Hash)函数"></a>哈希(Hash)函数</h3><blockquote>
<p>理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个对应关系$f$，使每个关键字和结构中一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系$f$找到给定值$K$的像$f\left ( K \right )$。<strong>若结构中存在关键字和$K$相等的记录，则必定在$f\left ( K \right )$的存储位置上</strong>，由此，不需要进行比较便可直接取得所查记录。在此，我们称这个对应关系$f$为<strong>哈希函数</strong>，按这个思想建立的表为<strong>哈希表</strong>。</p>
</blockquote>
<h3 id="哈希函数的特征"><a href="#哈希函数的特征" class="headerlink" title="哈希函数的特征"></a>哈希函数的特征</h3><ol>
<li>哈希函数是一个映像，因此哈希函数的设定很灵活，只要是的任何关键字由此所得的哈希函数值都落在表长允许的范围内即可。</li>
<li>对不同的关键字可能得到同一哈希地址，即$key_{1}\neq key_{2}$，而$f\left ( key_{1} \right )= f\left ( key_{2} \right )$，这种现象称为<strong>冲突(collision)</strong>。</li>
</ol>
<h3 id="哈希表定义"><a href="#哈希表定义" class="headerlink" title="哈希表定义"></a>哈希表定义</h3><p>综上，可如下描述哈希表：</p>
<blockquote>
<p>根据设定的哈希函数$H\left ( key \right )$和处理冲突的方法将一组关键字映像到一个有限的连续的地址集上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为<strong>哈希表</strong>，这一映像过程称为哈希造表或<strong>散列</strong>，所得存储位置称<strong>哈希地址</strong>或<strong>散列地址</strong>。</p>
</blockquote>
<h2 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h2><p>若对于关键字集合中的任一个关键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称此类哈希函数为<strong>均匀的(Uniform)</strong>哈希函数。换句话说，就是使关键字经过哈希函数得到一个“随机的地址”，以便使一组关键字的哈希地址<strong>均匀分布</strong>在整个地址区间中，从而减少<strong>冲突</strong></p>
<ul>
<li><strong>直接定址法</strong>：取关键字或关键字的某个线性函数值作为哈希地址。即：</li>
</ul>
<script type="math/tex; mode=display">H\left ( key \right )= key</script><script type="math/tex; mode=display">H\left ( key \right )= a\cdot key+b</script><ul>
<li><strong>数字分析法</strong>：假设关键字是以$r$为基的数(如：以10为基的十进制数)，并且哈希表中可能出现的关键字都是事先知道的，则可以取关键字的若干数位组成哈希地址。</li>
<li><strong>平方取中法</strong>：取关键字平方后的中间几位为哈希地址。</li>
<li><strong>折叠法</strong>：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为哈希地址。</li>
<li><strong>除留余数法</strong>：取关键字被某个不大于哈希表表长$m$的数$p$除后所得的余数为哈希地址。即:</li>
</ul>
<script type="math/tex; mode=display">H\left ( key \right )= key\left ( MOD \right )p, p\leq m</script><h2 id="处理冲突-collision"><a href="#处理冲突-collision" class="headerlink" title="处理冲突(collision)"></a>处理冲突(collision)</h2><p>上文提到的均匀的哈希函数可以减少冲突，但不能避免，因此如何处理冲突时哈希造表不可缺少的另一方面。通常用的处理方法如下：</p>
<ul>
<li><strong>开放地址法</strong><script type="math/tex; mode=display">H_{i}=\left ( H\left ( key \right )+d_{i} \right )MOD\left ( m \right ),i=1,2,...,k\left ( k\leq m-1 \right )</script>其中：$H\left ( key \right )$为哈希函数；$m$为哈希表表长；$d_{i}$为增量序列，有下列三种取法：<ol>
<li>$d_{i}=1,2,3,…,m-1$称线性探测再散列；</li>
<li>$d_{i}=1^{2},-1^{2},2^{2},-2^{2},3^{2},…,\pm k^{2},\left (k\leq m/2 \right)$称二次探测再散列；</li>
<li>$d_{i}=伪随机数序列$，称伪随机探测再散列。</li>
</ol>
</li>
<li><strong>再哈希法</strong><script type="math/tex; mode=display">H_{i}=RH_{i}\left (key \right), i=1,2,...,k</script>$RH_{i}$均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不在发生。这种方法不易产生“聚集”，但增加了计算的时间。</li>
<li><strong>链地址法</strong><br>将所有关键字为同义词的记录存储在同一线性链表中。假设某哈希函数产生的哈希地址在区间$\left [ 0,m-1 \right ]$上，则设立一个指针型向量<script type="math/tex; mode=display">ChainHash\left [m \right]</script>其每个分量的初始状态都是空指针。凡哈希地址为$i$的记录都插入到头指针为$ChainHash\left [i \right]$的链表中。在链表中的插入位置可以在表头或表尾；也可在中间，以保持同义词在同一线性链表中按关键字有序。</li>
<li><strong>建立公共溢出区</strong><br>假设哈希函数的值域为$\left [0,m-1 \right]$，则设向量$HashTable\left [0..m-1 \right]$为基本表，每个分量存放一个记录，另设立向量$OverTable\left [0..v \right]$为溢出表。所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</li>
</ul>
<h2 id="哈希表应用算法案例"><a href="#哈希表应用算法案例" class="headerlink" title="哈希表应用算法案例"></a>哈希表应用算法案例</h2><h3 id="两数之和-2-Sum"><a href="#两数之和-2-Sum" class="headerlink" title="两数之和(2 Sum)"></a>两数之和(2 Sum)</h3><p><strong>问题描述</strong>：</p>
<blockquote>
<p>输入一个数组<code>nums</code>和一个数<code>target</code>，返回数组<code>nums</code>中两个数的和为<code>target</code>的这两个数的下标(index),下标从1开始。例子：<br><code>nums = [2, 7, 11, 15]</code>, <code>target = [9]</code><br>返回<code>[1, 2]</code></p>
</blockquote>
<p><strong>问题分析</strong>：<br>有两个输入：<code>nums</code>和<code>target</code>，一个输出：<code>两个下标</code>，目的是找到两个数之和等于<code>target</code>。显而易见的一种方法是写两个for循环嵌套：外部循环从数组的第一个元素开始向后遍历作为第一个数<code>nums[i]</code>，内部循环从第一个数的下一个数<code>nums[i+1]</code>开始向后遍历，判断两个数之和是否等于<code>target</code>，找到后返回两个下标即可。不过这样做有明显的缺点：两个循环的算法时间复杂度为$O\left (n*(n-1)\right)$，那么如果<code>nums</code>中有9个元素，最多会遍历9x8=72次，对于更大的<code>nums</code>遍历次数将更多。所以我们来“算算”怎么简化算法。</p>
<p><strong>解决方案</strong>：<br>我们设找到的两个数中第一个为$x_{i}$，第二个数为$x_{j}$，进行运算：</p>
<script type="math/tex; mode=display">x_{i}+x_{j}=target\tag{1}</script><script type="math/tex; mode=display">x_{j}=target-x_{i}\tag{2}</script><p>进行上述的运算后可以发现等式(1)中的左边部分有两个未知数，而等式右边只有一个未知数，于是我们可以得到一个下标$i$到$j$的映射：$f\left (i\right)=j$，从而我们可以利用等式(2)来重新构造我们的for循环，即使用一次for循环。<br><strong>程序实现</strong>：<br>用python来实现这个算法，其中python中的字典可以作为很好的哈希映射。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_num</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    solve the problem 2 sum</span></span><br><span class="line"><span class="string">    :param nums: the set of some numbers</span></span><br><span class="line"><span class="string">    :param target: the sum of two numbers</span></span><br><span class="line"><span class="string">    :return: the index of two numbers</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    hash_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ind, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> (target - val) <span class="keyword">in</span> hash_map:</span><br><span class="line">            <span class="keyword">return</span> hash_map[target - val]+<span class="number">1</span>, ind+<span class="number">1</span></span><br><span class="line">        hash_map[val] = ind</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans = two_num([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], <span class="number">9</span>)</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>
<p>输出：<code>(1, 2)</code><br><strong>代码分析</strong>：<br>分析代码可知，首先创建一个空的字典，该字典用来实现哈希映射，接着我们对数组的每一个元素进行迭代，获取元素的下标和元素值，接着进行判断：如果另一个元素在字典中，则返回另一个元素在字典中的值和当前元素的下标。<br>否则，更新字典，把元素作为字典的键（这样就不必担心重复的元素），把元素的下标作为值，然后继续循环。回过头来可以发现我们最终返回的就是两个数的下标值。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>由上述案例可知哈希思想作为数据结构的应用带来的算法效能提升，在平时的算法编写中应考虑到时间和空间上的条件，利用数据结构的知识来不断优化算法。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统:存储管理算法(python实现)</title>
    <url>/2019/11/10/memory-alloc/</url>
    <content><![CDATA[<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>该分配方式为用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址<strong>相邻</strong>，体现在内存空间分配是物理地址的<strong>相邻</strong>。连续分配方式可分为四类：</p><a id="more"></a>
<ul>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li><strong>动态分区分配</strong></li>
<li>动态可重定向分配</li>
</ul>
<p>本文仅重点介绍<strong>动态分区分配算法</strong></p>
<h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>动态分区分配又称为可变分区分配，它是根据进程的实际需要，动态地为之分配内存空间。</p>
<h3 id="动态分区分配中的数据结构"><a href="#动态分区分配中的数据结构" class="headerlink" title="动态分区分配中的数据结构"></a>动态分区分配中的数据结构</h3><p>为了实现动态分区分配，系统中必须配置相应的数据结构，用以描述空闲分区和已分配分区的情况，为分配提供依据。常用的数据结构有以下两种形式：</p>
<ol>
<li>空闲分区表。在系统中设置一张空闲分区表，用于记录每个空闲的情况。每个空闲分区占一个表目(行)，表目中包括分区号、分区大小和分区始址等数据项，如下图所示<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_1.png" alt="空闲分区表"></li>
<li><strong>空闲分区链</strong>。为了实现对空闲分区的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接空闲分区的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。为了检索方便，在分区尾部重复设置状态位和分区大小表目。当分区被分配出去以后，把状态位由“0”改为“1”，此时，前、后向指针已无意义。如下图所示<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_2.png" alt="空闲分区链"></li>
</ol>
<p>本文主要针对空闲分区链编写python代码</p>
<h3 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h3><p>在动态分区存储管理方式中，主要的操作是分配内存和回收内存</p>
<ul>
<li>分配内存：系统利用某种<strong>分配算法</strong>，从空闲分区链中找到所需大小的分区。设请求的分区大小为apply.size，表中每个空闲分区的大小表示为part.size。若part.size - apply.size &lt;= min_size(min_size是事先规定的最小剩余)，说明多余的部分太小，可不分割，将整个分区分配个请求者。否则(即多余的部分超过min_size)，说明剩下了很多，便可从该分区中按请求的大小划分出一块内存空间出去，余下的部分仍留在空闲分区链(表)中。最后将分配区的 <strong>首址(address)</strong> 返回给调用者。流程如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_3.png" alt="分配内存"></li>
<li>回收内存：当进程运行完毕释放内存时，系统根据回收区的首址，从空闲链(表)中找到相应的插入点，此时可能出现以下四种情况之一：<ol>
<li>回收区与插入点前一个空闲分区$F_{1}$相邻接。此时应将回收区与$F_{1}$合并。<strong>不必创建新表项</strong>，只需修改其前一分区$F_{1}$的大小。</li>
<li>回收分区与插入点的后一空闲分区$F_{2}$相邻接。此时也将两分区合并。<strong>但回收区的首址作为新空闲区的首址</strong>。</li>
<li>回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，<strong>使用前一个分区的表项和首址，取消后一个分区的表项</strong>。</li>
<li>回收区既与前后两个分区都不邻接。<strong>此时为回收区单独建立一个新表项</strong>，首址和大小分别为回收区的首址和大小。<br>内存回收的流程如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_4.png" alt="回收内存"></li>
</ol>
</li>
</ul>
<h2 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h2><p>为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。所谓顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。基于顺序搜索的动态分区分配算法有如下四种（以下算法讲解皆是基于空闲分区链）：</p>
<ul>
<li><strong>首次适应(first fit, FF)算法</strong>：FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。</li>
<li>循环首次适应(next fit, NF)算法：NF算法不再是每次都从链首开始查找，而是从上一次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区。</li>
<li>最佳适应(best fit, BF)算法：BF算法要求每次为作业分配内存时，总是把能满足要求、又是最小的空间分区分配给作业。同时，为了加速寻找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。</li>
<li>最坏适应(worst fit, WF)算法：WF算法与BF算法相反：它在扫描整个空闲分区链时，总是挑选出一个最大的空闲区，以至于存储器中缺乏大的空闲分区</li>
</ul>
<h3 id="首次适应算法实现"><a href="#首次适应算法实现" class="headerlink" title="首次适应算法实现"></a>首次适应算法实现</h3><p>分析操作系统的内存管理流程后大致可把算法分为以下几个步骤：</p>
<ul>
<li>初始化空闲分区链</li>
<li>发出内存请求</li>
<li>使用算法(FF)分配内存</li>
<li>回收内存</li>
</ul>
<p>用python实现该算法代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionNode</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    a node of idle partition chain</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, loc)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize the node</span></span><br><span class="line"><span class="string">        :param size: the size of this partition</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.prior = <span class="literal">None</span>  <span class="comment"># the prior of this partition</span></span><br><span class="line">        self.part_size = size</span><br><span class="line">        self.loc = loc     <span class="comment"># the begin location of this partition</span></span><br><span class="line">        self.status = <span class="number">0</span>    <span class="comment"># the distribution status of this partition</span></span><br><span class="line">        self.next = <span class="literal">None</span>   <span class="comment"># the next of this partition</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionChain</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize a free partition chain</span></span><br><span class="line"><span class="string">        :param num:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.partition_chain = PartitionNode(np.random.randint(<span class="number">50</span>, <span class="number">151</span>), <span class="number">0</span>)  <span class="comment"># create the head node</span></span><br><span class="line">        self.num = num  <span class="comment"># the number of the partition</span></span><br><span class="line">        self.size = self.partition_chain.part_size</span><br><span class="line">        self.free = <span class="number">0</span>   <span class="comment"># the free space of the partition</span></span><br><span class="line">        self.__init_chain()  <span class="comment"># initialize the partition chain</span></span><br><span class="line">        self.min_remain = <span class="number">25</span>  <span class="comment"># the minimum size of split</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_chain</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize the partition charin</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> range(<span class="number">1</span>, self.num):</span><br><span class="line">            tmp.next = PartitionNode(np.random.randint(<span class="number">50</span>, <span class="number">151</span>), self.size)  <span class="comment"># create the next node</span></span><br><span class="line">            self.size += tmp.next.part_size</span><br><span class="line">            tmp.next.prior = tmp  <span class="comment"># point to the prior node</span></span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        self.free = self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_chain</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        print the infomation of partition chain</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        self.free = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            self.free += tmp.part_size</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        print(<span class="string">"空闲分区链(分区数-%d 大小-%d 空闲-%d):"</span> % (self.num, self.size, self.free), end=<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> tmp.next:</span><br><span class="line">                print(<span class="string">"&lt;AT-%d, S-%d&gt;"</span> % (tmp.loc, tmp.part_size), end=<span class="string">'···'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"&lt;AT-%d, S-%d&gt;"</span> % (tmp.loc, tmp.part_size))</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alloc_memory</span><span class="params">(self, method, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the algorithm of allocate memory</span></span><br><span class="line"><span class="string">        :param method: first fit, next fit, best fit, worst fit</span></span><br><span class="line"><span class="string">        :param m: the memory of application</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">'**需求**:'</span>, m)</span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">'first'</span>:</span><br><span class="line">            tmp = self.partition_chain</span><br><span class="line">            <span class="keyword">while</span> tmp:</span><br><span class="line">                <span class="keyword">if</span> m &lt;= tmp.part_size <span class="keyword">and</span> tmp.status == <span class="number">0</span>:  <span class="comment"># 按顺序找到第一个能满足要求的空闲分区</span></span><br><span class="line">                    <span class="keyword">if</span> tmp.part_size - m &lt;= self.min_remain:  <span class="comment"># 划分后剩余的大小过小，则分出整个分区，并调整分区链结构</span></span><br><span class="line">                        self.num -= <span class="number">1</span>  <span class="comment"># 长度减一</span></span><br><span class="line">                        <span class="keyword">if</span> tmp.prior <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 如果是表头</span></span><br><span class="line">                            self.partition_chain = tmp.next</span><br><span class="line">                            self.partition_chain.prior = <span class="literal">None</span></span><br><span class="line">                        <span class="keyword">elif</span> tmp.next <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果是表尾</span></span><br><span class="line">                            tmp.prior.next = <span class="literal">None</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            tmp.next.prior = tmp.prior</span><br><span class="line">                            tmp.prior.next = tmp.next</span><br><span class="line">                        print(<span class="string">"**Info**: 分配成功^_^, 地址-%d 大小-%d"</span> % (tmp.loc, tmp.part_size))</span><br><span class="line">                        <span class="keyword">return</span> &#123;<span class="string">'Address'</span>: tmp.loc, <span class="string">'Size'</span>: tmp.part_size&#125;</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tmp.part_size -= m</span><br><span class="line">                        print(<span class="string">"**Info**: 分配成功^_^, 地址-%d 大小-%d"</span> % (tmp.loc, m))</span><br><span class="line">                        <span class="keyword">return</span> &#123;<span class="string">'Address'</span>: tmp.loc, <span class="string">'Size'</span>: m&#125;  <span class="comment"># 返回分配区的首地址</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp = tmp.next</span><br><span class="line">            print(<span class="string">'**Info**: 分配失败x_x'</span>)</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">'next'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">'best'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">'fit'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dealloc_memory</span><span class="params">(self, m_dict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        recycle the memeory</span></span><br><span class="line"><span class="string">        :param m_dict: the dict of deallocated memory</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"**Info**: 回收失败x_x"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        loc = m_dict.get(<span class="string">'Address'</span>)</span><br><span class="line">        size = m_dict.get(<span class="string">'Size'</span>)</span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> tmp.prior <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 表头分区</span></span><br><span class="line">                <span class="keyword">if</span> loc &lt;= tmp.loc:</span><br><span class="line">                    <span class="keyword">if</span> loc == tmp.loc:  <span class="comment"># 同一分区</span></span><br><span class="line">                        tmp.part_size += size</span><br><span class="line">                    <span class="keyword">else</span>:  <span class="comment"># 与表头分区不邻接，自己作为表头分区</span></span><br><span class="line">                        new_part = PartitionNode(size, loc)</span><br><span class="line">                        new_part.next = tmp</span><br><span class="line">                        tmp.prior = new_part</span><br><span class="line">                        self.partition_chain = new_part</span><br><span class="line">                        self.num += <span class="number">1</span></span><br><span class="line">                    print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> (tmp.next <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">and</span> (loc &gt;= tmp.loc):  <span class="comment"># 表尾分区, 且在表尾之后</span></span><br><span class="line">                <span class="keyword">if</span> tmp.loc == loc:  <span class="comment"># 与表尾分区邻接，表尾分区在前</span></span><br><span class="line">                    tmp.part_size += size</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 与表尾分区不邻接，自己作为表尾分区</span></span><br><span class="line">                    new_part = PartitionNode(size, loc)</span><br><span class="line">                    tmp.next = new_part</span><br><span class="line">                    new_part.prior = tmp</span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 表中分区，前后皆有分区存在</span></span><br><span class="line">                <span class="keyword">if</span> loc &lt;= tmp.loc:</span><br><span class="line">                    <span class="keyword">if</span> ((loc + size) == tmp.loc) | (loc == tmp.loc):</span><br><span class="line">                        <span class="keyword">if</span> loc == tmp.loc:  <span class="comment"># 同一分区</span></span><br><span class="line">                            tmp.part_size += size</span><br><span class="line">                        <span class="keyword">elif</span> (tmp.prior.loc + tmp.prior.part_size) == loc:  <span class="comment"># 1.同时与前面和后面的分区邻接</span></span><br><span class="line">                            next_part = tmp.next</span><br><span class="line">                            <span class="keyword">if</span> next_part:  <span class="comment"># 如果是不是表尾分区</span></span><br><span class="line">                                next_part.prior = tmp.prior</span><br><span class="line">                            tmp.prior.part_size += size + tmp.part_size</span><br><span class="line">                            tmp.prior.next = next_part</span><br><span class="line">                        <span class="keyword">else</span>:  <span class="comment"># 2.只与后面的分区邻接</span></span><br><span class="line">                            tmp.part_size += size</span><br><span class="line">                        print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> loc == tmp.prior.loc:</span><br><span class="line">                            tmp.prior.part_size += size</span><br><span class="line">                        <span class="keyword">elif</span> (tmp.prior.loc + tmp.prior.part_size) == loc:  <span class="comment"># 3.只与前面的分区邻接</span></span><br><span class="line">                            tmp.prior.part_size += size</span><br><span class="line">                        <span class="keyword">else</span>:  <span class="comment"># 4.与前面和后面的都不邻接</span></span><br><span class="line">                            new_part = PartitionNode(size, loc)</span><br><span class="line">                            new_part.next = tmp</span><br><span class="line">                            new_part.prior = tmp.prior</span><br><span class="line">                            tmp.prior.next = new_part</span><br><span class="line">                            tmp.prior = new_part</span><br><span class="line">                            self.num += <span class="number">1</span></span><br><span class="line">                        print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    my_chain = PartitionChain(<span class="number">5</span>)</span><br><span class="line">    my_chain.print_chain()</span><br><span class="line">    my_apply = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 请求内存</span></span><br><span class="line">        rnd = np.random.randint(<span class="number">80</span>, <span class="number">130</span>)</span><br><span class="line">        my_apply.append(my_chain.alloc_memory(<span class="string">'first'</span>, rnd))</span><br><span class="line">    my_chain.print_chain()</span><br><span class="line">    print(<span class="string">'已经请求的分区:'</span>, my_apply)</span><br><span class="line">    <span class="keyword">for</span> applys <span class="keyword">in</span> my_apply:</span><br><span class="line">        my_chain.dealloc_memory(applys)</span><br><span class="line">    my_chain.print_chain()</span><br></pre></td></tr></table></figure>
<p>运行示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">空闲分区链(分区数-5 大小-484 空闲-484): &lt;AT-0, S-126&gt;···&lt;AT-126, S-132&gt;···&lt;AT-258, S-50&gt;···&lt;AT-308, S-68&gt;···&lt;AT-376, S-108&gt;</span><br><span class="line">**需求**: 118</span><br><span class="line">**Info**: 分配成功^_^, 地址-0 大小-126</span><br><span class="line">**需求**: 86</span><br><span class="line">**Info**: 分配成功^_^, 地址-126 大小-86</span><br><span class="line">**需求**: 82</span><br><span class="line">**Info**: 分配成功^_^, 地址-376 大小-82</span><br><span class="line">空闲分区链(分区数-4 大小-484 空闲-190): &lt;AT-126, S-46&gt;···&lt;AT-258, S-50&gt;···&lt;AT-308, S-68&gt;···&lt;AT-376, S-26&gt;</span><br><span class="line">已经请求的分区: [&#123;&apos;Address&apos;: 0, &apos;Size&apos;: 126&#125;, &#123;&apos;Address&apos;: 126, &apos;Size&apos;: 86&#125;, &#123;&apos;Address&apos;: 376, &apos;Size&apos;: 82&#125;]</span><br><span class="line">**Info**: 大小:126 回收成功^_^</span><br><span class="line">**Info**: 大小:86 回收成功^_^</span><br><span class="line">**Info**: 大小:82 回收成功^_^</span><br><span class="line">空闲分区链(分区数-5 大小-484 空闲-484): &lt;AT-0, S-126&gt;···&lt;AT-126, S-132&gt;···&lt;AT-258, S-50&gt;···&lt;AT-308, S-68&gt;···&lt;AT-376, S-108&gt;</span><br></pre></td></tr></table></figure>
<p>如有不当指出，请多多指教。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>银行家算法(java实现)</title>
    <url>/2019/11/08/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>银行家算法是一种避免进程发生<strong>死锁</strong>的算法。</p><blockquote>
<p>死锁的定义：<br>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么改组进程是死锁的(Deadlock)<br>在死锁避免方法中，把系统的状态分为<strong>安全状态</strong>和<strong>不安全状态</strong>。<br>安全状态和不安全状态：<br>是指系统能按某种进程推进顺序<script type="math/tex">\left ( P_{1},P_{2}, ...,P_{n}\right )</script> 为每个进程<script type="math/tex">P_{i}</script>分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。并称<script type="math/tex">\left ( P_{1},P_{2}, ...,P_{n}\right )</script>为安全序列。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p>
</blockquote><a id="more"></a>

<h2 id="银行家算法中的数据结构"><a href="#银行家算法中的数据结构" class="headerlink" title="银行家算法中的数据结构"></a>银行家算法中的数据结构</h2><p>银行家算法中有四个数据结构：</p>
<ul>
<li>最大需求向量(Max)：是一个长度为m的数组，它定义了系统中每个进程对第m类资源的最大需求</li>
<li>已分配向量(Allocation)：是一个长度为m的数组，它定义了系统中每个进程对每一类资源分配给进程的资源数量。</li>
<li>需求向量(Need)：是一个长度为m的数组，用以表示进程还需要的各类资源数量</li>
<li>可利用资源向量(Available)：是一个长度为m的数组，其中每一个值代表可以当前可利用的资源数目。</li>
</ul>
<p>上述数据中有这样的关系：Need = Max - Allocation</p>
<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>史上最详细的步骤^_^</p>
<ul>
<li>【步骤一】创建进程数组PCB[n] (代表n个进程)</li>
<li>【步骤二】输入并初始化每个进程PCB[i]的Max数组、Allocation数组</li>
<li>【步骤三】利用Max数组和Allocation数组计算出Need数组</li>
<li>【步骤四】输入Available数组</li>
<li>【步骤五】为每个PCB添加完成状态变量Finish(0-未完成，1-完成)，得到Finish数组(全部初始化为0)</li>
<li>【步骤六】初始化表示安全状态变量Safe_Status = 0(0-不安全，1-安全)</li>
<li>【步骤七】循环进行资源分配：</li>
<li>WHILE(SUM(Finish) &lt; n):</li>
<li>Safe_Status = 0</li>
<li>FOR i =  1 TO n</li>
<li>IF PCB[i]中Need的每个值 &lt;= Avaliable的每个值 AND PCB[i].Finish == 0</li>
<li>PCB[i].Finish = 1</li>
<li>将该进程PCB[i]加入安全序列队列</li>
<li>Available = Available + PCB[i].Need</li>
<li>Safe_Status = 1</li>
<li>END IF</li>
<li>END FOR</li>
<li>IF Safe_Status == 0</li>
<li>BREAK</li>
<li>END IF</li>
<li>END WHILE</li>
<li>【步骤八】判断系统是否安全：</li>
<li>IF (SUM(Finish == n))</li>
<li>该系统安全</li>
<li>END IF</li>
<li>【步骤九】输出安全序列队列</li>
</ul>
<h2 id="用Java实现银行家算法"><a href="#用Java实现银行家算法" class="headerlink" title="用Java实现银行家算法"></a>用Java实现银行家算法</h2><h3 id="Proc-java"><a href="#Proc-java" class="headerlink" title="Proc.java"></a>Proc.java</h3><p>表示进程信息的进程类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proc</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name;</span><br><span class="line">	<span class="keyword">int</span> max_res[];</span><br><span class="line">	<span class="keyword">int</span> alloc_res[];</span><br><span class="line">	<span class="keyword">int</span> need_res[];</span><br><span class="line">	<span class="keyword">boolean</span> finish_status = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Proc</span><span class="params">(<span class="keyword">char</span> name , <span class="keyword">int</span> max[], <span class="keyword">int</span> alloc[], <span class="keyword">int</span> need[])</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.max_res = max;</span><br><span class="line">		<span class="keyword">this</span>.alloc_res = alloc;</span><br><span class="line">		<span class="keyword">this</span>.need_res = need;</span><br><span class="line">		<span class="keyword">this</span>.finish_status = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMax_res</span><span class="params">(<span class="keyword">int</span> max_res[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.max_res = max_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] getMax_res() &#123;</span><br><span class="line">		<span class="keyword">return</span> max_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlloc_res</span><span class="params">(<span class="keyword">int</span> alloc_res[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.alloc_res = alloc_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] getAlloc_res() &#123;</span><br><span class="line">		<span class="keyword">return</span> alloc_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNeed_res</span><span class="params">(<span class="keyword">int</span> need_res[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.need_res = need_res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] getNeed_res() &#123;</span><br><span class="line">		<span class="keyword">return</span> need_res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BankRR-java"><a href="#BankRR-java" class="headerlink" title="BankRR.java"></a>BankRR.java</h3><p>银行家算法和程序入口所在的类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankRR</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pcb_nums;  <span class="comment">// 进程数量</span></span><br><span class="line">	<span class="keyword">int</span> res_nums;  <span class="comment">// 资源种类数量</span></span><br><span class="line">	Proc pcbs[];   <span class="comment">// 进程数组</span></span><br><span class="line">	<span class="keyword">int</span> max[];     <span class="comment">// 最大需求资源向量</span></span><br><span class="line">	<span class="keyword">int</span> alloc[];   <span class="comment">// 拥有资源数向量</span></span><br><span class="line">	<span class="keyword">int</span> need[];    <span class="comment">// 还需要资源数向量</span></span><br><span class="line">	<span class="keyword">int</span> ava[];     <span class="comment">// 可用资源数向量</span></span><br><span class="line">	<span class="keyword">char</span> safe_seq[];  <span class="comment">// 安全序列数组</span></span><br><span class="line">	<span class="keyword">boolean</span> safe_stauts = <span class="keyword">false</span>;  <span class="comment">// 安全序列</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bank_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// A sample</span></span><br><span class="line">		<span class="comment">/*   Max   Alloc  Need   Avai</span></span><br><span class="line"><span class="comment">		 - a 7 5 3, 0 1 0, 7 4 3, 3 3 2</span></span><br><span class="line"><span class="comment">		 - b 3 2 2, 2 0 0, 1 2 2</span></span><br><span class="line"><span class="comment">		 - c 9 0 2, 3 0 2, 6 0 0</span></span><br><span class="line"><span class="comment">		 - d 2 2 2, 2 1 1, 0 1 1</span></span><br><span class="line"><span class="comment">		 - e 4 3 3, 0 0 2, 4 3 1</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"一共有几个进程："</span>);</span><br><span class="line">		pcb_nums = in.nextInt();</span><br><span class="line">		System.out.println(<span class="string">"一共有几个资源"</span>);</span><br><span class="line">		res_nums = in.nextInt();</span><br><span class="line">		pcbs = <span class="keyword">new</span> Proc[pcb_nums];  <span class="comment">// 创建进程数组</span></span><br><span class="line">		ava = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];     <span class="comment">// 可用资源</span></span><br><span class="line">		safe_seq = <span class="keyword">new</span> <span class="keyword">char</span>[pcb_nums];  <span class="comment">// 安全序列</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcbs.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			max = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];     <span class="comment">// 最大资源</span></span><br><span class="line">			alloc = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];   <span class="comment">// 拥有资源</span></span><br><span class="line">			need = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];    <span class="comment">// 需要资源</span></span><br><span class="line">			System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">			System.out.println(<span class="string">"输入第"</span> + (i+<span class="number">1</span>) + <span class="string">"个进程信息(名字-最大资源-拥有资源)"</span>);</span><br><span class="line">			System.out.println(<span class="string">"名字："</span>);</span><br><span class="line">			<span class="keyword">char</span> name = in.next().charAt(<span class="number">0</span>);</span><br><span class="line">			System.out.println(<span class="string">"最大资源："</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				max[j] = in.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"拥有资源："</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				alloc[j] = in.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				need[j] = max[j] - alloc[j];</span><br><span class="line">			&#125;</span><br><span class="line">			pcbs[i] = <span class="keyword">new</span> Proc(name, max, alloc, need);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"---可用资源---："</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ava[j] = in.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algori</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> safe_count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(safe_count != pcb_nums)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcb_nums; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pcbs[i].finish_status == <span class="keyword">false</span>) <span class="comment">// 判断该pcb是否完成</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">int</span> now_res = pcbs[i].getNeed_res()[j];</span><br><span class="line">						<span class="keyword">if</span> (now_res &lt;= ava[j])</span><br><span class="line">						&#123;</span><br><span class="line">							pcbs[i].finish_status = <span class="keyword">true</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							pcbs[i].finish_status = <span class="keyword">false</span>;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (pcbs[i].finish_status) <span class="comment">// 如果该pcb可以完成，则完成后回收资源</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">						&#123;</span><br><span class="line">							ava[j] += pcbs[i].getNeed_res()[j];</span><br><span class="line">						&#125;</span><br><span class="line">						safe_seq[safe_count] = pcbs[i].getName();</span><br><span class="line">						safe_count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcb_nums; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pcbs[i].finish_status)</span><br><span class="line">				&#123;</span><br><span class="line">					safe_stauts = <span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					safe_stauts = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!safe_stauts) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (safe_stauts) &#123;</span><br><span class="line">			System.out.println(<span class="string">"该系统安全，安全序列为："</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcb_nums; i++) &#123;</span><br><span class="line">				System.out.print(safe_seq[i]+<span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"该系统不安全"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		BankRR test = <span class="keyword">new</span> BankRR();</span><br><span class="line">		test.bank_init();</span><br><span class="line">		test.algori();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><p>进程样例如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/1.png" alt><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一共有几个进程：</span><br><span class="line">5</span><br><span class="line">一共有几个资源</span><br><span class="line">3</span><br><span class="line">-----------------------</span><br><span class="line">输入第1个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">a</span><br><span class="line">最大资源：</span><br><span class="line">7 5 3</span><br><span class="line">拥有资源：</span><br><span class="line">0 1 0</span><br><span class="line">-----------------------</span><br><span class="line">输入第2个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">b</span><br><span class="line">最大资源：</span><br><span class="line">3 2 2</span><br><span class="line">拥有资源：</span><br><span class="line">2 0 0</span><br><span class="line">-----------------------</span><br><span class="line">输入第3个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">c</span><br><span class="line">最大资源：</span><br><span class="line">9 0 2</span><br><span class="line">拥有资源：</span><br><span class="line">3 0 2</span><br><span class="line">-----------------------</span><br><span class="line">输入第4个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">d</span><br><span class="line">最大资源：</span><br><span class="line">2 2 2</span><br><span class="line">拥有资源：</span><br><span class="line">2 1 1</span><br><span class="line">-----------------------</span><br><span class="line">输入第5个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">e</span><br><span class="line">最大资源：</span><br><span class="line">4 3 3</span><br><span class="line">拥有资源：</span><br><span class="line">0 0 2</span><br><span class="line">---可用资源---：</span><br><span class="line">3 3 2</span><br><span class="line">该系统安全，安全序列为：</span><br><span class="line">b d e a c</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>进程死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>用python实现链式队列</title>
    <url>/2019/11/08/python%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列也是一种线性的数据结构，和栈相反的是，队列是一种<strong>先进先出</strong>的线性表。它只允许在表的一端进行插入，而在另一端进行删除元素。与我们现实生活中的排队是一样的：排在队伍最前面的会先完成事情离开队伍。<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%98%9F%E5%88%97/1_1.png" alt><br>在数据结构中抽象为一种<strong>线性链表</strong>，如下所示<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%98%9F%E5%88%97/1_2.png" alt></p><a id="more"></a>
<h2 id="链式队列基本数据结构"><a href="#链式队列基本数据结构" class="headerlink" title="链式队列基本数据结构"></a>链式队列基本数据结构</h2><p>链式队列即是链表构成，通过指针相连。实现过程如下</p>
<h3 id="链式队列基本单元-节点-Node"><a href="#链式队列基本单元-节点-Node" class="headerlink" title="链式队列基本单元: 节点(Node)"></a>链式队列基本单元: 节点(Node)</h3><p>创建<code>Node</code>类</p>
<ul>
<li>值域</li>
<li>指针域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param v: the value of node</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.value = v</span><br><span class="line">        self.pnext = None  # the pointer to point next</span><br></pre></td></tr></table></figure>
<h3 id="链式队列类"><a href="#链式队列类" class="headerlink" title="链式队列类"></a>链式队列类</h3><p>创建<code>LinkedQueue</code>类</p>
<ul>
<li>front: 队头节点</li>
<li>rear: 队尾节点</li>
<li>length: 队列长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LinkedQueue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.front = None  # the head node of queue</span><br><span class="line">        self.rear = None   # the rear node of queue</span><br><span class="line">        self.length = 0    # the length of queue</span><br></pre></td></tr></table></figure>
<h2 id="链式队列操作函数"><a href="#链式队列操作函数" class="headerlink" title="链式队列操作函数"></a>链式队列操作函数</h2><p><code>self</code>参数为对象本身，类似于C++中的<code>this</code>指针</p>
<h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><p>创建<code>queue_empty</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def queue_empty(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if the queue is empty</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.front is None:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p>
<h3 id="获取队首元素"><a href="#获取队首元素" class="headerlink" title="获取队首元素"></a>获取队首元素</h3><p>创建<code>get_head</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_head(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    get the value of head node</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return self.front.value</span><br></pre></td></tr></table></figure></p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>创建<code>enqueue</code>函数</p>
<ul>
<li>val: 节点值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def enqueue(self, val):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    insert value to queue&apos;s rear</span><br><span class="line">    :param val:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.queue_empty():</span><br><span class="line">        self.front = Node(val)</span><br><span class="line">        self.rear = self.front</span><br><span class="line">        self.length += 1</span><br><span class="line">    else:</span><br><span class="line">        self.rear.pnext = Node(val)</span><br><span class="line">        self.rear = self.rear.pnext</span><br><span class="line">        self.length += 1</span><br></pre></td></tr></table></figure>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>创建<code>dequeue</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dequeue(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    delete the value of head node and return its value</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not self.queue_empty():</span><br><span class="line">        val = self.front.value</span><br><span class="line">        self.front = self.front.pnext</span><br><span class="line">        self.length -= 1</span><br><span class="line">        return val</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历队列-队首-队尾"><a href="#遍历队列-队首-队尾" class="headerlink" title="遍历队列(队首-队尾)"></a>遍历队列(队首-队尾)</h3><p>创建<code>queue_traverse</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def queue_traverse(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    traverse the queue</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&apos;队头-&gt;|&apos;, end=&apos; &apos;)</span><br><span class="line">    tmp = self.front</span><br><span class="line">    while tmp:</span><br><span class="line">        print(tmp.value, &apos;|&apos;, end=&apos; &apos;)</span><br><span class="line">        tmp = tmp.pnext</span><br><span class="line">    print(&quot;\n&quot;)</span><br></pre></td></tr></table></figure></p>
<h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>创建程序入口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    my_queue = LinkedQueue()</span><br><span class="line">    my_queue.enqueue([1, 2, 3])</span><br><span class="line">    my_queue.enqueue(456)</span><br><span class="line">    my_queue.enqueue(&apos;hello&apos;)</span><br><span class="line">    my_queue.queue_traverse()</span><br><span class="line">    my_queue.dequeue()</span><br><span class="line">    my_queue.queue_traverse()</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队头-&gt;| [1, 2, 3] | 456 | hello |</span><br><span class="line"></span><br><span class="line">队头-&gt;| 456 | hello |</span><br></pre></td></tr></table></figure></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/SkecisAI/python-DS/blob/master/linked_queue.py" target="_blank" rel="noopener">点击此处访问</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>用python实现链式栈</title>
    <url>/2019/11/06/python-stack/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种线性的数据结构。栈的定义是：限定仅在表尾进行插入或删除操作的线性表(线性表的介绍参见我的另一篇<a href="https://skecis.top/2019/11/01/python%E9%93%BE%E8%A1%A8/#more" target="_blank" rel="noopener">博文</a>)。直观一点来看，如下图<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%A0%88/1.png" alt><br>即最后进栈的元素最先出来，又称为<strong>后进先出</strong>的线性表</p><a id="more"></a>
<h2 id="链式栈基本数据结构"><a href="#链式栈基本数据结构" class="headerlink" title="链式栈基本数据结构"></a>链式栈基本数据结构</h2><p>链式栈即是链式表构成的，通过指针相连。实现过程如下</p>
<h3 id="链式栈基本单元-节点-Node"><a href="#链式栈基本单元-节点-Node" class="headerlink" title="链式栈基本单元: 节点(Node)"></a>链式栈基本单元: 节点(Node)</h3><p>创建<code>Node</code>类</p>
<ul>
<li>值域</li>
<li>指针域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param v: the value of node</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.value = v</span><br><span class="line">        self.pnext = None  # the pointer to point next</span><br></pre></td></tr></table></figure>
<h3 id="链式栈类"><a href="#链式栈类" class="headerlink" title="链式栈类"></a>链式栈类</h3><p>创建<code>LinkedStack</code>类</p>
<ul>
<li>top: 栈顶节点</li>
<li>bottom: 栈底节点</li>
<li>length: 栈长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LinkedStack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.top = None  # the top node</span><br><span class="line">        self.bottom = None  # the bottom node</span><br><span class="line">        self.length = 0  # the length of this stack</span><br></pre></td></tr></table></figure>
<h2 id="链式栈操作函数"><a href="#链式栈操作函数" class="headerlink" title="链式栈操作函数"></a>链式栈操作函数</h2><p><code>self</code>参数为对象本身，类似于C++中的<code>this</code>指针</p>
<h3 id="压栈"><a href="#压栈" class="headerlink" title="压栈"></a>压栈</h3><p>创建<code>push</code>函数</p>
<ul>
<li>val: 节点值域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def push(self, val):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    add a value to stack</span><br><span class="line">    :param val: the value</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not self.stack_empty():</span><br><span class="line">        self.top.pnext = Node(val)</span><br><span class="line">        self.top = self.top.pnext</span><br><span class="line">        self.length += 1</span><br><span class="line">    else:</span><br><span class="line">        self.top = Node(val)</span><br><span class="line">        self.bottom = self.top</span><br><span class="line">        self.length += 1</span><br></pre></td></tr></table></figure>
<h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><p>创建<code>pop</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def pop(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    delete the node at the top and return its value</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    tmp_top = self.top</span><br><span class="line">    tmp_bottom = self.bottom</span><br><span class="line">    for i in range(1, self.length+1):</span><br><span class="line">        if i == self.length - 1:</span><br><span class="line">            self.top = tmp_bottom</span><br><span class="line">            self.top.pnext = None</span><br><span class="line">            self.length -= 1</span><br><span class="line">        else:</span><br><span class="line">            tmp_bottom = tmp_bottom.pnext</span><br><span class="line">    return tmp_top.value</span><br></pre></td></tr></table></figure></p>
<h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><p>创建<code>stack_empty</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def stack_empty(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if the stack is empty</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.top is None:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p>
<h3 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><p>创建<code>get_top</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_top(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return the value of top</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return self.top.value</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历栈-栈底-栈顶"><a href="#遍历栈-栈底-栈顶" class="headerlink" title="遍历栈(栈底-栈顶)"></a>遍历栈(栈底-栈顶)</h3><p>创建<code>stack_traverse</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def stack_traverse(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    traverse the stack</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    tmp = self.bottom</span><br><span class="line">    tmp_list = []</span><br><span class="line">    while tmp:</span><br><span class="line">        tmp_list.append(tmp.value)</span><br><span class="line">        tmp = tmp.pnext</span><br><span class="line">    tmp_list = tmp_list[::-1]</span><br><span class="line">    print(&quot;\n-----栈顶-----&quot;)</span><br><span class="line">    for val in tmp_list:</span><br><span class="line">        print(val)</span><br><span class="line">    print(&quot;--------------\n&quot;)</span><br></pre></td></tr></table></figure></p>
<h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>创建程序入口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    my_stack = LinkedStack()</span><br><span class="line">    my_stack.push([&apos;start&apos;])</span><br><span class="line">    my_stack.push(12)</span><br><span class="line">    my_stack.push(2323)</span><br><span class="line">    my_stack.push([&apos;end&apos;])</span><br><span class="line">    my_stack.stack_traverse()</span><br><span class="line">    print(my_stack.pop())</span><br><span class="line">    my_stack.stack_traverse()</span><br><span class="line">    print(my_stack.length)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-----栈顶-----</span><br><span class="line">[&apos;end&apos;]</span><br><span class="line">2323</span><br><span class="line">12</span><br><span class="line">[&apos;start&apos;]</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line">[&apos;end&apos;]</span><br><span class="line"></span><br><span class="line">-----栈顶-----</span><br><span class="line">2323</span><br><span class="line">12</span><br><span class="line">[&apos;start&apos;]</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/SkecisAI/python-DS/blob/master/linked_stack.py" target="_blank" rel="noopener">点击此处访问</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas数据操作：分组和聚合</title>
    <url>/2019/11/06/pandas-groupby/</url>
    <content><![CDATA[<h2 id="导入必要的库"><a href="#导入必要的库" class="headerlink" title="导入必要的库"></a>导入必要的库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure><h2 id="导入数据集"><a href="#导入数据集" class="headerlink" title="导入数据集"></a>导入数据集</h2><p>我下载了seaborn中的<a href="https://github.com/mwaskom/seaborn-data" target="_blank" rel="noopener">数据集</a>(都是小型的数据集)，选择了其中的航班数据集<code>flight.csv</code>，并放入了本地seaborn_dataset文件夹(该文件夹放在项目根目录)中<br>导入flight数据集(使用<code>read_csv</code>函数)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flight_df = pd.read_csv(&apos;seaborn_dataset/flights.csv&apos;)</span><br></pre></td></tr></table></figure></p><a id="more"></a>

<p>粗略看看该数据集(使用<code>head</code>函数)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(flight_df.head())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   year     month  passengers</span><br><span class="line">0  1949   January         112</span><br><span class="line">1  1949  February         118</span><br><span class="line">2  1949     March         132</span><br><span class="line">3  1949     April         129</span><br><span class="line">4  1949       May         121</span><br></pre></td></tr></table></figure></p>
<p>再看看数据类型(使用<code>info</code>函数)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(flight_df.info())</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;</span><br><span class="line">RangeIndex: 144 entries, 0 to 143</span><br><span class="line">Data columns (total 3 columns):</span><br><span class="line">year          144 non-null int64</span><br><span class="line">month         144 non-null object</span><br><span class="line">passengers    144 non-null int64</span><br><span class="line">dtypes: int64(2), object(1)</span><br><span class="line">memory usage: 3.5+ KB</span><br><span class="line">None</span><br></pre></td></tr></table></figure></p>
<p>注意其中的<code>year</code>和<code>passengers</code>为int型数据</p>
<h2 id="根据单个column的值分组"><a href="#根据单个column的值分组" class="headerlink" title="根据单个column的值分组"></a>根据单个column的值分组</h2><h3 id="使用groupby函数"><a href="#使用groupby函数" class="headerlink" title="使用groupby函数"></a>使用<code>groupby</code>函数</h3><p>参数为column名，可代入单个column名，或column名组成的列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grouped = flight_df.groupby(&apos;year&apos;)</span><br><span class="line">print(grouped)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002783D62D860&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看到返回的是一个pandas的<strong>分组对象</strong><code>DataFrameGroupBy</code>(或者<code>SeriesGroupBy</code>)</p>
<h3 id="获取分组数量"><a href="#获取分组数量" class="headerlink" title="获取分组数量"></a>获取分组数量</h3><p>使用分组对象的<code>ngroups</code>属性，类型为一个int型数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.ngroups)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure></p>
<h3 id="获取分组内容"><a href="#获取分组内容" class="headerlink" title="获取分组内容"></a>获取分组内容</h3><p>利用分组对象的<code>groups</code>属性，类型为一个字典(dict)，字典的键(key)为组名，值(value)为每一组所有的对应的索引(index)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.groups)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1949: Int64Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], dtype=&apos;int64&apos;), 1950: Int64Index([12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], dtype=&apos;int64&apos;), 1951: Int64Index([24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35], dtype=&apos;int64&apos;), 1952: Int64Index([36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], dtype=&apos;int64&apos;), 1953: Int64Index([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59], dtype=&apos;int64&apos;), 1954: Int64Index([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71], dtype=&apos;int64&apos;), 1955: Int64Index([72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83], dtype=&apos;int64&apos;), 1956: Int64Index([84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95], dtype=&apos;int64&apos;), 1957: Int64Index([96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107], dtype=&apos;int64&apos;), 1958: Int64Index([108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119], dtype=&apos;int64&apos;), 1959: Int64Index([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131], dtype=&apos;int64&apos;), 1960: Int64Index([132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143], dtype=&apos;int64&apos;)&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="访问分组结果"><a href="#访问分组结果" class="headerlink" title="访问分组结果"></a>访问分组结果</h2><h3 id="输出每个组的细节"><a href="#输出每个组的细节" class="headerlink" title="输出每个组的细节"></a>输出每个组的细节</h3><p>编写一个有利于输出分组内容的函数(function)，并调用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_groups(group_object):</span><br><span class="line">    for name, group in group_object:</span><br><span class="line">        print(name)</span><br><span class="line">        print(group)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_groups(grouped)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1949</span><br><span class="line">    year      month  passengers</span><br><span class="line">0   1949    January         112</span><br><span class="line">1   1949   February         118</span><br><span class="line">2   1949      March         132</span><br><span class="line">3   1949      April         129</span><br><span class="line">4   1949        May         121</span><br><span class="line">5   1949       June         135</span><br><span class="line">6   1949       July         148</span><br><span class="line">7   1949     August         148</span><br><span class="line">8   1949  September         136</span><br><span class="line">9   1949    October         119</span><br><span class="line">10  1949   November         104</span><br><span class="line">11  1949   December         118</span><br><span class="line">1950</span><br><span class="line">    year      month  passengers</span><br><span class="line">12  1950    January         115</span><br><span class="line">13  1950   February         126</span><br><span class="line">14  1950      March         141</span><br><span class="line">15  1950      April         135</span><br><span class="line">16  1950        May         125</span><br><span class="line">17  1950       June         149</span><br><span class="line">18  1950       July         170</span><br><span class="line">19  1950     August         170</span><br><span class="line">20  1950  September         158</span><br><span class="line">21  1950    October         133</span><br><span class="line">22  1950   November         114</span><br><span class="line">23  1950   December         140</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">1960</span><br><span class="line">     year      month  passengers</span><br><span class="line">132  1960    January         417</span><br><span class="line">133  1960   February         391</span><br><span class="line">134  1960      March         419</span><br><span class="line">135  1960      April         461</span><br><span class="line">136  1960        May         472</span><br><span class="line">137  1960       June         535</span><br><span class="line">138  1960       July         622</span><br><span class="line">139  1960     August         606</span><br><span class="line">140  1960  September         508</span><br><span class="line">141  1960    October         461</span><br><span class="line">142  1960   November         390</span><br><span class="line">143  1960   December         432</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组元素的数量"><a href="#获取每个组元素的数量" class="headerlink" title="获取每个组元素的数量"></a>获取每个组元素的数量</h3><p>使用<code>size</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(gruoped.size())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">year</span><br><span class="line">1949    12</span><br><span class="line">1950    12</span><br><span class="line">1951    12</span><br><span class="line">1952    12</span><br><span class="line">1953    12</span><br><span class="line">1954    12</span><br><span class="line">1955    12</span><br><span class="line">1956    12</span><br><span class="line">1957    12</span><br><span class="line">1958    12</span><br><span class="line">1959    12</span><br><span class="line">1960    12</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组中每个column的元素数量"><a href="#获取每个组中每个column的元素数量" class="headerlink" title="获取每个组中每个column的元素数量"></a>获取每个组中每个column的元素数量</h3><p>使用<code>count</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.count())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      month  passengers</span><br><span class="line">year</span><br><span class="line">1949     12          12</span><br><span class="line">1950     12          12</span><br><span class="line">1951     12          12</span><br><span class="line">1952     12          12</span><br><span class="line">1953     12          12</span><br><span class="line">1954     12          12</span><br><span class="line">1955     12          12</span><br><span class="line">1956     12          12</span><br><span class="line">1957     12          12</span><br><span class="line">1958     12          12</span><br><span class="line">1959     12          12</span><br><span class="line">1960     12          12</span><br></pre></td></tr></table></figure></p>
<h3 id="获取指定组名的组的数据"><a href="#获取指定组名的组的数据" class="headerlink" title="获取指定组名的组的数据"></a>获取指定组名的组的数据</h3><p>使用<code>get_group</code>函数，参数为组的名字。因为这里的<code>year</code>是整型数据，故代入整数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.get_group(1950))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    year      month  passengers</span><br><span class="line">12  1950    January         115</span><br><span class="line">13  1950   February         126</span><br><span class="line">14  1950      March         141</span><br><span class="line">15  1950      April         135</span><br><span class="line">16  1950        May         125</span><br><span class="line">17  1950       June         149</span><br><span class="line">18  1950       July         170</span><br><span class="line">19  1950     August         170</span><br><span class="line">20  1950  September         158</span><br><span class="line">21  1950    October         133</span><br><span class="line">22  1950   November         114</span><br><span class="line">23  1950   December         140</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组中前两个个元素"><a href="#获取每个组中前两个个元素" class="headerlink" title="获取每个组中前两个个元素"></a>获取每个组中前两个个元素</h3><p>使用<code>head</code>函数，参数为元素数量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.head(2))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     year     month  passengers</span><br><span class="line">0    1949   January         112</span><br><span class="line">1    1949  February         118</span><br><span class="line">12   1950   January         115</span><br><span class="line">13   1950  February         126</span><br><span class="line">24   1951   January         145</span><br><span class="line">25   1951  February         150</span><br><span class="line">36   1952   January         171</span><br><span class="line">37   1952  February         180</span><br><span class="line">48   1953   January         196</span><br><span class="line">49   1953  February         196</span><br><span class="line">60   1954   January         204</span><br><span class="line">61   1954  February         188</span><br><span class="line">72   1955   January         242</span><br><span class="line">73   1955  February         233</span><br><span class="line">84   1956   January         284</span><br><span class="line">85   1956  February         277</span><br><span class="line">96   1957   January         315</span><br><span class="line">97   1957  February         301</span><br><span class="line">108  1958   January         340</span><br><span class="line">109  1958  February         318</span><br><span class="line">120  1959   January         360</span><br><span class="line">121  1959  February         342</span><br><span class="line">132  1960   January         417</span><br><span class="line">133  1960  February         391</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组的第3行数据"><a href="#获取每个组的第3行数据" class="headerlink" title="获取每个组的第3行数据"></a>获取每个组的第3行数据</h3><p>使用<code>nth</code>函数，参数为行号<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(grouped.nth(3))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      month  passengers</span><br><span class="line">year</span><br><span class="line">1949  April         129</span><br><span class="line">1950  April         135</span><br><span class="line">1951  April         163</span><br><span class="line">1952  April         181</span><br><span class="line">1953  April         235</span><br><span class="line">1954  April         227</span><br><span class="line">1955  April         269</span><br><span class="line">1956  April         313</span><br><span class="line">1957  April         348</span><br><span class="line">1958  April         348</span><br><span class="line">1959  April         396</span><br><span class="line">1960  April         461</span><br></pre></td></tr></table></figure></p>
<h3 id="根据多个column分组"><a href="#根据多个column分组" class="headerlink" title="根据多个column分组*"></a>根据多个column分组*</h3><p>根据两个column分组，传入column名字列表(list)。并用前面的<code>print_groups</code>函数打印组信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mcg = flight_df.groupby([&apos;year&apos;, &apos;month&apos;])</span><br><span class="line">print_groups(mcg)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1949, &apos;April&apos;)</span><br><span class="line">   year  month  passengers</span><br><span class="line">3  1949  April         129</span><br><span class="line">(1949, &apos;August&apos;)</span><br><span class="line">   year   month  passengers</span><br><span class="line">7  1949  August         148</span><br><span class="line">(1949, &apos;December&apos;)</span><br><span class="line">    year     month  passengers</span><br><span class="line">11  1949  December         118</span><br><span class="line">(1949, &apos;February&apos;)</span><br><span class="line">   year     month  passengers</span><br><span class="line">1  1949  February         118</span><br><span class="line">(1949, &apos;January&apos;)</span><br><span class="line">   year    month  passengers</span><br><span class="line">0  1949  January         112</span><br><span class="line">(1949, &apos;July&apos;)</span><br><span class="line">   year month  passengers</span><br><span class="line">6  1949  July         148</span><br><span class="line">(1949, &apos;June&apos;)</span><br><span class="line">   year month  passengers</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">138  1960  July         622</span><br><span class="line">(1960, &apos;June&apos;)</span><br><span class="line">     year month  passengers</span><br><span class="line">137  1960  June         535</span><br><span class="line">(1960, &apos;March&apos;)</span><br><span class="line">     year  month  passengers</span><br><span class="line">134  1960  March         419</span><br><span class="line">(1960, &apos;May&apos;)</span><br><span class="line">     year month  passengers</span><br><span class="line">136  1960   May         472</span><br><span class="line">(1960, &apos;November&apos;)</span><br><span class="line">     year     month  passengers</span><br><span class="line">142  1960  November         390</span><br><span class="line">(1960, &apos;October&apos;)</span><br><span class="line">     year    month  passengers</span><br><span class="line">141  1960  October         461</span><br><span class="line">(1960, &apos;September&apos;)</span><br><span class="line">     year      month  passengers</span><br><span class="line">140  1960  September         508</span><br></pre></td></tr></table></figure></p>
<h3 id="获取每个组的描述性统计变量"><a href="#获取每个组的描述性统计变量" class="headerlink" title="获取每个组的描述性统计变量"></a>获取每个组的描述性统计变量</h3><p>使用<code>describe</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mcg.describe())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               passengers</span><br><span class="line">                    count   mean std    min    25%    50%    75%    max</span><br><span class="line">year month</span><br><span class="line">1949 April            1.0  129.0 NaN  129.0  129.0  129.0  129.0  129.0</span><br><span class="line">     August           1.0  148.0 NaN  148.0  148.0  148.0  148.0  148.0</span><br><span class="line">     December         1.0  118.0 NaN  118.0  118.0  118.0  118.0  118.0</span><br><span class="line">     February         1.0  118.0 NaN  118.0  118.0  118.0  118.0  118.0</span><br><span class="line">     January          1.0  112.0 NaN  112.0  112.0  112.0  112.0  112.0</span><br><span class="line">...                   ...    ...  ..    ...    ...    ...    ...    ...</span><br><span class="line">1960 March            1.0  419.0 NaN  419.0  419.0  419.0  419.0  419.0</span><br><span class="line">     May              1.0  472.0 NaN  472.0  472.0  472.0  472.0  472.0</span><br><span class="line">     November         1.0  390.0 NaN  390.0  390.0  390.0  390.0  390.0</span><br><span class="line">     October          1.0  461.0 NaN  461.0  461.0  461.0  461.0  461.0</span><br><span class="line">     September        1.0  508.0 NaN  508.0  508.0  508.0  508.0  508.0</span><br><span class="line"></span><br><span class="line">[144 rows x 8 columns]</span><br></pre></td></tr></table></figure></p>
<p>分析结果可知，每个组仅有一行数据</p>
<h2 id="使用等级制的索引分组"><a href="#使用等级制的索引分组" class="headerlink" title="使用等级制的索引分组"></a>使用等级制的索引分组</h2><p>创建一个原数据的浅复制，使用<code>copy</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mi = flight_df.copy()</span><br></pre></td></tr></table></figure></p>
<h3 id="使用set-index函数"><a href="#使用set-index函数" class="headerlink" title="使用set_index函数"></a>使用<code>set_index</code>函数</h3><p>参数为column名字列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mi = mi.set_index([&apos;year&apos;, &apos;month&apos;])</span><br><span class="line">print(mi)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1949 January           112</span><br><span class="line">     February          118</span><br><span class="line">     March             132</span><br><span class="line">     April             129</span><br><span class="line">     May               121</span><br><span class="line">...                    ...</span><br><span class="line">1960 August            606</span><br><span class="line">     September         508</span><br><span class="line">     October           461</span><br><span class="line">     November          390</span><br><span class="line">     December          432</span><br><span class="line"></span><br><span class="line">[144 rows x 1 columns]</span><br></pre></td></tr></table></figure></p>
<h3 id="使用第一个等级的索引分组"><a href="#使用第一个等级的索引分组" class="headerlink" title="使用第一个等级的索引分组"></a>使用第一个等级的索引分组</h3><p>使用了<code>groupby</code>函数中的<code>level</code>参数，类型为int型。最后使用<code>print_groups</code>函数输出组详情。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mig_11 = mi.groupby(level=0)</span><br><span class="line">print_groups(mig_11)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1949</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1949 January           112</span><br><span class="line">     February          118</span><br><span class="line">     March             132</span><br><span class="line">     April             129</span><br><span class="line">     May               121</span><br><span class="line">     June              135</span><br><span class="line">     July              148</span><br><span class="line">     August            148</span><br><span class="line">     September         136</span><br><span class="line">     October           119</span><br><span class="line">     November          104</span><br><span class="line">     December          118</span><br><span class="line">1950</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1950 January           115</span><br><span class="line">     February          126</span><br><span class="line">     March             141</span><br><span class="line">     April             135</span><br><span class="line">     May               125</span><br><span class="line">     June              149</span><br><span class="line">     July              170</span><br><span class="line">     August            170</span><br><span class="line">     September         158</span><br><span class="line">     October           133</span><br><span class="line">     November          114</span><br><span class="line">     December          140</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">1959</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1959 January           360</span><br><span class="line">     February          342</span><br><span class="line">     March             406</span><br><span class="line">     April             396</span><br><span class="line">     May               420</span><br><span class="line">     June              472</span><br><span class="line">     July              548</span><br><span class="line">     August            559</span><br><span class="line">     September         463</span><br><span class="line">     October           407</span><br><span class="line">     November          362</span><br><span class="line">     December          405</span><br><span class="line">1960</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1960 January           417</span><br><span class="line">     February          391</span><br><span class="line">     March             419</span><br><span class="line">     April             461</span><br><span class="line">     May               472</span><br><span class="line">     June              535</span><br><span class="line">     July              622</span><br><span class="line">     August            606</span><br><span class="line">     September         508</span><br><span class="line">     October           461</span><br><span class="line">     November          390</span><br><span class="line">     December          432</span><br></pre></td></tr></table></figure></p>
<h3 id="使用多个等级的索引分组"><a href="#使用多个等级的索引分组" class="headerlink" title="使用多个等级的索引分组"></a>使用多个等级的索引分组</h3><p>向<code>level</code>参数赋值索引列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mig_12 = mi.groupby(level=[&apos;year&apos;, &apos;month&apos;])</span><br><span class="line">print_groups(mig_12)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1949, &apos;April&apos;)</span><br><span class="line">            passengers</span><br><span class="line">year month</span><br><span class="line">1949 April         129</span><br><span class="line">(1949, &apos;August&apos;)</span><br><span class="line">             passengers</span><br><span class="line">year month</span><br><span class="line">1949 August         148</span><br><span class="line">(1949, &apos;December&apos;)</span><br><span class="line">               passengers</span><br><span class="line">year month</span><br><span class="line">1949 December         118</span><br><span class="line">(1949, &apos;February&apos;)</span><br><span class="line">               passengers</span><br><span class="line">year month</span><br><span class="line">1949 February         118</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">(1960, &apos;November&apos;)</span><br><span class="line">               passengers</span><br><span class="line">year month</span><br><span class="line">1960 November         390</span><br><span class="line">(1960, &apos;October&apos;)</span><br><span class="line">              passengers</span><br><span class="line">year month</span><br><span class="line">1960 October         461</span><br><span class="line">(1960, &apos;September&apos;)</span><br><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1960 September         508</span><br></pre></td></tr></table></figure></p>
<h2 id="使用聚合函数agg：参数为函数名"><a href="#使用聚合函数agg：参数为函数名" class="headerlink" title="使用聚合函数agg：参数为函数名"></a>使用聚合函数<code>agg</code>：参数为函数名</h2><h3 id="计算组的平均值"><a href="#计算组的平均值" class="headerlink" title="计算组的平均值"></a>计算组的平均值</h3><p>传入<code>np.mean</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mig_12.agg(np.mean))</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1949 April             129</span><br><span class="line">     August            148</span><br><span class="line">     December          118</span><br><span class="line">     February          118</span><br><span class="line">     January           112</span><br><span class="line">...                    ...</span><br><span class="line">1960 March             419</span><br><span class="line">     May               472</span><br><span class="line">     November          390</span><br><span class="line">     October           461</span><br><span class="line">     September         508</span><br><span class="line"></span><br><span class="line">[144 rows x 1 columns]</span><br></pre></td></tr></table></figure></p>
<p>不创建索引，使用<code>groupby</code>函数的<code>as_index</code>参数(设置为<code>False</code>，创建索引设置为<code>True</code>)，类型为布尔型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = flight_df.groupby([&apos;year&apos;, &apos;month&apos;], as_index=False).agg(np.mean)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     year      month  passengers</span><br><span class="line">0    1949      April         129</span><br><span class="line">1    1949     August         148</span><br><span class="line">2    1949   December         118</span><br><span class="line">3    1949   February         118</span><br><span class="line">4    1949    January         112</span><br><span class="line">..    ...        ...         ...</span><br><span class="line">139  1960      March         419</span><br><span class="line">140  1960        May         472</span><br><span class="line">141  1960   November         390</span><br><span class="line">142  1960    October         461</span><br><span class="line">143  1960  September         508</span><br><span class="line"></span><br><span class="line">[144 rows x 3 columns]</span><br></pre></td></tr></table></figure></p>
<h3 id="一次使用多个函数"><a href="#一次使用多个函数" class="headerlink" title="一次使用多个函数"></a>一次使用多个函数</h3><p>向参数<code>as_index</code>传入函数名列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mig_12.agg([np.mean, np.std]))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               passengers</span><br><span class="line">                     mean std</span><br><span class="line">year month</span><br><span class="line">1949 April            129 NaN</span><br><span class="line">     August           148 NaN</span><br><span class="line">     December         118 NaN</span><br><span class="line">     February         118 NaN</span><br><span class="line">     January          112 NaN</span><br><span class="line">...                   ...  ..</span><br><span class="line">1960 March            419 NaN</span><br><span class="line">     May              472 NaN</span><br><span class="line">     November         390 NaN</span><br><span class="line">     October          461 NaN</span><br><span class="line">     September        508 NaN</span><br><span class="line"></span><br><span class="line">[144 rows x 2 columns]</span><br></pre></td></tr></table></figure></p>
<h3 id="对不同的column应用不同的函数"><a href="#对不同的column应用不同的函数" class="headerlink" title="对不同的column应用不同的函数"></a>对不同的column应用不同的函数</h3><p>通过对<code>as_index</code>参数传入字典(dict)实现，字典键(key)为column名，值(value)为函数名。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = mig_12.agg(&#123;&apos;passengers&apos;: np.mean&#125;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                passengers</span><br><span class="line">year month</span><br><span class="line">1949 April             129</span><br><span class="line">     August            148</span><br><span class="line">     December          118</span><br><span class="line">     February          118</span><br><span class="line">     January           112</span><br><span class="line">...                    ...</span><br><span class="line">1960 March             419</span><br><span class="line">     May               472</span><br><span class="line">     November          390</span><br><span class="line">     October           461</span><br><span class="line">     September         508</span><br><span class="line"></span><br><span class="line">[144 rows x 1 columns]</span><br></pre></td></tr></table></figure></p>
<h3 id="只对指定的column应用函数"><a href="#只对指定的column应用函数" class="headerlink" title="只对指定的column应用函数"></a>只对指定的column应用函数</h3><p>对分组对象使用[ ]运算符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mig_12[&apos;passengers&apos;].mean())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">year  month</span><br><span class="line">1949  April        129</span><br><span class="line">      August       148</span><br><span class="line">      December     118</span><br><span class="line">      February     118</span><br><span class="line">      January      112</span><br><span class="line">                  ...</span><br><span class="line">1960  March        419</span><br><span class="line">      May          472</span><br><span class="line">      November     390</span><br><span class="line">      October      461</span><br><span class="line">      September    508</span><br><span class="line">Name: passengers, Length: 144, dtype: int64</span><br></pre></td></tr></table></figure></p>
<p>返回的是一个<code>Series</code>对象</p>
]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫实践:下载壁纸</title>
    <url>/2019/11/02/python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="导入必要的包-package"><a href="#导入必要的包-package" class="headerlink" title="导入必要的包(package)"></a>导入必要的包(package)</h2><p>若没有下列的包，可使用<code>pip install 包名</code>命令安装</p><ul>
<li>re: 使用正则表达式</li>
<li>requests: 向网站发出请求</li>
<li>bs4: 解析网页内容</li>
<li>time: 计算时间</li>
</ul><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br></pre></td></tr></table></figure>
<h2 id="任务要求-批量下载某网站的壁纸"><a href="#任务要求-批量下载某网站的壁纸" class="headerlink" title="任务要求: 批量下载某网站的壁纸"></a>任务要求: 批量下载某网站的壁纸</h2><h3 id="访问壁纸网站"><a href="#访问壁纸网站" class="headerlink" title="访问壁纸网站"></a>访问壁纸网站</h3><p>我选择的是壁纸质量高的wallpapers home<a href="https://wallpapershome.com" target="_blank" rel="noopener">点击此处访问</a>，网站主页如下<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_1.png" alt></p>
<h3 id="寻找关键页面"><a href="#寻找关键页面" class="headerlink" title="寻找关键页面"></a>寻找关键页面</h3><p>点击主页上的<a href="https://wallpapershome.com/?page=1" target="_blank" rel="noopener">View All Wallpapers</a>注意网址变化<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_2.png" alt><br>目标页面，出现了参数<code>page=1</code>，<strong>每个页面有12张壁纸信息</strong><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_3.png" alt></p>
<h3 id="查看页面请求头"><a href="#查看页面请求头" class="headerlink" title="查看页面请求头"></a>查看页面请求头</h3><p>寻找<code>Host</code>信息和<code>Headers</code>信息，使用开发者工具操作，如下<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_7.png" alt></p>
<h3 id="定位壁纸信息"><a href="#定位壁纸信息" class="headerlink" title="定位壁纸信息"></a>定位壁纸信息</h3><p>选择元素，找到图片的准确信息，操作步骤如下图<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_4.png" alt></p>
<h3 id="找到壁纸信息"><a href="#找到壁纸信息" class="headerlink" title="找到壁纸信息"></a>找到壁纸信息</h3><p>壁纸所在的<code>div</code>标签的类名为<code>class=pics</code><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_5.png" alt></p>
<h3 id="准确定位壁纸的地址"><a href="#准确定位壁纸的地址" class="headerlink" title="准确定位壁纸的地址"></a>准确定位壁纸的地址</h3><p>在上述页面中点击任意一张壁纸，会出现新页面，在新页面中将鼠标移至<code>Download</code>处，选择分辨率<code>1920x1080</code>，浏览器左下角将会出现壁纸的地址信息如下<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_6.png" alt></p>
<h2 id="任务分析"><a href="#任务分析" class="headerlink" title="任务分析"></a>任务分析</h2><h3 id="定制请求头和初始变量"><a href="#定制请求头和初始变量" class="headerlink" title="定制请求头和初始变量"></a>定制请求头和初始变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36&apos;,</span><br><span class="line">    &apos;Host&apos;: &apos;wallpapershome.com&apos;</span><br><span class="line">&#125;</span><br><span class="line">size = &apos;1920x1080&apos;  # 分辨率</span><br><span class="line">save_path = &apos;wallpapers_src/&apos;  # 本地存储地址</span><br><span class="line">start = time.time()  # 程序开始时刻</span><br></pre></td></tr></table></figure>
<h3 id="目标网页的网址规律"><a href="#目标网页的网址规律" class="headerlink" title="目标网页的网址规律"></a>目标网页的网址规律</h3><p>因为不仅仅抓取一个页面的壁纸，故可利用<code>page</code>参数设置请求地址，查看页面数量可知一共有1502张页面，故可如下操作即可访问每个页面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(1502):</span><br><span class="line">    wallpaper_name = []  # 存储每张页面的壁纸名字</span><br><span class="line">    url = &quot;https://wallpapershome.com/?page=&quot; + str(i+1)</span><br><span class="line">    r = requests.get(url, headers=headers)</span><br><span class="line">    print(&quot;状态响应码:&quot;, r.status_code)</span><br></pre></td></tr></table></figure></p>
<h3 id="解析壁纸的地址信息"><a href="#解析壁纸的地址信息" class="headerlink" title="解析壁纸的地址信息"></a>解析壁纸的地址信息</h3><p>通过先前的壁纸的地址信息分析可知，每张壁纸存贮在地址<code>https://wallpapershome.com/images/wallpapers/</code>下，壁纸格式形如<code>分类-分辨率-清晰度-名字.jpg</code>，故利用获取到的壁纸名，再通过设定分辨率，组合可得到壁纸地址<br>创建一个处理壁纸名的函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def handle_name(line):</span><br><span class="line">    sep = &apos;-&apos;</span><br><span class="line">    m = re.match(&apos;(.*)/(.*).html$&apos;, line)</span><br><span class="line">    name = m.group(2)</span><br><span class="line">    name = name.split(&apos;-&apos;)</span><br><span class="line">    name.insert(-2, size)</span><br><span class="line">    name = sep.join(name)</span><br><span class="line">    return name</span><br></pre></td></tr></table></figure></p>
<p>再获取每页12张壁纸全名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(r.content, &apos;lxml&apos;)</span><br><span class="line">wallpaper_list = soup.find(&apos;div&apos;, class_=&apos;pics&apos;)</span><br><span class="line">for j in range(12):</span><br><span class="line">    wallpaper_name.append(handle_name(wallpaper_list.contents[j].a.get(&apos;href&apos;)))</span><br></pre></td></tr></table></figure></p>
<h3 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h3><p>检测运行状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;正在下载第&quot; + str(i+1) + &quot;个页面&quot;)</span><br><span class="line">cost = time.time() - start</span><br><span class="line">print(&quot;已运行时间:&quot; + str(cost) + &apos;秒&apos;)</span><br></pre></td></tr></table></figure></p>
<h3 id="下载每张壁纸"><a href="#下载每张壁纸" class="headerlink" title="下载每张壁纸"></a>下载每张壁纸</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for j in range(12):</span><br><span class="line">    src_url = &apos;https://wallpapershome.com/images/wallpapers/&apos; + wallpaper_name[j] + &apos;.jpg&apos;</span><br><span class="line">    with open(save_path+wallpaper_name[j]+&apos;.jpg&apos;, &apos;wb&apos;) as f:</span><br><span class="line">        img = requests.get(src_url).content</span><br><span class="line">        f.write(img)</span><br><span class="line">        print(&apos;+&apos;, end=&apos;&apos;)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>
<h2 id="运行效果如下"><a href="#运行效果如下" class="headerlink" title="运行效果如下"></a>运行效果如下</h2><p>可能因为是国外网站的原因，下载速度慢得… -.-  部分运行结果如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">状态响应码: 200</span><br><span class="line">正在下载第69个页面</span><br><span class="line">已运行时间:3.5130293369293213秒</span><br><span class="line">++++++++++++</span><br><span class="line"></span><br><span class="line">状态响应码: 200</span><br><span class="line">正在下载第70个页面</span><br><span class="line">已运行时间:85.50803112983704秒</span><br><span class="line">++</span><br></pre></td></tr></table></figure></p>
<h3 id="大量精美壁纸-free-收入囊中"><a href="#大量精美壁纸-free-收入囊中" class="headerlink" title="大量精美壁纸(free)收入囊中"></a>大量精美壁纸(free)收入囊中</h3><p>岂不美哉，妈妈再也不用担心我没有壁纸换了(手动滑稽)<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E7%88%AC%E8%99%AB/1_8.png" alt></p>
<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/SkecisAI/python-project/blob/master/get_wallpapers.py" target="_blank" rel="noopener">点击此处访问</a></p>
]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>用python实现线性链表</title>
    <url>/2019/11/01/python%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="线性链表概览"><a href="#线性链表概览" class="headerlink" title="线性链表概览"></a>线性链表概览</h2><h3 id="单节点链表"><a href="#单节点链表" class="headerlink" title="单节点链表"></a>单节点链表</h3><p>头指针和尾指针为同一节点，<strong>尾指针中的指针域为空(None)</strong><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%93%BE%E8%A1%A8/1_1.png" alt></p><h3 id="一般链表"><a href="#一般链表" class="headerlink" title="一般链表"></a>一般链表</h3><p><strong>尾指针中的指针域为空(None)</strong><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%93%BE%E8%A1%A8/1_2.png" alt></p><a id="more"></a>

<h2 id="链表基本数据结构"><a href="#链表基本数据结构" class="headerlink" title="链表基本数据结构"></a>链表基本数据结构</h2><h3 id="链表基本单元：节点-Node"><a href="#链表基本单元：节点-Node" class="headerlink" title="链表基本单元：节点(Node)"></a>链表基本单元：节点(Node)</h3><p>创建<code>Node</code>类</p>
<ul>
<li>值域</li>
<li>指针域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    the basic element of a linked list</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, val, pnext):</span><br><span class="line">        self.value = val</span><br><span class="line">        self.pnext = pnext</span><br></pre></td></tr></table></figure>
<h3 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h3><p>创建<code>LinkedList</code>类</p>
<ul>
<li>head: 头指针</li>
<li>tail: 尾指针</li>
<li>length: 链表长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LinkedList:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    a linked list object</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.head = None</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        self.length = 0</span><br></pre></td></tr></table></figure>
<h2 id="链表操作函数"><a href="#链表操作函数" class="headerlink" title="链表操作函数"></a>链表操作函数</h2><p><code>self</code>参数为对象本身，类似于C++中的<code>this</code>指针</p>
<h3 id="向链表中插入节点"><a href="#向链表中插入节点" class="headerlink" title="向链表中插入节点"></a>向链表中插入节点</h3><p>创建<code>insert_value</code>函数</p>
<ul>
<li>val: 节点值域</li>
<li>loc: 节点位置，默认为None</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def insert_value(self, val, loc=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    insert node to the list</span><br><span class="line">    :param val: insert value</span><br><span class="line">    :param loc: insert with index</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.list_empty():</span><br><span class="line">        # if the list is empty</span><br><span class="line">        self.head = Node(val, None)</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        self.length = 1</span><br><span class="line">    else:</span><br><span class="line">        if (not loc) | (loc == self.length):</span><br><span class="line">            # if insert element without location or at the tail</span><br><span class="line">            new_node = Node(val, None)</span><br><span class="line">            self.tail.pnext = new_node</span><br><span class="line">            self.tail = new_node</span><br><span class="line">            self.length += 1</span><br><span class="line">        else:</span><br><span class="line">            new_node = Node(val, None)</span><br><span class="line">            last_node = self.head</span><br><span class="line">            for index in range(self.length):</span><br><span class="line">                if index == (loc - 1) - 1:</span><br><span class="line">                    break</span><br><span class="line">                else:</span><br><span class="line">                    last_node = last_node.pnext</span><br><span class="line">            next_node = last_node.pnext</span><br><span class="line">            last_node.pnext = new_node</span><br><span class="line">            new_node.pnext = next_node</span><br><span class="line">            self.length += 1</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h3><p>创建<code>delete_value</code>函数</p>
<ul>
<li>loc: 删除的节点位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def delete_value(self, loc=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    delete value from list</span><br><span class="line">    :param loc: the location of list</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not self.list_empty():</span><br><span class="line">        if loc:</span><br><span class="line">            last_node = self.head</span><br><span class="line">            for index in range(self.length):</span><br><span class="line">                if index == (loc - 1) - 1:</span><br><span class="line">                    break</span><br><span class="line">                else:</span><br><span class="line">                    last_node = last_node.pnext</span><br><span class="line">            next_node = last_node.pnext.pnext</span><br><span class="line">            last_node.pnext = next_node</span><br><span class="line">        else:</span><br><span class="line">            now_node = self.head</span><br><span class="line">            while now_node:</span><br><span class="line">                if now_node.pnext.pnext is None:</span><br><span class="line">                    now_node.pnext = None</span><br><span class="line">                    break</span><br><span class="line">                else:</span><br><span class="line">                    now_node = now_node.pnext</span><br><span class="line">        self.length -= 1</span><br></pre></td></tr></table></figure>
<h3 id="判断链表是否为空"><a href="#判断链表是否为空" class="headerlink" title="判断链表是否为空"></a>判断链表是否为空</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def list_empty(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if the list is empty</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.head is None:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h3 id="打印链表内容"><a href="#打印链表内容" class="headerlink" title="打印链表内容"></a>打印链表内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def list_traverse(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    visit all elements of the list</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not self.list_empty():</span><br><span class="line">        now_node = self.head</span><br><span class="line">        print(&apos;-&apos;*15)</span><br><span class="line">        while now_node:</span><br><span class="line">            print(&quot;value: &quot;, now_node.value)</span><br><span class="line">            now_node = now_node.pnext</span><br></pre></td></tr></table></figure>
<h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>创建程序入口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    my_linkedlist = LinkedList()</span><br><span class="line">    for i in range(5):</span><br><span class="line">        my_linkedlist.insert_value(i)</span><br><span class="line">    my_linkedlist.list_traverse()</span><br><span class="line">    my_linkedlist.insert_value([&apos;this&apos;, &apos;is&apos;, &apos;a&apos;, &apos;list&apos;], 3)</span><br><span class="line">    my_linkedlist.list_traverse()</span><br><span class="line">    my_linkedlist.delete_value(2)</span><br><span class="line">    my_linkedlist.list_traverse()</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------</span><br><span class="line">value:  0</span><br><span class="line">value:  1</span><br><span class="line">value:  2</span><br><span class="line">value:  3</span><br><span class="line">value:  4</span><br><span class="line">---------------</span><br><span class="line">value:  0</span><br><span class="line">value:  1</span><br><span class="line">value:  [&apos;this&apos;, &apos;is&apos;, &apos;a&apos;, &apos;list&apos;]</span><br><span class="line">value:  2</span><br><span class="line">value:  3</span><br><span class="line">value:  4</span><br><span class="line">---------------</span><br><span class="line">value:  0</span><br><span class="line">value:  [&apos;this&apos;, &apos;is&apos;, &apos;a&apos;, &apos;list&apos;]</span><br><span class="line">value:  2</span><br><span class="line">value:  3</span><br><span class="line">value:  4</span><br></pre></td></tr></table></figure></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/SkecisAI/python-DS/blob/master/linked_list.py" target="_blank" rel="noopener">点击此处访问</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>CFPS数据分析案例</title>
    <url>/2019/10/24/CFPS%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="文献引用"><a href="#文献引用" class="headerlink" title="文献引用"></a>文献引用</h2><p><a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFDLAST2018&amp;filename=ZGQL201712007&amp;uid=WEEvREcwSlJHSldTTEYzU3EydDVHeHMyVC9Rc1FKVFNDOFJmRVM4alNqdz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MDM1NzVUcldNMUZyQ1VSTE9lWitSckZDbm5WTC9CUHlyYVlyRzRIOWJOclk5Rlk0UjhlWDFMdXhZUzdEaDFUM3E=" target="_blank" rel="noopener"><strong>刘保中.我国城乡家庭教育投入状况的比较研究——基于CFPS(2014)数据的实证分析[J].中国青年研究,2017(12):45-52.</strong></a></p><a id="more"></a>
<h2 id="文献简要"><a href="#文献简要" class="headerlink" title="文献简要"></a>文献简要</h2><p>使用<strong>CFPS2014</strong>年的数据，在<strong>教育期望、教育支出</strong>和<strong>教育参与</strong>三个维度上对当前我国城乡家庭教育投入状况进行了比较分析，详细摘要内容如下:<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_1.png" alt></p>
<h2 id="数据处理-Python"><a href="#数据处理-Python" class="headerlink" title="数据处理(Python)"></a>数据处理(Python)</h2><h3 id="数据概要"><a href="#数据概要" class="headerlink" title="数据概要"></a>数据概要</h3><p>该文献使用的是cfps2014年的数据，且着重使用的是<strong>儿童数据</strong>，文献中的数据部分摘要如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_2.png" alt></p>
<h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>导入必要的包<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import statsmodels.api as sm</span><br><span class="line">from pandas.io.stata import StataReader</span><br></pre></td></tr></table></figure></p>
<h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><p>导入了儿童数据和家庭数据(均为stata文件)，使用StataReader函数读入该类型文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_stata = StataReader(&apos;cfps2014child.dta&apos;, convert_categoricals=False)</span><br><span class="line">famecon_stata = StataReader(&apos;cfps2014famecon.dta&apos;, convert_categoricals=False)</span><br></pre></td></tr></table></figure></p>
<p>上述方式得到的是stata数据，接着将其转化为Pandas中的DataFrame格式，使用read函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df = child_stata.read()</span><br><span class="line">fam_df = famecon_stata.read()</span><br></pre></td></tr></table></figure></p>
<p>数据概览<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(child_df.head())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">           pid  proxyrpt  ...  cfps2014eduy_im  releaseversion</span><br><span class="line">0  100453401.0       1.0  ...              0.0             2.0</span><br><span class="line">1  103924504.0       1.0  ...              0.0             2.0</span><br><span class="line">2  106561502.0       1.0  ...              0.0             2.0</span><br><span class="line">3  107624502.0       1.0  ...              0.0             2.0</span><br><span class="line">4  110011103.0       1.0  ...              8.0             2.0</span><br></pre></td></tr></table></figure></p>
<h4 id="变量引入及预处理"><a href="#变量引入及预处理" class="headerlink" title="变量引入及预处理"></a>变量引入及预处理</h4><p>使用的变量及处理方式：父母对孩子的教育期望（分为高等教育期望和非高等教育期望，以及等价转化为教育年限）、家庭全年教育支出、家庭教育课外补习支出、家庭教育参与（共六个变量，程度从低到高划为1-5分）。控制变量：孩子户口（0-农业户口，1-非农业户口）、孩子性别（0-女，1-男），孩子年龄、孩子目前上学阶段（小学及以上）、家庭年收入（取对数）。文献中使用的变量详情（部分划线的变量未引入）：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_3.png" alt><br>特征变量详情列表如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_col = [&apos;fid14&apos;,  # 14年家庭编码</span><br><span class="line">             &apos;wd2&apos;,  # 家庭教育期望</span><br><span class="line">             &apos;wd503m&apos;, &apos;wd5ckp&apos;, &apos;wd5total_m&apos;, &apos;wd5total&apos;,  # 家庭教育支出： 课外辅导费用，是否确认教育支出，新教育支出，旧教育支出</span><br><span class="line">             &apos;wf601m&apos;, &apos;wf602m&apos;, &apos;wf603m&apos;, &apos;wf604m&apos;, &apos;wf605m&apos;, &apos;wf606m&apos;,  # 家庭教育参与： 频率从低到高（赋值1-5分）</span><br><span class="line">             &apos;wa4&apos;, &apos;cfps2014_age&apos;, &apos;cfps_gender&apos;,  # 控制变量： 户口(1:农, 3:非农)，年龄，性别</span><br><span class="line">             &apos;wf301m&apos;]  # 上哪级学校</span><br><span class="line">family_col = [&apos;fid14&apos;,</span><br><span class="line">              &apos;finc&apos;]  # 家庭年收入</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>使用家庭收入变量连接两表<br>为了在儿童数据中引入家庭数据的收入变量，需根据家庭编码链接两个表，使用join函数，键值设为家庭编码<code>fid14</code>。<strong>特别要注意的是，因为不是每一个儿童在家庭表中的都有年收入这个数据，故连接后无年收入数据的儿童该值将为空，此时抛弃空值。并抛弃不符合要求的数据（-1）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取家庭年收入变量</span><br><span class="line">child_df = child_df.join(fam_df.set_index(&apos;fid14&apos;), on=&apos;fid14&apos;)  # 根据家庭编码链接两个表</span><br><span class="line">child_df = child_df.dropna()</span><br><span class="line">child_df.drop(child_df[child_df[&apos;finc&apos;] &lt; 0].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理家庭收入变量<br>进行取对数处理，自定义函数<code>cal_finc</code>进行映射。<br>自定义函数<code>cal_finc</code>如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def cal_finc(finc):</span><br><span class="line">    # 家庭年收入取对数</span><br><span class="line">    if finc == 0:</span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        return np.log(finc)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>将函数映射到数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df[&apos;finc&apos;] = child_df[&apos;finc&apos;].map(cal_finc)      # 处理家庭年收入</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>处理户口变量<br>将原来的数据中农业户口和非农业户口映射为0和1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">city_code = &#123;1: 0, 3: 1&#125;  # 户口重新编码</span><br><span class="line">child_df[&apos;wa4&apos;] = child_df[&apos;wa4&apos;].map(city_code)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删去不符合条件的数据<br>删去既不是农业户口或非农业户口的，再删去上学阶段不符合要求的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop_cond = (child_df[&apos;wa4&apos;] &lt; 1) | (child_df[&apos;wa4&apos;] &gt; 3)  # 删去户口不符合要求的</span><br><span class="line">child_df.drop(child_df[drop_cond].index, inplace=True)</span><br><span class="line">drop_cond1 = (child_df[&apos;wf301m&apos;] &lt;= 2)  # 删去上学阶段不符合要求的</span><br><span class="line">child_df.drop(child_df[drop_cond1].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="处理教育期望"><a href="#处理教育期望" class="headerlink" title="处理教育期望"></a>处理教育期望</h3><ol>
<li><p>首先删去不符合要求的教育期望样本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop_cond2 = (child_df[&apos;wd2&apos;] &lt; 0)</span><br><span class="line">child_df.drop(child_df[drop_cond2].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>教育期望的分布以及样本量<br>打印出教育期望的分布及样本数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(child_df[&apos;wd2&apos;].value_counts(), &apos;count: &apos;, child_df[&apos;wd2&apos;].count())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6.0    2394</span><br><span class="line">4.0     546</span><br><span class="line">8.0     296</span><br><span class="line">5.0     280</span><br><span class="line">7.0     145</span><br><span class="line">3.0      88</span><br><span class="line">2.0      18</span><br><span class="line">9.0       1</span><br><span class="line">Name: wd2, dtype: int64 count:  3768</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>将教育期望映射为两类：1-高等教育期望，0-非高等教育期望</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df[&apos;high_edu&apos;] = child_df.apply(lambda row: 1 if row[&apos;wd2&apos;] &gt;= 5 else 0, axis=1)  # 是否为高等教育期望</span><br></pre></td></tr></table></figure>
</li>
<li><p>将教育期望映射为教育年限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edu_code = &#123;9: 0, 8: 23, 7: 19, 6: 16, 5: 15, 4: 12, 3: 9, 2: 6&#125;  # 教育期望重新编码</span><br><span class="line">child_df[&apos;wd2_years&apos;] = child_df[&apos;wd2&apos;].map(edu_code)</span><br></pre></td></tr></table></figure>
</li>
<li><p>各个教育期望年限和高等教育期望的样本量、均值和百分比</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">village_df = child_df[child_df[&apos;wa4&apos;] == 0]  # 农业户口</span><br><span class="line">city_df = child_df[child_df[&apos;wa4&apos;] == 1]  # 非农业户口</span><br><span class="line">expect_total_mean = child_df[&apos;wd2_years&apos;].mean()</span><br><span class="line">village_expect_mean = village_df[&apos;wd2_years&apos;].mean()</span><br><span class="line">print(&apos;total   city   village&apos;)</span><br><span class="line">print(&apos;count: &apos;, child_df.shape[0], city_df.shape[0], village_df.shape[0])</span><br><span class="line">print(&apos;years_mean: &apos;, expect_total_mean, city_expect_mean, village_expect_mean)</span><br><span class="line">print(&apos;high_edu_percent: &apos;,</span><br><span class="line">      child_df[&apos;high_edu&apos;].value_counts(normalize=True).loc[1]*100,</span><br><span class="line">      city_df[&apos;high_edu&apos;].value_counts(normalize=True).loc[1]*100,</span><br><span class="line">      village_df[&apos;high_edu&apos;].value_counts(normalize=True).loc[1]*100)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total   city   village</span><br><span class="line">count:  3768 808 2960</span><br><span class="line">years_mean:  15.795912951167729 16.521039603960396 15.597972972972974</span><br><span class="line">high_edu_percent:  82.6963906581741 93.6881188118812 79.69594594594595</span><br></pre></td></tr></table></figure></p>
<p>原文中教育期望的数据分布如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_4.png" alt></p>
<h3 id="处理教育支出"><a href="#处理教育支出" class="headerlink" title="处理教育支出"></a>处理教育支出</h3><p>课外辅导数据较为正常，不需要处理</p>
<ol>
<li><p>获取最终的全年教育支出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df[&apos;edu_expense&apos;] = child_df.apply(lambda row: row[&apos;wd5total_m&apos;] if (row[&apos;wd5ckp&apos;] == 1) | (row[&apos;wd5ckp&apos;] == 3) else row[&apos;wd5total&apos;], axis=1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删去不符合条件的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child_df.drop(child_df[child_df[&apos;edu_expense&apos;] &lt; 0].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>各个全年教育指出和课外辅导的样本量、均值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 教育支出: 课外辅导</span><br><span class="line">coach_total_mean = child_df[&apos;wd503m&apos;].mean()</span><br><span class="line">village_coach_mean = village_df[&apos;wd503m&apos;].mean()</span><br><span class="line">city_coach_mean = city_df[&apos;wd503m&apos;].mean()</span><br><span class="line"># 教育支出： 总支出</span><br><span class="line">expense_total_mean = child_df[&apos;edu_expense&apos;].mean()</span><br><span class="line">village_expense_mean = village_df[&apos;edu_expense&apos;].mean()</span><br><span class="line">city_expense_mean = city_df[&apos;edu_expense&apos;].mean()</span><br><span class="line">child_df.to_csv(&apos;2014child.csv&apos;, index=False)</span><br><span class="line">print(&apos;total   city   village&apos;)</span><br><span class="line">print(&apos;count: &apos;, child_df.shape[0], city_df.shape[0], village_df.shape[0])</span><br><span class="line">print(&apos;expense_mean: &apos;, expense_total_mean, city_expense_mean, village_expense_mean)</span><br><span class="line">print(&apos;coach_mean: &apos;, coach_total_mean, city_coach_mean, village_coach_mean)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total   city   village</span><br><span class="line">count:  3774 808 2966</span><br><span class="line">expense_mean:  3179.1073131955486 5691.209158415842 2494.7585974376266</span><br><span class="line">coach_mean:  787.992315845257 2657.6992574257424 278.64531355360754</span><br></pre></td></tr></table></figure></p>
<p>原文中教育支出的数据分布如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_5.png" alt></p>
<h3 id="处理教育参与"><a href="#处理教育参与" class="headerlink" title="处理教育参与"></a>处理教育参与</h3><p>教育参与相关变量列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li = [&apos;wf601m&apos;, &apos;wf602m&apos;, &apos;wf603m&apos;, &apos;wf604m&apos;, &apos;wf605m&apos;, &apos;wf606m&apos;]</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>删去不符合条件的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nan_cond = False</span><br><span class="line">for col in child_df.columns:</span><br><span class="line">    if col in li:</span><br><span class="line">        nan_cond = nan_cond | (child_df[col] == -8) | (child_df[col] == -1)</span><br><span class="line">child_df.drop(child_df[nan_cond].index, inplace=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据关心程度从大到小编码（5-1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">care_code = &#123;1: 5, 2: 4, 3: 3, 4: 2, 5: 1&#125;  # 教育关心程度重新编码</span><br><span class="line">for col in child_df.columns:</span><br><span class="line">    if col in li:</span><br><span class="line">        child_df[col] = child_df[col].map(care_code)</span><br></pre></td></tr></table></figure>
</li>
<li><p>关怀程度在2次以上的各个比例及样本量<br>首先将频次变量映射为0-1变量，满足条件的为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 频次在两次以上，即&gt;=4</span><br><span class="line">for col in child_df.columns:</span><br><span class="line">    if col in li:</span><br><span class="line">        child_df[col] = child_df[col].map(lambda val: 1 if val &gt;= 4 else 0)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>进行统计<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&apos;total   city   village&apos;)</span><br><span class="line">print(&apos;count: &apos;, child_df.shape[0], city_df.shape[0], village_df.shape[0])</span><br><span class="line">for col in child_df.columns:</span><br><span class="line">    if col in li:</span><br><span class="line">        print(child_df[col].value_counts(normalize=True).loc[1]*100,</span><br><span class="line">              city_df[col].value_counts(normalize=True).loc[1]*100,</span><br><span class="line">              village_df[col].value_counts(normalize=True).loc[1]*100)</span><br></pre></td></tr></table></figure></p>
<p>输出(顺序与原文一致)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total   city   village</span><br><span class="line">count:  3746 802 2944</span><br><span class="line">72.61078483715964 79.30174563591022 70.78804347826086</span><br><span class="line">54.00427122263748 63.71571072319202 51.358695652173914</span><br><span class="line">87.26641751201282 88.5286783042394 86.9225543478261</span><br><span class="line">56.620395088093964 66.20947630922693 54.00815217391305</span><br><span class="line">65.02936465563268 66.08478802992519 64.74184782608695</span><br><span class="line">38.57447944474106 40.64837905236908 38.00951086956522</span><br></pre></td></tr></table></figure></p>
<p>原文中教育参与的变量分布如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/cfps%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1_6.png" alt></p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4>]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>CFPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas数据结构-Series(二)</title>
    <url>/2019/10/16/Pandas-Series2/</url>
    <content><![CDATA[<h2 id="导入必要的包"><a href="#导入必要的包" class="headerlink" title="导入必要的包"></a>导入必要的包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure><h2 id="通过索引对齐值的特性"><a href="#通过索引对齐值的特性" class="headerlink" title="通过索引对齐值的特性"></a>通过索引对齐值的特性</h2><a id="more"></a>
<h3 id="用”-”操作实现"><a href="#用”-”操作实现" class="headerlink" title="用”+”操作实现"></a>用”+”操作实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s6 = pd.Series([1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])</span><br><span class="line">s7 = pd.Series([4, 3, 2, 1], index=[&apos;d&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;])</span><br><span class="line">print(s6 + s7)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    2</span><br><span class="line">b    4</span><br><span class="line">c    6</span><br><span class="line">d    8</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<p>Serise的相加是基于索引匹配的<br><strong>如果存在无法匹配的标签，运算结果将为NaN</strong></p>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><h3 id="将所有值乘以一个数"><a href="#将所有值乘以一个数" class="headerlink" title="将所有值乘以一个数"></a>将所有值乘以一个数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s6 * 2)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    2</span><br><span class="line">b    4</span><br><span class="line">c    6</span><br><span class="line">d    8</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="两个Series相乘"><a href="#两个Series相乘" class="headerlink" title="两个Series相乘"></a>两个Series相乘</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t = pd.Series(2, s6.index)</span><br><span class="line">print(s6 * t)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    2</span><br><span class="line">b    4</span><br><span class="line">c    6</span><br><span class="line">d    8</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h2 id="存在NaN值的情况"><a href="#存在NaN值的情况" class="headerlink" title="存在NaN值的情况"></a>存在NaN值的情况</h2><h3 id="忽略NaN值"><a href="#忽略NaN值" class="headerlink" title="忽略NaN值"></a>忽略NaN值</h3><p>使用了mean()函数求平均<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.array([1, 2, 3, 4, np.nan]))</span><br><span class="line">print(s.mean())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.5</span><br></pre></td></tr></table></figure></p>
<p>不忽略NaN值<br>使用mean()函数的skipna参数，类型为布尔型(boolean)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.mean(skipna=False))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nan</span><br></pre></td></tr></table></figure></p>
<h2 id="布尔选择"><a href="#布尔选择" class="headerlink" title="布尔选择"></a>布尔选择</h2><p>用到的Series<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.arange(0, 10))</span><br></pre></td></tr></table></figure></p>
<p>s:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0    0</span><br><span class="line">1    1</span><br><span class="line">2    2</span><br><span class="line">3    3</span><br><span class="line">4    4</span><br><span class="line">5    5</span><br><span class="line">6    6</span><br><span class="line">7    7</span><br><span class="line">8    8</span><br><span class="line">9    9</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<h3 id="使用布尔运算符"><a href="#使用布尔运算符" class="headerlink" title="使用布尔运算符"></a>使用布尔运算符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s &gt; 5)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0    False</span><br><span class="line">1    False</span><br><span class="line">2    False</span><br><span class="line">3    False</span><br><span class="line">4    False</span><br><span class="line">5    False</span><br><span class="line">6     True</span><br><span class="line">7     True</span><br><span class="line">8     True</span><br><span class="line">9     True</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure></p>
<p><strong>得到的结果类型仍为Series</strong></p>
<h3 id="使用逻辑型数值的Series作为索引"><a href="#使用逻辑型数值的Series作为索引" class="headerlink" title="使用逻辑型数值的Series作为索引"></a>使用逻辑型数值的Series作为索引</h3><p>利用了对方括号运算符[ ]的重载，最终只返回对应索引的值为true的对应值的Series片段<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bigger_loc = s &gt; 5</span><br><span class="line">print(s[bigger_loc])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6    6</span><br><span class="line">7    7</span><br><span class="line">8    8</span><br><span class="line">9    9</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<p>更简介的语法：<code>s[s &gt; 5]</code></p>
<h3 id="使用复合的布尔运算表达式"><a href="#使用复合的布尔运算表达式" class="headerlink" title="使用复合的布尔运算表达式"></a>使用复合的布尔运算表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[(s &gt; 5) &amp; (s &lt; 8)])</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6    6</span><br><span class="line">7    7</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<p><strong>特别注意这里单一的运算周围用的括号()是必须的，否则会报类似下面的错误：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()</span><br></pre></td></tr></table></figure></p>
<h3 id="函数：all-和any"><a href="#函数：all-和any" class="headerlink" title="函数：all()和any()"></a>函数：all()和any()</h3><p>all()函数：单一逻辑间的<code>且</code>运算<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print((s &gt;= 0).all())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p>any()函数：单一逻辑间的<code>或</code>运算<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print((s &lt; 2).any())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h2 id="重定义Series的索引"><a href="#重定义Series的索引" class="headerlink" title="重定义Series的索引"></a>重定义Series的索引</h2><h3 id="使用index属性"><a href="#使用index属性" class="headerlink" title="使用index属性"></a>使用index属性</h3><p>将一个索引列表(list)传给index属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.random.randn(5))</span><br><span class="line">s.index = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a   -0.623722</span><br><span class="line">b   -0.906193</span><br><span class="line">c   -0.424337</span><br><span class="line">d   -0.486135</span><br><span class="line">e   -0.075073</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="修整连接Series后的索引"><a href="#修整连接Series后的索引" class="headerlink" title="修整连接Series后的索引"></a>修整连接Series后的索引</h3><p>连接后的索引<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series(np.random.randn(3))</span><br><span class="line">s2 = pd.Series(np.random.randn(3))</span><br><span class="line">combined = pd.concat([s1, s2])</span><br><span class="line">print(combined)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0    0.565139</span><br><span class="line">1    0.033748</span><br><span class="line">2   -1.315617</span><br><span class="line">0    1.064170</span><br><span class="line">1   -1.524376</span><br><span class="line">2    0.391475</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<p>修整索引<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">combined.index = np.arange(0, len(combined))</span><br><span class="line">print(combined)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   -0.169124</span><br><span class="line">1   -1.167542</span><br><span class="line">2   -0.431747</span><br><span class="line">3    0.879552</span><br><span class="line">4   -1.460969</span><br><span class="line">5    0.119569</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="使用reindex-函数"><a href="#使用reindex-函数" class="headerlink" title="使用reindex()函数"></a>使用reindex()函数</h3><p>参数为索引的列表(list)，<strong>特别要注意的是reindex()函数将会返回一个新的Series实例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series(np.random.randn(4), [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])</span><br><span class="line">s2 = s1.reindex([&apos;a&apos;, &apos;c&apos;, &apos;g&apos;])</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a   -0.644808</span><br><span class="line">c    1.309109</span><br><span class="line">g         NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<p>当索引不存在时，会被填充NaN，若要修改填充值，可使用fill_value参数<br>或者使用填充方法参数<code>method</code>：有向前填充(‘ffill’)和向后填充(‘bfill’)两种选择<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s3 = pd.Series([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;], index=[0, 3, 5])</span><br><span class="line">s3 = s3.reindex(np.arange(0, 7), method=&apos;ffill&apos;)</span><br><span class="line">print(s3)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0      red</span><br><span class="line">1      red</span><br><span class="line">2      red</span><br><span class="line">3    green</span><br><span class="line">4    green</span><br><span class="line">5     blue</span><br><span class="line">6     blue</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure></p>
<h2 id="在本体-in-place-上操作"><a href="#在本体-in-place-上操作" class="headerlink" title="在本体(in-place)上操作"></a>在本体(in-place)上操作</h2><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>直接通过索引赋值<br><code>Series[index] = val</code></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用del函数<br><code>del(Series[index])</code></p>
<h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.arange(100, 110), index=np.arange(10, 20))</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>s:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10    100</span><br><span class="line">11    101</span><br><span class="line">12    102</span><br><span class="line">13    103</span><br><span class="line">14    104</span><br><span class="line">15    105</span><br><span class="line">16    106</span><br><span class="line">17    107</span><br><span class="line">18    108</span><br><span class="line">19    109</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<h3 id="形式一：Series-start-end-interval"><a href="#形式一：Series-start-end-interval" class="headerlink" title="形式一：Series[start: end: interval]"></a>形式一：Series[start: end: interval]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[0:6:2])</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10    100</span><br><span class="line">12    102</span><br><span class="line">14    104</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<p>等价于<code>s.iloc[[0, 2, 4]]</code></p>
<h3 id="形式二：Series-start-end"><a href="#形式二：Series-start-end" class="headerlink" title="形式二：Series[start: end]"></a>形式二：Series[start: end]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[:5])</span><br></pre></td></tr></table></figure>
<p>等价于<code>s.head(5)</code></p>
<h3 id="巧妙利用切片"><a href="#巧妙利用切片" class="headerlink" title="巧妙利用切片"></a>巧妙利用切片</h3><p>倒序Series<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[::-1])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19    109</span><br><span class="line">18    108</span><br><span class="line">17    107</span><br><span class="line">16    106</span><br><span class="line">15    105</span><br><span class="line">14    104</span><br><span class="line">13    103</span><br><span class="line">12    102</span><br><span class="line">11    101</span><br><span class="line">10    100</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
<p>从开始位置4，倒叙<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s[4::-2])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14    104</span><br><span class="line">12    102</span><br><span class="line">10    100</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas数据结构-Series(一)</title>
    <url>/2019/10/15/Pandas-Series/</url>
    <content><![CDATA[<h2 id="导入必要的包"><a href="#导入必要的包" class="headerlink" title="导入必要的包"></a>导入必要的包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure><h2 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h2><a id="more"></a>
<h3 id="创建只含一个元素的Series"><a href="#创建只含一个元素的Series" class="headerlink" title="创建只含一个元素的Series"></a>创建只含一个元素的Series</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series(16)</span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0    16</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="通过索引获取值"><a href="#通过索引获取值" class="headerlink" title="通过索引获取值"></a>通过索引获取值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val = s1[0]</span><br><span class="line">print(val)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure></p>
<h3 id="通过列表创建Series"><a href="#通过列表创建Series" class="headerlink" title="通过列表创建Series"></a>通过列表创建Series</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s2 = pd.Series([7, 8, 9, 10, 11])</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0     7</span><br><span class="line">1     8</span><br><span class="line">2     9</span><br><span class="line">3    10</span><br><span class="line">4    11</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="获取Series的所有值或索引"><a href="#获取Series的所有值或索引" class="headerlink" title="获取Series的所有值或索引"></a>获取Series的所有值或索引</h3><p>使用Series实例的两个属性：values和index<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s2.values) # 获取值</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ 7  8  9 10 11]</span><br></pre></td></tr></table></figure></p>
<p>使用index属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s2.index) # 获取索引</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RangeIndex(start=0, stop=5, step=1)</span><br></pre></td></tr></table></figure></p>
<h3 id="指定值和索引创建Series"><a href="#指定值和索引创建Series" class="headerlink" title="指定值和索引创建Series"></a>指定值和索引创建Series</h3><p>使用了参数index，参数类型为列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s3 = pd.Series([1, 2, 3], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">print(s3)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a    1</span><br><span class="line">b    2</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="使用已存在的Series索引创建Series"><a href="#使用已存在的Series索引创建Series" class="headerlink" title="使用已存在的Series索引创建Series"></a>使用已存在的Series索引创建Series</h3><p>将已存在Series的索引(使用index属性)赋值给参数index<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s4 = pd.Series(2, index=s3.index)</span><br><span class="line">print(s4)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a    2</span><br><span class="line">b    2</span><br><span class="line">c    2</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<p>值的数量不足时，将会依每个索引把值复制一遍</p>
<h3 id="使用5个正态随机数生成Series"><a href="#使用5个正态随机数生成Series" class="headerlink" title="使用5个正态随机数生成Series"></a>使用5个正态随机数生成Series</h3><p>这里用了numpy的1-darray类型来创建<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">s5 = pd.Series(dict1)</span><br><span class="line">print(s5)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a    1</span><br><span class="line">b    2</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h2 id="关于Series值的属性、函数和方法"><a href="#关于Series值的属性、函数和方法" class="headerlink" title="关于Series值的属性、函数和方法"></a>关于Series值的属性、函数和方法</h2><p>首先创建一个带有NaN值的Series<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series([0, 1, 1, 2, 3, 4, 5, 6, 7, np.nan])</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0    0.0</span><br><span class="line">1    1.0</span><br><span class="line">2    1.0</span><br><span class="line">3    2.0</span><br><span class="line">4    3.0</span><br><span class="line">5    4.0</span><br><span class="line">6    5.0</span><br><span class="line">7    6.0</span><br><span class="line">8    7.0</span><br><span class="line">9    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="Series的长度"><a href="#Series的长度" class="headerlink" title="Series的长度"></a>Series的长度</h3><p>使用len()函数或size属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(len(s))</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.size)</span><br></pre></td></tr></table></figure></p>
<p>都将输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure></p>
<h3 id="Series的尺寸"><a href="#Series的尺寸" class="headerlink" title="Series的尺寸"></a>Series的尺寸</h3><p>使用shape属性，会得到一个元组<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.shape)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(10,)</span><br></pre></td></tr></table></figure></p>
<h3 id="统计Series中非NaN的值的数量"><a href="#统计Series中非NaN的值的数量" class="headerlink" title="统计Series中非NaN的值的数量"></a>统计Series中非NaN的值的数量</h3><p>使用count()方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.count())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></p>
<h3 id="获取Series中的所有的唯一值"><a href="#获取Series中的所有的唯一值" class="headerlink" title="获取Series中的所有的唯一值"></a>获取Series中的所有的唯一值</h3><p>使用unique()方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.unique())</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ 0.  1.  2.  3.  4.  5.  6.  7. nan]</span><br></pre></td></tr></table></figure></p>
<h2 id="预览数据的一部分"><a href="#预览数据的一部分" class="headerlink" title="预览数据的一部分"></a>预览数据的一部分</h2><h3 id="预览数据的开头部分"><a href="#预览数据的开头部分" class="headerlink" title="预览数据的开头部分"></a>预览数据的开头部分</h3><p>使用head()函数，可选参数<code>n</code>：需要预览的行数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.head(3))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0    0.0</span><br><span class="line">1    1.0</span><br><span class="line">2    1.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="预览数据的结尾部分"><a href="#预览数据的结尾部分" class="headerlink" title="预览数据的结尾部分"></a>预览数据的结尾部分</h3><p>使用tail()函数，可选参数<code>n</code>：需要预览的行数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.tail(4))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6    5.0</span><br><span class="line">7    6.0</span><br><span class="line">8    7.0</span><br><span class="line">9    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h3 id="预览数据的指定部分"><a href="#预览数据的指定部分" class="headerlink" title="预览数据的指定部分"></a>预览数据的指定部分</h3><p>使用take()函数，参数：索引组成的列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s.take([2, 3, 6]))</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2    1.0</span><br><span class="line">3    2.0</span><br><span class="line">6    5.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h2 id="在Series中查找值"><a href="#在Series中查找值" class="headerlink" title="在Series中查找值"></a>在Series中查找值</h2><p>引用<code>s3</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a    1</span><br><span class="line">b    2</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<h3 id="通过索引名查找"><a href="#通过索引名查找" class="headerlink" title="通过索引名查找"></a>通过索引名查找</h3><p>索引名可为列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s3[&apos;a&apos;])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h3 id="通过位置-从0开始-查找"><a href="#通过位置-从0开始-查找" class="headerlink" title="通过位置(从0开始)查找"></a>通过位置(从0开始)查找</h3><p>位置可为列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s3[1])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3 id="强行只通过索引名查找"><a href="#强行只通过索引名查找" class="headerlink" title="强行只通过索引名查找"></a>强行只通过索引名查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s5 = pd.Series([1, 2, 3], index=[10, 11, 12])</span><br></pre></td></tr></table></figure>
<p><code>s5</code>结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10    1</span><br><span class="line">11    2</span><br><span class="line">13    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></p>
<p>使用loc[]属性，列表类型，可传入列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s5.loc[12])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>如果索引名不存在会返回NaN，且不能传入位置</p>
<h3 id="强行只通过位置查找"><a href="#强行只通过位置查找" class="headerlink" title="强行只通过位置查找"></a>强行只通过位置查找</h3><p>使用iloc[]属性，列表类型，可传入列表(list)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(s5.iloc[1])</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>如果位置不存在会报错，且不能传入索引名</p>
<h3 id="位置和索引名兼容查找-不推荐"><a href="#位置和索引名兼容查找-不推荐" class="headerlink" title="位置和索引名兼容查找(不推荐)"></a>位置和索引名兼容查找(不推荐)</h3><p>使用ix[]属性，列表类型，可传入列表(list)。</p>
]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语法</title>
    <url>/2019/10/12/MySQL%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; CREATE DATABASE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; DROP DATABASE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><a id="more"></a>

<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; USE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS &lt;表名&gt; (字段名1 字段1类型定义, [...]);</span><br></pre></td></tr></table></figure>
<p>以下代码创建了一个学生成绩表：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS student_grade</span><br><span class="line">(</span><br><span class="line">    id    INT AUTO_INCREMENT,</span><br><span class="line">    name  CHAR(10),</span><br><span class="line">    sex   CHAR(5),</span><br><span class="line">    age   INT(2),</span><br><span class="line">    grade INT(2),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) CHARSET = utf8;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; DROP TABLE &lt;表名&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="向表中插入记录"><a href="#向表中插入记录" class="headerlink" title="向表中插入记录"></a>向表中插入记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; INSERT INTO &lt;表名&gt; (字段名1, [...]) VALUES (值1, [...]);</span><br></pre></td></tr></table></figure>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SELECT &lt;字段名&gt;, [...] FROM &lt;表名&gt; [WHERE字句] [LIMIT字句];</span><br></pre></td></tr></table></figure>
<ul>
<li>可用<code>*</code>替换字段名表示查询所有字段</li>
<li>WHERE字句包含了查询条件</li>
<li>LIMIT字句包含了需要返回的记录数量</li>
</ul>
<h4 id="WHERE字句"><a href="#WHERE字句" class="headerlink" title="WHERE字句"></a>WHERE字句</h4><p>格式<br><code>WHERE 对象1[关系]对象1的值 [AND|OR] [...]</code><br>例如：查询男生的成绩<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SELECT grade FROM student_grade WHERE sex=<span class="string">'男'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; UPDATE &lt;表名&gt; SET &lt;字段名&gt;=&lt;值&gt;, [...] [WHERE字句];</span><br></pre></td></tr></table></figure>
<h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; DELETE FROM &lt;表名&gt; [WHERE字句];</span><br></pre></td></tr></table></figure>
<h3 id="模糊查询：LIKE子句"><a href="#模糊查询：LIKE子句" class="headerlink" title="模糊查询：LIKE子句"></a>模糊查询：LIKE子句</h3><p>例如查询李姓同学的记录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM student_grade WHERE name LIKE <span class="string">'李'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="修改字段信息：ALTER命令"><a href="#修改字段信息：ALTER命令" class="headerlink" title="修改字段信息：ALTER命令"></a>修改字段信息：ALTER命令</h3><p>删除字段<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;;</span><br></pre></td></tr></table></figure></p>
<p>添加字段：ADD子句<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ALTER TABLE &lt;表名&gt; ADD &lt;字段名&gt;&lt;类型&gt;[AFTER &lt;已有字段名&gt;|FIRST];</span><br></pre></td></tr></table></figure></p>
<p>修改字段类型<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;类型定义&gt;;</span><br></pre></td></tr></table></figure></p>
<p>修改字段名<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ALTER TABLE &lt;表名&gt; CHANGE &lt;需修改字段名&gt; &lt;新字段名&gt; &lt;类型定义&gt;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL安装</title>
    <url>/2019/10/11/mysql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Windows下安装MySQL"><a href="#Windows下安装MySQL" class="headerlink" title="Windows下安装MySQL"></a>Windows下安装MySQL</h2><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL官网下载地址</a></p><h3 id="下载MySQL安装文件"><a href="#下载MySQL安装文件" class="headerlink" title="下载MySQL安装文件"></a>下载MySQL安装文件</h3><p>在下载页面中<code>Select Platform</code>选择<code>Microsoft Windows</code>, 然后在下方的下载选项中选择点击第一个<code>Downloads</code>下载:<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/mysql_install_1_1.png" alt="1.1"><br>跳转到另一个个页面后点击左下角<code>No thanks, just start my download.</code>:<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/mysql_install_1_2.png" alt="1.2"><br>开始下载。下载后得到一个.zip文件。将其解压得到类似<code>mysql-8.0.17-winx64</code>这样的文件夹。<br>将得到的文件夹放入C盘中的DB文件夹中(这里的DB为新建文件夹)得到mysql安装路径为<code>C:\DB\mysql-8.0.17-winx64</code></p><a id="more"></a>

<h3 id="MySQL配置文件"><a href="#MySQL配置文件" class="headerlink" title="MySQL配置文件"></a>MySQL配置文件</h3><ol>
<li>打开文件夹<code>C:\DB\mysql-8.0.17-winx64</code>,新建<code>my.ini</code>配置文件</li>
<li>编辑 my.ini 配置以下基本信息,其中的<code>basedir</code>设置为自己安装文件的路径：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line">port = 3306</span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line">basedir=C:\DB\mysql-8.0.17-winx64</span><br><span class="line"><span class="comment"># 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</span></span><br><span class="line"><span class="comment"># datadir=C:\\web\\sqldata</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=20</span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="启动MySQL"><a href="#启动MySQL" class="headerlink" title="启动MySQL"></a>启动MySQL</h3><p>注：以下命令最好在有管理员权限的cmd中运行<br>切换目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\DB\mysql-8.0.17-winx64\bin</span><br></pre></td></tr></table></figure></p>
<p>初始化数据库<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure></p>
<p>执行完成后，会输出 root 用户的初始默认密码，如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2019-05-10T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated <span class="keyword">for</span> root@localhost: APsCY5wg&amp;hgQ</span><br></pre></td></tr></table></figure></p>
<p><code>APsCY5wg&amp;hgQ</code>即为localhost主机下root用户名的初始密码<br>安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld install</span><br></pre></td></tr></table></figure></p>
<p>启动服务<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure></p>
<h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h 主机名 -u 用户名 -p</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>世界那么大-出去看看</title>
    <url>/2019/10/11/science-internet/</url>
    <content><![CDATA[<p>知识不分边界，在这广袤的土地上寻求知识吧</p><h2 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h2><h3 id="购买一台VPS服务器"><a href="#购买一台VPS服务器" class="headerlink" title="购买一台VPS服务器"></a>购买一台VPS服务器</h3><p><a href="https://bwh88.net/index.php" target="_blank" rel="noopener">BanWaGong</a>挺不错</p><h3 id="远程登录服务器"><a href="#远程登录服务器" class="headerlink" title="远程登录服务器"></a>远程登录服务器</h3><a id="more"></a>

<p>Windows可用<a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">Xshell</a>等远程工具</p>
<h3 id="为服务器部署linux系统，最合适的系统为Centos-6-x86-64-bbr"><a href="#为服务器部署linux系统，最合适的系统为Centos-6-x86-64-bbr" class="headerlink" title="为服务器部署linux系统，最合适的系统为Centos 6 x86_64-bbr"></a>为服务器部署linux系统，最合适的系统为<code>Centos 6 x86_64-bbr</code></h3><h2 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h2><h3 id="安装基本工具"><a href="#安装基本工具" class="headerlink" title="安装基本工具"></a>安装基本工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install wget</span><br></pre></td></tr></table></figure>
<h3 id="安装核心工具SS"><a href="#安装核心工具SS" class="headerlink" title="安装核心工具SS"></a>安装核心工具SS</h3><p>下载工具SS，在服务器终端以root身份执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget — no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="修改执行权限"><a href="#修改执行权限" class="headerlink" title="修改执行权限"></a>修改执行权限</h3><p>执行命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod +x shadowsocks.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="运行安装"><a href="#运行安装" class="headerlink" title="运行安装"></a>运行安装</h3><p>执行命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure></p>
<h3 id="安装过程中"><a href="#安装过程中" class="headerlink" title="安装过程中"></a>安装过程中</h3><p>执行刚刚的命令后，开始安装SS，安装过程中会有修改端口、密码等提示，可修改也可遵从默认，接着会选择加密方式，这里选择<code>aes-256-cfb</code></p>
<h3 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h3><p>完成安装后，会显示你的所有配置信息:端口，密码，加密方式等以供记忆。</p>
<h2 id="三、写在后面"><a href="#三、写在后面" class="headerlink" title="三、写在后面"></a>三、写在后面</h2><p>请合理使用SS工具，学习自己所需要的知识，毕竟工具开发原作者曾被请去喝茶，之后便不再维护了。</p>
<h4 id="爱祖国，爱社会"><a href="#爱祖国，爱社会" class="headerlink" title="爱祖国，爱社会"></a>爱祖国，爱社会</h4>]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>get小技能</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/2019/10/10/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>记录学习的一些Git常用命令</p><h2 id="git本地操作"><a href="#git本地操作" class="headerlink" title="git本地操作"></a>git本地操作</h2><h3 id="生成git仓库"><a href="#生成git仓库" class="headerlink" title="生成git仓库"></a>生成git仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><h3 id="从当前git仓库添加并提交文件"><a href="#从当前git仓库添加并提交文件" class="headerlink" title="从当前git仓库添加并提交文件"></a>从当前git仓库添加并提交文件</h3><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add . | git add &lt;filename&gt;</span><br><span class="line">$ git commit -m <span class="string">"注释"</span></span><br></pre></td></tr></table></figure>
<p>上述第一条命令的作用为添加目录下所有文件到仓库或者添加单个文件到暂存仓库，第二条命令的作用是提交添加的所有文件到当前分支。<br>每一次修改，如果不用git add将其放入仓库，则在使用git commit时则不会对其提交</p>
<h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><ol>
<li><p>查看git仓库的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件的改动信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ol>
<li><p>查看日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>回退上一个版本：HEAD^  回退上上一个版本：HEAD^^（HEAD^n）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看历史命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ol>
<li><p>撤销工作区的修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销暂存区的修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>从版本库中删除并提交<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;filename&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><h3 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure>
<h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">"邮箱"</span></span><br><span class="line">$ git config --global user.name <span class="string">"用户名"</span></span><br></pre></td></tr></table></figure>
<h3 id="提交文件到远程仓库"><a href="#提交文件到远程仓库" class="headerlink" title="提交文件到远程仓库"></a>提交文件到远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin master git@github.com:username/repository.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>第二行命令有可选参数<code>-f</code>意为强制提交</p>
<h3 id="另一方使用同一仓库，在push前需要拉取最新版本"><a href="#另一方使用同一仓库，在push前需要拉取最新版本" class="headerlink" title="另一方使用同一仓库，在push前需要拉取最新版本"></a>另一方使用同一仓库，在push前需要拉取最新版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull --rebase origin master</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>get小技能</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-模型实现</title>
    <url>/2019/09/15/%E8%A5%BF%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>基于周志华西瓜书中的数据集和各个机器学习模型的算法原理，采用python编写代码</p>
<h2 id="一-模型清单"><a href="#一-模型清单" class="headerlink" title="一. 模型清单"></a>一. 模型清单</h2><ul>
<li><strong>逻辑回归</strong></li>
<li><strong>线性判别分析</strong></li>
<li><strong>决策树</strong><ol>
<li>划分选择<ol>
<li>基于信息增益</li>
<li>基于基尼指数</li>
</ol>
</li>
<li>剪枝<ol>
<li>预剪枝</li>
<li>后剪枝 <a id="more"></a></li>
</ol>
</li>
</ol>
</li>
<li><strong>神经网络</strong><ol>
<li>标准BP算法</li>
</ol>
</li>
<li><strong>（待续）</strong><h2 id="二-代码清单"><a href="#二-代码清单" class="headerlink" title="二. 代码清单"></a>二. 代码清单</h2>代码中重要的部分都配有蹩脚的英文注释（T.T苦学英语ing），具体使用的数据集内容请参考代码引用和数据集清单。</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/logistic_regression.py" target="_blank" rel="noopener">logistic_regression</a>: 逻辑回归实现。</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/linear_discriminant_analysis.py" target="_blank" rel="noopener">linear_discriminant_analysis</a>: 线性判别分析实现。</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/decision_tree.py" target="_blank" rel="noopener">decision_tree</a>: 决策树实现，集成各个思想，包含划分方式有<code>信息增益</code>、<code>基尼指数</code>，连续值的处理方式有<code>平均值法</code>、<code>二分法</code>，以及剪枝方法有<code>预剪枝</code>、<code>后剪枝</code>。</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/neural_network.py" target="_blank" rel="noopener">neural_network</a>: 神经网络实现，标准BP算法。</li>
<li>（待续）<h2 id="三-数据集清单"><a href="#三-数据集清单" class="headerlink" title="三. 数据集清单"></a>三. 数据集清单</h2>均为csv文件，内容如下</li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/watermelon.csv" target="_blank" rel="noopener">西瓜数据集3.0alpha</a></li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/watermelon4.csv" target="_blank" rel="noopener">西瓜数据集2.0</a></li>
<li><a href="https://github.com/SkecisAI/ML-Practice/blob/master/watermelon3.csv" target="_blank" rel="noopener">西瓜数据集3.0</a></li>
</ul>
<p><em>才疏学浅，以上资料仅供参考，交流。</em></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
