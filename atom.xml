<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Liu&#39;s Blog</title>
  
  <subtitle>学习如逆水行舟，不进则退。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.skecis.top/"/>
  <updated>2022-03-03T10:11:11.214Z</updated>
  <id>http://www.skecis.top/</id>
  
  <author>
    <name>SkecisAI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="http://www.skecis.top/2022/01/27/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.skecis.top/2022/01/27/cpp学习笔记/</id>
    <published>2022-01-27T06:00:19.000Z</published>
    <updated>2022-03-03T10:11:11.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ol><li>函数名第一个字母大写，其后每个单词字母开头大写，驼峰式</li><li>变量名小写，单词之间下划线连接</li><li>类名，驼峰式。</li></ol><a id="more"></a><h2 id="第一部分：基础"><a href="#第一部分：基础" class="headerlink" title="第一部分：基础"></a>第一部分：基础</h2><ol><li>“\t”：水平制表符，占8个字符的位置，  若该字符前的字符不满8个，该字符补齐剩下的空位，满8个以上的，去除8倍数的字符，再补齐剩下的空位。例：<code>&quot;123456\t&quot;=&quot;123456__&quot;(&#39;_&#39;代表一个空格，此处两个空格)</code>，<code>&quot;12345678\t&quot;=&quot;12345678________&quot;</code>。</li><li>数组地址：数组名代表第一个数组元素的地址，<code>&amp;[数组名]</code>代表整个数组的地址。</li><li>宏与内联函数相关。</li><li>为函数参数添加默认值，方向必须是从右向左</li><li><strong>具体化函数模板</strong>，针对于特殊类型的操作：<code>template &lt;&gt; [返回类型][函数名]&lt;特殊类型&gt;(参数列表)</code>，<strong>注：普通函数模板并非定义，具体化函数模板才是具体类型的函数定义</strong></li></ol><ul><li>函数模板不能作为其他函数的参数，具体化的函数模板才能作为参数传递</li></ul><ol><li>使用名称空间中声明的变量，而不是使用全局变量</li><li><code>nullptr</code>表示空指针：<code>int* p = nullptr</code></li><li>定位new运算符：<code>new(指针名) classname</code>，将在指针所指向的空间中对class进行内存分配。</li><li>内联函数不需要寻址，当编译器执行到内联函数时直接将其展开，故内联函数以简洁为主。</li><li><p>嵌套模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br></pre></td></tr></table></figure></li><li><p>将模板作为参数：<code>template&lt;template&lt;typename T&gt; class [参数名]&gt;</code>，其中的参数必须是一个模板类。</p></li><li>字符串的输入：<ol><li><code>cin</code>：接受一个单词（用空格或换行符区分），<strong>会将换行符留在输入队列中</strong></li><li><code>getline()</code>：接受一行输入，以回车键为标志停止读取，<strong>且不保存换行符</strong></li><li><code>get()</code>：与前者功能相同，不同的是<strong>会将换行符留在输入队列中</strong>，解决办法是<code>get([字符串名], [大小]).get()</code>（或分开成两行，后者读取输入队列中的换行符）</li></ol></li><li>左值-变量；右值-常量或临时对象。左值引用不能指向右值，常左值引用可以指向右值（函数重载时，右值参数优先寻找右值引用，其次寻找常左值引用）</li><li>静态内容，将只在所声明的文件中可见</li><li>函数指针：<code>[返回类型] (*指针名)([参数列表])</code>，使用函数指针调用函数：<code>fun()或(*fun)()</code>都是可用的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">void</span> (*p1)() = add; <span class="comment">// void add() &#123;&#125;</span></span><br><span class="line">    <span class="keyword">void</span> (**p)() = &amp;p1; <span class="comment">// 二级函数指针指向一级函数指针的地址。</span></span><br><span class="line">    (*(*p))(); <span class="comment">// 调用add</span></span><br><span class="line"><span class="comment">///////////////</span></span><br><span class="line">    <span class="keyword">int</span> (**p1) () = <span class="keyword">new</span>(<span class="keyword">int</span>(*[<span class="number">2</span>])()); <span class="comment">// 函数指针数组</span></span><br><span class="line">    p1[<span class="number">0</span>] = add;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1[<span class="number">0</span>]();     <span class="comment">// 等于func()的调用形式</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*p1[<span class="number">0</span>])();  <span class="comment">// 等于(*fun)()的调用形式</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*(*p1[<span class="number">0</span>]))(); <span class="comment">// 等于(*fun)()的调用形式</span></span><br><span class="line">    ... <span class="comment">// 可以添加多个(*)等价于(*fun)()的调用形式</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="第二部分：面向对象"><a href="#第二部分：面向对象" class="headerlink" title="第二部分：面向对象"></a>第二部分：面向对象</h2><ol><li>创建对象：<code>ClassName object_name([参数列表])</code>或者列表初始化：<code>ClassName object_name = {[成员属性], }</code></li><li><code>this</code>：是指向<strong>调用对象</strong>的指针</li><li>类的友元函数是非成员函数，但其访问权限与成员函数相同。友元一般用于多个操作数的运算，且其中会使用到类的私有成员。</li><li><p>复制构造函数：<code>ClassName(const ClassName&amp;)</code>，默认复制构造函数逐个复制成员的值（浅复制），对应的（深度复制）：复制成员产生新的副本</p><ol><li>新建一个对象，并将其初始化为已有对象时</li><li>函数按值传递对象时（相当于创建原始变量的一个副本）</li><li>函数返回对象时（返回引用则不会调用，效率更高）</li></ol></li><li><p>先创建的对象后析构，后创建的对象先析构。析构函数的调用时机：在当时代码块结束时，析构在该代码块中定义的对象</p></li><li>静态类成员函数：<ol><li>对象不能调用</li><li>函数中只能使用静态成员</li></ol></li><li>类成员初始化列表：<code>Constructor():mem1(m1), mem2(m2), mem(m3) {...}</code>，初始化的顺序为他们被声明的顺序</li><li>基类先被初始化，再初始化派生类</li><li>基类指针或引用可以指向派生类，但不能使用派生类的方法</li><li>虚函数<code>virtual</code>：<strong>成员函数</strong>将根据引用或指针指向的对象类型是派生类还是基类来选择对应的方法</li><li><code>protected</code>保护成员：派生类的成员可以直接访问保护成员，而不能访问私有成员</li><li>包含纯虚函数的类不能被创建对象，即是抽象基类：<code>virtual void fun()=0</code></li><li>使用<code>explicit</code>防止单参数构造函数的隐式转换。</li><li>虚基类：当多个类继承同一个虚基类时，只产生一个副本。而非虚基类会为每个派生类产生一个副本。</li><li>模板类：<code>template&lt;class T&gt;</code></li><li>模板类的<strong>约束模板友元函数</strong>会在模板类中使用类的模板，<strong>非约束模板友元函数</strong>只使用新的模板</li><li>友元类：<code>friend class [classname]</code>，友元类的所有方法都可以访问原始类的私有成员和保护成员</li><li><p><strong>前向声明</strong>：<code>class [需要使用友元函数的类];</code>，防止友元函数的类与需要友元函数的类产生编译时的循环依赖。正确的顺序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> [使用友元函数的类];</span>  <span class="comment">// 前向声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> [友元函数的类] &#123;</span>&#125;  <span class="comment">//其中包含对另一个类私有或共有成员的使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> [使用友元函数的类] </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> [友元函数的类限定]::[函数名]([参数列表]);</span><br><span class="line">    ...</span><br><span class="line">&#125;  <span class="comment">//  包含友元函数的定义</span></span><br></pre></td></tr></table></figure></li><li><p><code>throw</code>抛出的异常被<code>catch</code>捕获，并且抛出的异常类型与捕获的异常类型所匹配</p></li><li>将基类异常放在<code>catch</code>层次的最后一层</li><li>类一旦定义了含有参数的构造函数，则将删掉类的默认无参构造函数</li><li>类和结构体中的静态成员要在外部初始化，因为静态成员不属于某一个实例</li></ol><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><ol><li><p>RTTI（运行阶段类型识别，动态类型转换）</p><ol><li><code>dynamic_cast&lt;Type *&gt;([指针p])</code>: 如果p是Type或其派生出来的，将成功转化为Type类型的指针。否则结果为<strong>空指针</strong></li><li><code>typeid</code>运算符返回<code>type_info</code>类，后者重载了<code>==</code>和<code>!=</code>运算符。</li></ol></li><li>智能指针：自动删除不需要的分配的堆内存。无需调用delete<ol><li><code>unique_ptr&lt;class&gt; [变量名](new class())</code>：只有一个智能指针可使用（没有复制构造函数）</li><li><code>shared_ptr&lt;class [变量名](new class())&gt;</code>：采用引用计数来跟踪指针，计数为0才将其释放掉</li></ol></li><li>函数适配器（<code>bind1st、bind2nd</code>）：用于在二元函数于一元函数之间转换</li></ol><h2 id="第四部分：C-11新特性"><a href="#第四部分：C-11新特性" class="headerlink" title="第四部分：C++11新特性"></a>第四部分：C++11新特性</h2><ol><li>新类型：<code>long long</code>和<code>unsigned long long</code></li><li>大括号用于初始化：<code>int x = {3}</code>、<code>int *p = new int [4] {1, 2, 3, 4}</code></li><li>模板类<code>std::initializer_list</code>，可用于常规函数的参数</li><li><code>decltype(x) y</code>：让y的类型与x相同，其中x是一个表达式</li><li>返回类型后置：<code>int add(double, int) = auto add(double, int) -&gt; int</code></li><li>创建别名：<code>using []=[]</code></li><li>类成员的初始化</li><li>新容器：forward_list、unordered_map、unordered_mulitmap、unordered_set、unordered_multiset</li><li>右值引用(右值为字面量)：<code>int&amp;&amp; r = 12</code></li><li>lambda表达式：<code>[可能要使用的外部变量](参数列表){语句块}</code></li><li><p>包装器(<code>include&lt;functional&gt;</code>)：<code>function&lt;[返回类型]([参数类型列表])&gt; 名称</code>，指向函数名、函数指针或lambda表达式。用于整合调用特征标相同的函数，即返回值和参数类型相同（例如让模板函数只实例化一次，缩小了可执行代码exe的规模）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>)&gt; fdd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">use_f</span><span class="params">(T t, function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>)&gt; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"use_f.\n"</span>;</span><br><span class="line"><span class="keyword">return</span> f(t); <span class="comment">// 在这里重载的括号运算符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> fp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Fp(<span class="keyword">double</span> z = <span class="number">1.0</span>) : fp(z) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor.\n"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> p)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator().\n"</span>; <span class="keyword">return</span> fp * p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; use_f&lt;<span class="keyword">double</span>&gt;(<span class="number">2.0</span>, Fp(<span class="number">3.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义移动构造函数会导致赋值运算符重载被删除然后报错：<code>...operator=(...).. cant be referenced--it is a deleted function.</code></p></li><li><code>override</code>：指出函数要覆盖一个虚方法。<code>final</code>：指出函数不能被重写</li><li>可变参数模板：<code>Arg... arg</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Args...&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t, <span class="keyword">const</span> Args&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用t</span></span><br><span class="line">    func(args...) <span class="comment">// 递归调用，对剩下的参数解包</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让递归终止的函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用t，不再递归调用func</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;命名规范&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;函数名第一个字母大写，其后每个单词字母开头大写，驼峰式&lt;/li&gt;
&lt;li&gt;变量名小写，单词之间下划线连接&lt;/li&gt;
&lt;li&gt;类名，驼峰式。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="程序语言" scheme="http://www.skecis.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="http://www.skecis.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>mysql中explain的使用</title>
    <link href="http://www.skecis.top/2021/03/04/mysql%E4%B8%ADexplain%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.skecis.top/2021/03/04/mysql中explain的使用/</id>
    <published>2021-03-04T02:44:05.000Z</published>
    <updated>2021-03-04T03:30:30.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure><p>explain用在查询语句之前，会输出一个表，表中的每个字段有着各自的含义：</p><a id="more"></a><ul><li><code>id</code>: select的标识符，自动分配且唯一</li><li><code>select_type</code>: select的查询类型</li><li><code>table</code>: 查询的表名称</li><li><code>partitions</code>: 匹配的分区</li><li><code>type</code>: join类型</li><li><code>possible_keys</code>: 有可能使用到的key</li><li><code>key</code>：真实使用的key</li><li><code>key_len</code>: 使用的key的字节长度</li><li><code>ref</code>: columns compared to index</li><li><code>rows</code>: 查询到的数据条数</li><li><code>extra</code>: 额外的信息</li></ul><h2 id="重要字段的说明"><a href="#重要字段的说明" class="headerlink" title="重要字段的说明"></a>重要字段的说明</h2><h3 id="select-type-查询的类型"><a href="#select-type-查询的类型" class="headerlink" title="select_type-查询的类型"></a>select_type-查询的类型</h3><ul><li><code>SIMPLE</code> – the query is a simple SELECT query without any subqueries or UNIONs：没有子查询和UNION语句</li><li><code>PRIMARY</code> – the SELECT is in the outermost query in a JOIN：最外层的查询</li><li><code>DERIVED</code> – the SELECT is part of a subquery within a FROM clause：在from中的子查询</li><li><code>SUBQUERY</code> – the first SELECT in a subquery：子查询中的第一个SELECT</li><li><code>DEPENDENT SUBQUERY</code> – a subquery which is dependent upon on outer query</li><li><code>UNCACHEABLE SUBQUERY</code> – a subquery which is not cacheable (there are certain conditions for a query to be cacheable)</li><li><code>UNION</code> – the SELECT is the second or later statement of a UNION</li><li><code>DEPENDENT UNION</code> – the second or later SELECT of a UNION is dependent on an outer query</li><li><code>UNION RESULT</code> – the SELECT is a result of a UNION</li></ul><h3 id="type-查询的效率"><a href="#type-查询的效率" class="headerlink" title="type-查询的效率"></a>type-查询的效率</h3><ul><li><code>system</code> – the table has only zero or one row: 查询结果只有一行或零行，特殊的const</li><li><code>const</code> – the table has only one matching row which is indexed. This is the fastest type of join because the table only has to be read once and the column’s value can be treated as a constant when joining other tables.：只有一行结果，且使用了索引</li><li><code>eq_ref</code> – all parts of an index are used by the join and the index is PRIMARY KEY or UNIQUE NOT NULL. This is the next best possible join type.：使用了索引的全部，并且索引是主键或唯一索引</li><li><code>ref</code> – all of the matching rows of an indexed column are read for each combination of rows from the previous table. This type of join appears for indexed columns compared using = or &lt;=&gt; operators.：所有匹配的行，使用=的操作符</li><li><code>fulltext</code> – the join uses the table’s FULLTEXT index.：全文索引的使用</li><li><code>ref_or_null</code> – this is the same as ref but also contains rows with a null value for the column.</li><li><code>index_merge</code> – the join uses a list of indexes to produce the result set. The key column of EXPLAIN‘s output will contain the keys used.:使用了一个索引列表产生的结果集（即包含多个索引）</li><li><code>unique_subquery</code> – an IN subquery returns only one result from the table and makes use of the primary key.</li><li><code>index_subquery</code> – the same as unique_subquery but returns more than one result row.</li><li><code>range</code> – an index is used to find matching rows in a specific range, typically when the key column is compared to a constant using operators like BETWEEN, IN, &gt;, &gt;=, etc.：范围查询</li><li><code>index</code> – the entire index tree is scanned to find matching rows.：整个索引树被扫描</li><li><code>all</code> – the entire table is scanned to find matching rows for the join. This is the worst join type and usually indicates the lack of appropriate indexes on the table.：全表扫描，效率最差</li></ul><p>效率从高到低：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</p><h3 id="key-len-索引的字节数"><a href="#key-len-索引的字节数" class="headerlink" title="key_len: 索引的字节数"></a>key_len: 索引的字节数</h3><ul><li>字符串<ul><li>char(n): n bytes</li><li>varchar(n): utf8=3n+2, utf8mb4=4n+2</li></ul></li><li>数值类型<ul><li>tinyint: 1 bytes</li><li>smallint: 2 bytes</li><li>mediumint: 3 bytes</li><li>int: 4 bytes</li><li>bigint: 8 bytes</li></ul></li><li>时间类型<ul><li>date: 3 bytes</li><li>timestamp: 4 bytes</li><li>datetime: 8 bytes</li></ul></li><li>字段属性: NULL 1 bytes, NOT NULL 0 bytes</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;explain&quot;&gt;&lt;a href=&quot;#explain&quot; class=&quot;headerlink&quot; title=&quot;explain&quot;&gt;&lt;/a&gt;explain&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;explain用在查询语句之前，会输出一个表，表中的每个字段有着各自的含义：&lt;/p&gt;
    
    </summary>
    
    
      <category term="程序语言" scheme="http://www.skecis.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="mysql" scheme="http://www.skecis.top/tags/mysql/"/>
    
      <category term="性能优化" scheme="http://www.skecis.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>枷锁</title>
    <link href="http://www.skecis.top/2020/12/14/%E6%9E%B7%E9%94%81/"/>
    <id>http://www.skecis.top/2020/12/14/枷锁/</id>
    <published>2020-12-14T00:08:42.000Z</published>
    <updated>2020-12-14T00:15:35.519Z</updated>
    
    <content type="html"><![CDATA[<p>乌黑，冰冷，坚硬，沉重的枷锁<br>它并不去断裂<br>而是融化在滚烫鲜红的血液里<br>留下一瞬的气泡，不断的破碎  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;乌黑，冰冷，坚硬，沉重的枷锁&lt;br&gt;它并不去断裂&lt;br&gt;而是融化在滚烫鲜红的血液里&lt;br&gt;留下一瞬的气泡，不断的破碎  &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.skecis.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.skecis.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>经典排序-思想解析</title>
    <link href="http://www.skecis.top/2020/12/02/%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%80%9D%E6%83%B3/"/>
    <id>http://www.skecis.top/2020/12/02/排序之思想/</id>
    <published>2020-12-02T02:23:15.000Z</published>
    <updated>2020-12-18T13:56:16.526Z</updated>
    
    <content type="html"><![CDATA[<p>阐述每种排序方法的思想与复杂度。假设数组大小为$n$，且<strong>从小到大</strong>排列。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>每一趟排序：<strong>两两元素进行比较并交换位置</strong>，核心代码如下</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i] &gt; a[i+<span class="number">1</span>])&#123;</span><br><span class="line">    tmp = a[i];</span><br><span class="line">    a[i] = a[i+<span class="number">1</span>];</span><br><span class="line">    a[i+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每一趟排序后，较大的数都被安排到了正确的位置。故只需n-1次排序即可排序完成</li><li>存在的问题是：假设在一堂排序后数组已为有序，则不需要后面的遍历与比较了。故优化的方法是，设置一个标志变量来判断数组是否已经有序了。</li></ol><ul><li>时间复杂度：$Average：O(n^{2})$，$Worst: O(n^{2})$</li><li>空间复杂度：$O(1)$</li><li>适用于$n$较小的数组</li><li><strong>稳定</strong>的排序方法</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>以第一个元素为首个基准，<strong>从下标1开始的每个元素寻找其插入位置</strong>，一躺排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length(); i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> insertVal = arr[i];   <span class="comment">// 记录待插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> insertIndex = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(insertIndex &gt;= <span class="number">0</span> &amp;&amp; arr[insertIndex] &gt; insertVal)&#123;</span><br><span class="line">        arr[insertIndex+<span class="number">1</span>] = arr[insertIndex];   <span class="comment">// 较大的元素向后移动</span></span><br><span class="line">        insertIndex--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(insertIndex + <span class="number">1</span> != i)&#123;   <span class="comment">// 发生了移动才交换</span></span><br><span class="line">        arr[insertIndex + <span class="number">1</span>] = insertVal; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>减少交换元素的操作，转而记录元素的正确位置</li></ol><ul><li>时间复杂度：$Average：O(n^{2})$</li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>也成<strong>缩小增量排序</strong>，对每个增量序列：<code>arr[i]..a[i+delta]..a[i+2*delta]..</code>进行插入排序，增量delta持续减小至1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = delta; i &lt; arr.length(); i++)&#123;  <span class="comment">// 从第dk个元素开始</span></span><br><span class="line">    <span class="keyword">int</span> insertVal = arr[i];   <span class="comment">// 记录待插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> insertIndex = i - delta;</span><br><span class="line">    <span class="keyword">while</span>(insertIndex &gt;= <span class="number">0</span> &amp;&amp; arr[insertIndex] &gt; insertVal)&#123;</span><br><span class="line">        arr[insertIndex + delta] = arr[insertIndex];   <span class="comment">// 下标差变为delta</span></span><br><span class="line">        insertIndex -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(insertIndex + delta != i)&#123;   <span class="comment">// 发生了移动才交换</span></span><br><span class="line">        arr[insertIndex + delta] = insertVal; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增量序列，数组大小为n</span></span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">    delta = n / <span class="number">2</span>;</span><br><span class="line">    n = n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对增量序列进行插入排序</li><li>效率比插入排序要好</li></ol><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>递归进行的排序，定义一个轴，使在数组中轴的一部分比轴小，另一部分比轴大:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一趟排序如下</span></span><br><span class="line"><span class="keyword">int</span> pivot = arr[l];</span><br><span class="line"><span class="keyword">int</span> low = l;</span><br><span class="line"><span class="keyword">int</span> high = r;</span><br><span class="line"><span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= pivot)&#123;</span><br><span class="line">        high--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = arr[high];  <span class="comment">// 找到了比轴小的数，移向low端，接着转而从low开始</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt; pivot)&#123;</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[high] = arr[low]; <span class="comment">// 找到了比轴大的数，移向high端</span></span><br><span class="line">&#125;</span><br><span class="line">arr[low] = pivot;   <span class="comment">// 将轴归位</span></span><br></pre></td></tr></table></figure><ol><li><strong>速度很快</strong>。但会利用到递归过程中的<strong>栈空间</strong></li><li>时间复杂度：$O(n\log_{2}n)$</li></ol><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>采用了<strong>分而治之</strong>的思想，并利用了<strong>递归</strong>。需要一个临时数组存储<strong>有序序列</strong>，再将其拷贝至原数组。</p><h4 id="分过程：不断把数组划分为左右两个子数组"><a href="#分过程：不断把数组划分为左右两个子数组" class="headerlink" title="分过程：不断把数组划分为左右两个子数组"></a>分过程：不断把数组划分为左右两个子数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">divide(arr, tmp, l, r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        divide(arr, tmp, l, mid);  <span class="comment">// 左部分</span></span><br><span class="line">        divide(arr, tmp, mid+<span class="number">1</span>, r);  <span class="comment">// 右部分</span></span><br><span class="line">        merge(arr, tmp, l, mid+<span class="number">1</span>, r) <span class="comment">// 合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合过程：将两个有序数组合并"><a href="#合过程：将两个有序数组合并" class="headerlink" title="合过程：将两个有序数组合并"></a>合过程：将两个有序数组合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">merge(arr, tmp, i, j, r)&#123;</span><br><span class="line">    <span class="keyword">int</span> k = l;</span><br><span class="line">    <span class="keyword">int</span> left = i;</span><br><span class="line">    <span class="keyword">int</span> mid = j - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 逐个选取两个数组中最小的数放进tmp中</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[j])&#123;</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k++] = arr[j++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放入某个数组剩余的部分</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        tmp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)&#123;</span><br><span class="line">        tmp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将有序数组重新放回到原数组中</span></span><br><span class="line">    <span class="keyword">int</span> left2 = left;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= r)&#123;</span><br><span class="line">        arr[left++] = tmp[left2++]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>利用到了递归的栈空间</li><li>时间复杂度与栈的深度有关。一般为$O(n\log_{2}n)$</li></ol><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h4><p>对于数组$a[n]$:</p><script type="math/tex; mode=display">大顶堆\left\{\begin{matrix}a[i] >= a[2i]\\ a[i] >= a[2i+1]\end{matrix}\right.或小顶堆\left\{\begin{matrix}a[i] <= a[2i]\\ a[i] <= a[2i+1]\end{matrix}\right.</script><p>类比二叉树的概念：<strong>根的值大于或小于左右子树的值</strong></p><h4 id="利用堆进行排序"><a href="#利用堆进行排序" class="headerlink" title="利用堆进行排序"></a>利用堆进行排序</h4><p>两个关键过程：</p><ul><li><p>将指定节点下的数调整为一个堆：<strong>从最后一个非终端节点$\left \lfloor \frac{n}{2} \right \rfloor$倒序一个个调整，调整其及子树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">adjustHeap(arr, i, n)&#123;</span><br><span class="line">    <span class="keyword">int</span> v = arr[i];</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*i &lt;= n &amp;&amp; arr[i] &gt; arr[<span class="number">2</span>*i])&#123;</span><br><span class="line">        arr[i] = arr[<span class="number">2</span>*i];</span><br><span class="line">        arr[<span class="number">2</span>*i] = v;</span><br><span class="line">        adjustHeap(arr, <span class="number">2</span>*i, n);  <span class="comment">// 递归调整下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    v = arr[i];</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span> &lt;= n &amp;&amp; arr[i] &gt; arr[<span class="number">2</span>*i+<span class="number">1</span>])&#123;</span><br><span class="line">        arr[i] = arr[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">2</span>*i+<span class="number">1</span>] = v;</span><br><span class="line">        adjustHeap(arr, <span class="number">2</span>*i+<span class="number">1</span>)   <span class="comment">// 递归调整下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取堆顶的元素后调整：<strong>将最后一个元素放到根$0$的位置上，调整该节点以及子树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">heapSort(arr)&#123;</span><br><span class="line">    调整初始数组为一个堆</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = arr[<span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">1</span>] = arr[n-i];</span><br><span class="line">        arr[n-i] = v;   <span class="comment">// 最小的数在后面：结果为从大到小</span></span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, n-i-<span class="number">1</span>);  <span class="comment">// n-i-1: 堆大小减1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>堆排序适用于n较大的数组</li><li>时间主要用在初始堆的建立过程中</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阐述每种排序方法的思想与复杂度。假设数组大小为$n$，且&lt;strong&gt;从小到大&lt;/strong&gt;排列。&lt;/p&gt;&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;p&gt;每一趟排序：&lt;strong&gt;两两元素进行比较并交换位置&lt;/strong&gt;，核心代码如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.skecis.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://www.skecis.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://www.skecis.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>决策树算法解析</title>
    <link href="http://www.skecis.top/2020/10/27/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://www.skecis.top/2020/10/27/决策树/</id>
    <published>2020-10-27T08:23:36.000Z</published>
    <updated>2020-10-31T05:47:30.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设样本有$m$个类别，$v$是属性中不同值的数量</p></blockquote><h2 id="ID3算法-信息熵"><a href="#ID3算法-信息熵" class="headerlink" title="ID3算法-信息熵"></a>ID3算法-信息熵</h2><h3 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h3><p>分类所期望的信息量: $I=-\sum_{i=1}^{m}\frac{s_{i}}{s}log_{2}(\frac{s_{i}}{s})$</p><a id="more"></a><h3 id="信息熵（加权）"><a href="#信息熵（加权）" class="headerlink" title="信息熵（加权）"></a>信息熵（加权）</h3><p>为了得到准确的分类还需要多少期望信息量，即让划分的每种属性都有相同的类别。<strong>值越小分类就越准确</strong></p><script type="math/tex; mode=display">E(属性A)=\sum_{j=1}^{v}\frac{s_{1j}+\dotsb+s_{mj}}{s}I(s_{1j},\dotsc,s_{mj})</script><p><strong>可理解为将该属性划分的每个节点的信息熵加权平均得到的</strong>$E(属性)$</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>信息增益=原来的信息期望量-基于属性划分后的信息需求。基于属性划分后的信息需求即信息熵越小，信息增益就越大。故应选择这样的划分。</p><script type="math/tex; mode=display">Gain(属性A)=I-E(属性A)</script><h2 id="C4-5算法-信息增益率"><a href="#C4-5算法-信息增益率" class="headerlink" title="C4.5算法-信息增益率"></a>C4.5算法-信息增益率</h2><p>为了解决<strong>与每个划分相关联的记录太少，以致预测不可靠</strong>。把属性测试条件产生的输出也考虑进去。</p><h3 id="分裂信息（Split-Info）"><a href="#分裂信息（Split-Info）" class="headerlink" title="分裂信息（Split Info）"></a>分裂信息（Split Info）</h3><script type="math/tex; mode=display">SplitInfo=-\sum_{i=1}^{k}P(v_{i})log_{2}P(v_{i}),k是划分总数，v_{i}是子女节点样本数占比</script><h3 id="信息增益率（Gain-Ratio）"><a href="#信息增益率（Gain-Ratio）" class="headerlink" title="信息增益率（Gain Ratio）"></a>信息增益率（Gain Ratio）</h3><script type="math/tex; mode=display">GainRatio=\frac{\Delta_{info}}{SplitInfo}</script><p>增益率可以说明：<strong>大量的划分会导致信息增益率很小</strong></p><script type="math/tex; mode=display">k是属性的划分总数，若每个属性值有着相同的样本数n，则父节点有kn个样本。\\则P(v_{i})=\frac{n}{kn}=\frac{1}{k},SplitInfo=-\sum_{i=1}^{k}\frac{1}{k}log_{2}\frac{1}{k}=log_{2}k</script><p>属性划分$k$越大，会导致$SplitInfo$越大，则$GainRatio$越小</p><h2 id="CART算法-Gini不纯度"><a href="#CART算法-Gini不纯度" class="headerlink" title="CART算法-Gini不纯度"></a>CART算法-Gini不纯度</h2><h3 id="Gini不纯度（指数）"><a href="#Gini不纯度（指数）" class="headerlink" title="Gini不纯度（指数）"></a>Gini不纯度（指数）</h3><p>$p(i|t)-节点t中属于类i的记录占比$</p><script type="math/tex; mode=display">Gini(t)=1-\sum_{i=0}^{c-1}[p(i|t)]^2,c是类别数量</script><h3 id="Gini指标的加权平均"><a href="#Gini指标的加权平均" class="headerlink" title="Gini指标的加权平均"></a>Gini指标的加权平均</h3><h2 id="不纯性度量的总结"><a href="#不纯性度量的总结" class="headerlink" title="不纯性度量的总结"></a>不纯性度量的总结</h2><p>不纯性度量的意义：<strong>不纯性度量的值越大，说明划分效果越差。当所有样本属于同一个类时，不纯性度量的值最小。</strong></p><ul><li>$Entropy(t)=-\sum_{i=0}^{c-1}p(i|t)log_{2}p(i|t)$</li><li>$Gini(t)=1-\sum_{i=0}^{c-1}[p(i|t)]^2$</li><li>$ClassificationError(t)=1-\max_{i}[p(i|t)]$</li></ul><p>最大化增益$\Delta$:</p><script type="math/tex; mode=display">\Delta=I(parent)-\sum_{j=1}^{k}\frac{N(v_{j})}{N}I(v_{j})</script><p>（其中$I(\cdot)$是节点的不纯性度量，$N$是父节点上的样本总数，$k$是不同属性值的个数，$N(v_{j})$是与子女节点$v_{j}$关联的节点数。）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设样本有$m$个类别，$v$是属性中不同值的数量&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;ID3算法-信息熵&quot;&gt;&lt;a href=&quot;#ID3算法-信息熵&quot; class=&quot;headerlink&quot; title=&quot;ID3算法-信息熵&quot;&gt;&lt;/a&gt;ID3算法-信息熵&lt;/h2&gt;&lt;h3 id=&quot;信息量&quot;&gt;&lt;a href=&quot;#信息量&quot; class=&quot;headerlink&quot; title=&quot;信息量&quot;&gt;&lt;/a&gt;信息量&lt;/h3&gt;&lt;p&gt;分类所期望的信息量: $I=-\sum_{i=1}^{m}\frac{s_{i}}{s}log_{2}(\frac{s_{i}}{s})$&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.skecis.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数据分析" scheme="http://www.skecis.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="数据挖掘" scheme="http://www.skecis.top/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="决策树" scheme="http://www.skecis.top/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>链表环-快慢指针的数学原理</title>
    <link href="http://www.skecis.top/2020/10/09/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    <id>http://www.skecis.top/2020/10/09/循环链表快慢指针/</id>
    <published>2020-10-09T09:40:57.000Z</published>
    <updated>2021-12-02T12:41:46.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>设<strong>快指针</strong>在<strong>慢指针</strong>距离1格，快指针每次移动2格，满指针每次移动1格。当两个指针都进入环后，那么移动$n$次且相遇时有：</p><script type="math/tex; mode=display">此处：(2n+1)\%s=n\%s=m,s为环的长度（不是链表长度）\\设:2n+1=s*k_{1}+m,k_{1}\in Z\\n=s*k_2+m,k_{2}\in Z\\得：n+1=s*(k_{1}-k_{2}),(k_{1},k_{2}\in Z,k_{1}>k_{2} )</script><p><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/%E5%9B%BE%E8%A7%A3.png" alt="图解"></p><p>$k_{1}$与$k_{2}$取合适的整数时，此方程的n有解。<strong>故若链表中存在环，那么快慢指针必定会相遇。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hasCycle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ListNode head)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(head == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode slow = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode fast = head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(slow != fast)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(fast == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || fast.next == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            slow = slow.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fast = fast.next.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.skecis.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="循环链表" scheme="http://www.skecis.top/tags/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL四种隔离级别</title>
    <link href="http://www.skecis.top/2020/09/12/mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://www.skecis.top/2020/09/12/mysql隔离级别/</id>
    <published>2020-09-12T07:33:27.000Z</published>
    <updated>2020-09-12T08:18:59.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><ul><li>未提交读：READ UNCOMMITTED</li><li>提交读：READ COMMITTED</li><li>可重复读（默认）：REPEATABLE READ</li><li>可序列化：SERIALIZABLE</li></ul><a id="more"></a><p>设置隔离级别：<code>set session transaction isolation level read uncommitted;</code></p><h3 id="未提交读（read-uncommitted）"><a href="#未提交读（read-uncommitted）" class="headerlink" title="未提交读（read uncommitted）"></a>未提交读（read uncommitted）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line"><span class="comment"># 会话一</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment"># 如果执行回滚</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话二</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 会看到已经更改的name，发生脏读</span></span><br><span class="line"><span class="comment"># 如果会话一的事务回滚，再执行。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 会发现name恢复原值</span></span><br></pre></td></tr></table></figure><p>发生<strong>脏读</strong></p><h3 id="提交读（read-committed）"><a href="#提交读（read-committed）" class="headerlink" title="提交读（read committed）"></a>提交读（read committed）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line"><span class="comment"># 会话一</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment"># 提交事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话二</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 无法看到会话一修改后的name</span></span><br><span class="line"><span class="comment"># 如果会话一的事务提交，再执行。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 会发现name的值发生更改。得到两次不同的结果</span></span><br></pre></td></tr></table></figure><p>可以避免<strong>脏读</strong>，但是发生<strong>不可重复读</strong></p><h3 id="可重复读（repeatable-read）"><a href="#可重复读（repeatable-read）" class="headerlink" title="可重复读（repeatable read）"></a>可重复读（repeatable read）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"><span class="comment"># 会话一</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment"># 提交事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话二</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;  <span class="comment"># 开启事务</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 无法看到会话一修改后的name</span></span><br><span class="line"><span class="comment"># 如果会话一的事务提交，再执行。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 无法看到会话一修改后的name</span></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment"># 提交事务后再查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment"># 会发现name的值发生更改</span></span><br></pre></td></tr></table></figure><p>可以避免<strong>脏读</strong>和<strong>不可重复读</strong>，但是无法避免<strong>幻读</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"><span class="comment"># 会话一</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;  <span class="comment"># 6行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'hhh'</span>; <span class="comment"># 等待会话一的事务提交后，执行。</span></span><br><span class="line"><span class="comment"># 出现：7 rows affected</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话二</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;  <span class="comment"># 6行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span> (... ...); <span class="comment"># 插入一行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>发生<strong>幻读</strong>（即出现了新的数据）</p><h3 id="可串行化（serializable）"><a href="#可串行化（serializable）" class="headerlink" title="可串行化（serializable）"></a>可串行化（serializable）</h3><p>事务的串行执行。即一个事务提交后，另一个事务的操作才能执行，否则发生阻塞。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;四种隔离级别&quot;&gt;&lt;a href=&quot;#四种隔离级别&quot; class=&quot;headerlink&quot; title=&quot;四种隔离级别&quot;&gt;&lt;/a&gt;四种隔离级别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;未提交读：READ UNCOMMITTED&lt;/li&gt;
&lt;li&gt;提交读：READ COMMITTED&lt;/li&gt;
&lt;li&gt;可重复读（默认）：REPEATABLE READ&lt;/li&gt;
&lt;li&gt;可序列化：SERIALIZABLE&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="程序语言" scheme="http://www.skecis.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="数据库" scheme="http://www.skecis.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="http://www.skecis.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记</title>
    <link href="http://www.skecis.top/2020/07/23/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.skecis.top/2020/07/23/java学习笔记/</id>
    <published>2020-07-23T08:17:21.000Z</published>
    <updated>2020-10-22T08:42:46.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><ul><li>基本类型：<code>byte, short, int, long, float, double, boolean, char</code></li><li>引用类型：<code>String, 类</code></li></ul><a id="more"></a><p>注：</p><ol><li>整数常量默认int型</li><li>对long型常量末尾加<code>l</code>或<code>L</code></li><li>浮点数常量默认double型</li><li>对float型常量末尾加<code>f</code>或<code>F</code></li><li>char赋值不能为空(String可以为””):<code>Error: char c = &#39;&#39;;</code></li><li>大转小-位截断</li></ol><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(object e: object[])&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><h3 id="4种访问权限修饰符"><a href="#4种访问权限修饰符" class="headerlink" title="4种访问权限修饰符"></a>4种访问权限修饰符</h3><ul><li>private：私有的，只有类的内部可访问</li><li>缺省的：与private相比，多了同一个包。</li><li>protected：保护的，与缺省的相比，多了一个不同包的子类</li><li>public：公有的，整个工程。</li></ul><p>范围：类内部&lt;同一个包&lt;不同包&lt;工程范围(private&lt;缺省&lt;protected&lt;public)。<em>不同包可以创建相同的类不冲突</em>。<br>修饰类的成员：变量、方法<br>类的修饰：缺省和public</p><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><ul><li>package关键字：申明java文件的包名或路径，”xxx.xxx.xxx”每一个“.”代表分了一层目录。同一个包下，不能有相同的接口和类</li><li>import关键字：导包必须，显示导入类或接口</li></ul><p><code>import static</code> 导入类或接口中的静态结构：属性或方法</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> | <span class="keyword">private</span> | <span class="keyword">protected</span>] classname (参数列表)&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<strong>类有默认无参构造器，构造器可以重载，一旦显式提供构造器后，默认无参构造器不再有效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this 调用构造器</span></span><br><span class="line"><span class="keyword">this</span>()  <span class="comment">// 只能放在首行</span></span><br><span class="line"><span class="comment">// 用于多个构造器的重载</span></span><br></pre></td></tr></table></figure><ul><li><strong>重载</strong>：更改同名函数的参数个数和类型实现重载。</li></ul><h3 id="继承-Inherit"><a href="#继承-Inherit" class="headerlink" title="继承(Inherit)"></a><strong>继承</strong>(<strong>Inherit</strong>)</h3><ol><li>子类拥有父类的<strong>非private方法和属性</strong></li><li>子类可以<strong>重写</strong>父类的方法</li><li>只能<strong>单继承</strong></li><li>提高了类间的耦合性</li><li>子类使用<strong>super构造器</strong>调用父类结构：属性和方法。</li><li>所有类缺省继承lang包下的Object类。</li><li><strong>同名变量的搜寻，就近原则</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;  <span class="comment">// 只有非私有属性，方法被继承</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String major;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, age, String major)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>在子类中对继承的类中的方法进行改造（重写）并覆盖。</p><ol><li>重写的方法修饰符权限 &gt;= 父类中被重写的方法权限</li><li>不能重写private修饰的父类方法</li><li>两者的返回值要么都是void或都相同，<strong>要么重写的方法返回值类型是父类中被重写方法的子类</strong>，基本类型必须相同。</li><li>子类重写的方法抛出的异常类型不大于父类中被重写的方法抛出的异常类型</li><li>static方法不可被重写</li></ol><p>同名属性优先使用子类属性，或使用super关键字调用父类属性。<strong>子类会默认调用父类的super()空参构造器</strong>，一个类的构造器首行只能是super()或this()。</p><h4 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h4><ol><li>子类继承父类后，获取了父类中所有的属性和方法。</li><li>子类创建过程中，直接或间接的通过super关键字调用了父类的构造器。</li><li>只是调用父类的构造器，并没有创建父类的实例</li></ol><h3 id="多态-Polymorphic"><a href="#多态-Polymorphic" class="headerlink" title="多态(Polymorphic)"></a><strong>多态</strong>(<strong>Polymorphic</strong>)</h3><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象</li><li>（向上转型）使用多态方式调用方法时，首先检查父类中是否有该方法，没有则编译错误；如果有，再去调用子类的同名方法</li><li><strong>运行时行为</strong></li><li>虚方法，动态绑定，运行时才确定方法，晚绑定</li></ol><p>多态的实现方式：</p><ul><li>有继承</li><li>有重写</li><li>接口</li><li>抽象方法和抽象类</li></ul><h4 id="向上转型与向下转型（多态性）"><a href="#向上转型与向下转型（多态性）" class="headerlink" title="向上转型与向下转型（多态性）"></a>向上转型与向下转型（多态性）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Father f = <span class="keyword">new</span> Son();   <span class="comment">// 向上转型，**子类结构已经加载到内存**</span></span><br><span class="line"></span><br><span class="line">Son s = (Son)f;         <span class="comment">// 向下转型</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Animal a1 = <span class="keyword">new</span> Bird(); <span class="comment">// 向上转型</span></span><br><span class="line">Animal a2 = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">System.out.println(a1 <span class="keyword">instanceof</span> Animal);   <span class="comment">// true</span></span><br><span class="line">System.out.println(a1 <span class="keyword">instanceof</span> Bird);     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Bird b1 = (Bird) a1;    <span class="comment">// 向下转型，**内存上是地址的改变** [class@address]</span></span><br><span class="line">System.out.println(b1 <span class="keyword">instanceof</span> Animal);  <span class="comment">// true</span></span><br><span class="line">System.out.println(b1 <span class="keyword">instanceof</span> Bird);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">Object ob = <span class="keyword">new</span> Bird();</span><br><span class="line">Animal a = (Animal)ob;</span><br><span class="line"><span class="comment">// **错误**的向下转型</span></span><br><span class="line">Father f = <span class="keyword">new</span> Father();</span><br><span class="line">Son s = (Son)f;         <span class="comment">// error：抛出类型转换错误</span></span><br></pre></td></tr></table></figure><ul><li><strong>向上转型</strong>：父类引用指向子类对象（这里的父类可以是接口），不能调用与父类不同的特有的子类方法。</li><li><strong>向下转型</strong>：使用强制类型转换，可以调用子类的特有方法。</li><li><code>a instanceof B</code>: B与B的父类使其等价。</li></ul><p>编译看左边，运行看右边。</p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul><li>clone()方法：克隆对象</li><li>equals()方法：判断对象的值是否相等</li></ul><h4 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals"></a>== 与 equals</h4><p>== 运算符：</p><ol><li>可用于基本数据类型和引用数据类型。</li><li>对于基本数据类型的比较，比较的是存储的值。</li><li>对于引用类型的数据，比较的是指向的地址值。</li></ol><p>equals方法：</p><ol><li>只适用于引用型数据类型</li><li>用于比较对象间的值是否相同，自定义类需要重写equals方法。（继承自Object，重写前等价于==）</li></ol><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>使基本数据类型具有类的特征。主要用于：基本数据类型-包装类-String，三者之间的转换</p><div class="table-container"><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">包装类</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center"><strong>Byte</strong></td></tr><tr><td style="text-align:center">short</td><td style="text-align:center"><strong>Short</strong></td></tr><tr><td style="text-align:center">int</td><td style="text-align:center"><strong>Integer</strong></td></tr><tr><td style="text-align:center">long</td><td style="text-align:center"><strong>Long</strong></td></tr><tr><td style="text-align:center">float</td><td style="text-align:center"><strong>Float</strong></td></tr><tr><td style="text-align:center">double</td><td style="text-align:center"><strong>Double</strong></td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"><strong>Boolean</strong></td></tr><tr><td style="text-align:center">char</td><td style="text-align:center"><strong>Character</strong></td></tr></tbody></table></div><p>装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">Integer i = a;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"232"</span>;</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(s);</span><br><span class="line"></span><br><span class="line">Boolean b1 = <span class="keyword">new</span> Boolean(<span class="string">"true"</span>);  <span class="comment">// true</span></span><br><span class="line">Boolean b2 = <span class="keyword">new</span> Boolean(<span class="string">"true123"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">int</span> i = i.intValue();  <span class="comment">// xxxValue()方法调用</span></span><br></pre></td></tr></table></figure><h4 id="自动装箱与自动拆箱-JDK-5-0"><a href="#自动装箱与自动拆箱-JDK-5-0" class="headerlink" title="自动装箱与自动拆箱 (JDK 5.0+)"></a>自动装箱与自动拆箱 (JDK 5.0+)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">method(a);  <span class="comment">// int-&gt;Integer-&gt;Object, 自动装箱+向上转型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动装箱：<code>Integer a = 12;</code></li><li>自动拆箱：<code>int b = a;</code></li><li>转String转：valueof() 与 parseXXX()<ol><li><code>String s = [int|double|float|byte] + &quot;&quot;;</code></li><li><code>String s = String.valueOf([int|double|float|byte]) | String.valueOf(Object)</code></li><li><code>object o = Object.parseObj(String);</code></li></ol></li></ul><p><strong>面试题</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一题：</span></span><br><span class="line">Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">1.2</span>);</span><br><span class="line">sysout(o1)  <span class="comment">// 1.0 自动类型提升</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二题：</span></span><br><span class="line">Integer aa = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer bb = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(aa == bb);  <span class="comment">// false：两个对象的地址不同</span></span><br><span class="line"></span><br><span class="line">Integer m = <span class="number">1</span>;</span><br><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line">System.out.println(m == n);    <span class="comment">// true: Integer的内部类IntegerCache中有个int型的cache数组，里面存了-128~127这些数，该范围的数事先加载好了，每个数都有一个地址值。故在该范围的数，地址都相同</span></span><br><span class="line"></span><br><span class="line">Integer x = <span class="number">128</span>;</span><br><span class="line">Integer y = <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false：超过了-127-128这个范围，故都是要new一个Integer对象，故地址不同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer的私有静态内部类（私有的构造器），且有一个静态块</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h3><p>static：静态</p><ol><li>静态：<strong>不随外部的变化而变化，被所有对象共有，属于类本身</strong>。</li><li>可以修饰：属性、方法、代码块、内部类</li><li>静态成员随着类的加载而加载</li><li>静态变量不仅可以通过类调用</li><li>由于类只加载一次，故<strong>静态变量</strong>在内存中只有一份，<strong>存在方法区的静态域中</strong></li><li>静态方法中<strong>不能使用</strong>this、super、非静态变量。（生存周期的角度去理解）</li></ol><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>私有化构造器，使用类变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式: 提前新建好了，对象加载时间过长，但是线程安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();  <span class="comment">// 私有类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;   <span class="comment">// 私有构造器</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;   <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式: 需要时才新建对象，延迟对象的创建，线程不安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ol><li>存在于类内部，属于类成员。用来初始化类、对象</li><li>只能用static修饰，或者不修饰</li><li>静态代码块属于类，非静态代码块属于对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    String s = Block.s;       <span class="comment">// 输出 static code block</span></span><br><span class="line">    Block b1 = <span class="keyword">new</span> Block();   <span class="comment">// 输出 code block</span></span><br><span class="line">    Block b2 = <span class="keyword">new</span> Block();   <span class="comment">// 输出 code block</span></span><br><span class="line">    Block b3 = <span class="keyword">new</span> Block();   <span class="comment">// 输出 code block</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String s = <span class="string">"Block"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Block</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态代码块：</span></span><br><span class="line"><span class="comment">        1. 随着类的加载执行一次，后不再执行（按照声明的先后顺序执行多个）</span></span><br><span class="line"><span class="comment">        2. 只能调用静态的成员。</span></span><br><span class="line"><span class="comment">        3. 不能调用非静态结构</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        sysout(<span class="string">"static code block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        非静态代码块：</span></span><br><span class="line"><span class="comment">        1. 随着对象的创建执行，每次创建一次则执行一次（先执行代码块，再执行构造器，可以对对象进行初始化）</span></span><br><span class="line"><span class="comment">        2. 静态、非静态都可以调用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#123;</span><br><span class="line">        sysout(<span class="string">"code block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值顺序：默认赋值-&gt;(显示赋值-&gt;代码块赋值)-&gt;构造器</p><h3 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h3><ul><li>final修饰类: 不能被继承，不能被拓展，最终形态。</li><li>final修饰方法：不能被重写，最终版本。</li><li>final修饰变量：一旦被赋值，则不可修改。常量。</li></ul><p>类中的final变量初始化：显式、构造器、代码块。即在对象出生前，要被初始化</p><h2 id="抽象-Abstract"><a href="#抽象-Abstract" class="headerlink" title="抽象(Abstract)"></a><strong>抽象</strong>(<strong>Abstract</strong>)</h2><p>如果一个类中没有包含足够的信息来描绘一个具体的对象，那这个类就是抽象的。  </p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul><li>只属于抽象类：<strong>如果一个类包含抽象方法，那么该类必须是抽象类</strong></li><li>非抽象类（具体类）必须重写：任何子类<strong>必须重写父类的所有抽象方法，或者声明自身为抽象类</strong></li><li>没有方法体：声明为抽象方法时，不含方法体</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li><strong>抽象类不能被实例化</strong>。只有抽象类的非抽象子类可以创建对象</li><li>抽象类不一定包含抽象方法，<strong>包含抽象方法的类一定是抽象类</strong></li><li>可以是“模板类”，可以调用抽象方法。</li></ul><h3 id="匿名子类"><a href="#匿名子类" class="headerlink" title="匿名子类"></a>匿名子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    Male m = <span class="keyword">new</span> Male();</span><br><span class="line">    func(m);</span><br><span class="line"></span><br><span class="line">    func(<span class="keyword">new</span> Male());  <span class="comment">// 匿名对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了匿名类的对象p：向上转型</span></span><br><span class="line">    Person p = <span class="keyword">new</span> [匿名 extends]Person()&#123;  <span class="comment">//  抽象类的匿名子类</span></span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a><strong>封装</strong>(<strong>Encapsulation</strong>)</h2><ol><li>良好的封装可以减少耦合</li><li>类内部的结构可以自由修改</li><li>对成员变量精确控制</li><li>隐藏信息，实现细节</li></ol><h2 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口(Interface)"></a>接口(<strong>Interface</strong>)</h2><p>接口与类是并列的结构。</p><h3 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h3><ul><li><strong>接口不是类，没有构造器</strong></li><li>接口中的<strong>所有方法必须是抽象方法</strong></li><li>JDK7.0-：只能有全局常量（public static final, 可省略）和抽象方法，JDK8.0+：增加了静态方法和默认方法</li></ul><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul><li>接口中每一个方法被<strong>隐式指定且只能是</strong><code>public abstract</code></li><li>接口中的变量会被<strong>隐式指定且只能是</strong><code>public static final</code></li><li>接口中的方法不包含方法体，且只有两种结果：<ol><li>被抽象类实现，可以不含方法体</li><li>被具体类实现，必须重写方法体</li></ol></li><li>接口可以<strong>extends多继承</strong>多个接口</li></ul><p>接口的多态性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    USB usb = <span class="keyword">new</span> Printer();  <span class="comment">// 接口实现类的向上转型</span></span><br><span class="line">    transferData(usb);</span><br><span class="line">    transferData(<span class="keyword">new</span> Disk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">transferData</span><span class="params">(USB u)</span></span>&#123;  <span class="comment">// 多态</span></span><br><span class="line">    u.<span class="keyword">do</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<strong>接口是方法的规范，面向接口编程。</strong></p><h3 id="与抽象类的区别"><a href="#与抽象类的区别" class="headerlink" title="与抽象类的区别"></a>与抽象类的区别</h3><ul><li>抽象类中的方法可以有方法体，但是<strong>接口中所有的方法不能有方法体</strong></li><li>一个类只能继承一个抽象类，而<strong>一个类可以实现多个接口</strong></li><li>接口没有构造器</li></ul><h3 id="匿名实现类"><a href="#匿名实现类" class="headerlink" title="匿名实现类"></a>匿名实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上转型，多态</span></span><br><span class="line">Interface <span class="class"><span class="keyword">interface</span> </span>= <span class="keyword">new</span> [匿名] Interface&#123;...&#125;;  <span class="comment">// 匿名内部类，其实现了接口。省略号中包含方法体</span></span><br></pre></td></tr></table></figure><p>总结：<strong>接口就是抽象方法的集合</strong></p><h3 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h3><p>两个类实现同一个接口，代理类中有被代理类的对象，代理类代表被代理类的功能，屏蔽真实的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealImage realImage = <span class="keyword">new</span> RealImage();</span><br><span class="line">        ProxyImage proxyImage = <span class="keyword">new</span> ProxyImage(realImage);</span><br><span class="line">        proxyImage.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show 真实的图片"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Image image;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(Image i)</span></span>&#123;  <span class="comment">// 多态</span></span><br><span class="line">        <span class="keyword">this</span>.image = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"检查图片"</span>);</span><br><span class="line">        <span class="keyword">this</span>.image.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>实现了创建者与调用者的分离（开闭原则：对拓展开放，对修改封闭）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AudiFactory audiFactory = <span class="keyword">new</span> AudiFactory();</span><br><span class="line">        BMWFactory bmwFactory = <span class="keyword">new</span> BMWFactory();</span><br><span class="line">        Car a = audiFactory.getCar();</span><br><span class="line">        Car b = bmwFactory.getCar();</span><br><span class="line">        a.run();</span><br><span class="line">        b.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"奥迪在跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"宝马在跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMW();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK8-0-的接口新特性"><a href="#JDK8-0-的接口新特性" class="headerlink" title="JDK8.0+的接口新特性"></a>JDK8.0+的接口新特性</h3><p>接口中的成员：</p><ol><li>全局常量</li><li>抽象方法</li><li><strong>静态方法</strong>(默认public，8.0+)</li><li><strong>默认方法</strong>(默认public，8.0+)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sys(<span class="string">"s"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">dprint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sys(<span class="string">"f"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态方法：只能使用接口调用</li><li>默认方法：可以重写方法体，也可以不重写使用默认的方法体。<br><strong>注：父类与接口中的方法同名同参数，那么子类在没有重写的情况下默认调用父类方法。（类优先，若是同名属性则不被允许，多个接口中的同名默认方法冲突否则必须重写。若要调接口中的方法—<code>InterfaceA.super.method</code>）</strong></li></ul><h2 id="内部类（不常见）"><a href="#内部类（不常见）" class="headerlink" title="内部类（不常见）"></a>内部类（不常见）</h2><ul><li>局部内部类：方法体内、代码块内。</li><li>成员内部类：类的下一层，与成员变量平级</li></ul><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul><li>可以调用外部类的结构</li><li>可以被static修饰</li><li>可以有4种修饰方式</li></ul><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><ul><li>接口实现类</li><li>匿名实现类。</li><li>局部内部类调用外部的局部变量，要求其是final的。</li></ul><h3 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h3><ol><li><strong>abstract：可以修饰类和方法，类是抽象的不能被实例化，方法是抽象的没有方法体需要具体类实现</strong></li><li><strong>接口相互之间可以继承，抽象类可以实现接口，抽象类可以继承非抽象类</strong><br>3.<strong>抽象与接口体现了多态</strong></li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>编译时异常</li><li>运行时异常</li></ul><h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">    |----java.lang.Error</span><br><span class="line">    |----java.lang.Exception</span><br><span class="line">         |----编译时异常：</span><br><span class="line">              - IOException</span><br><span class="line">              - ClassNotFountException</span><br><span class="line">         |----运行时异常</span><br><span class="line">              - NullPointerException</span><br><span class="line">              - ArrayIndexOutOfBoundsException</span><br><span class="line">              - ClassCastException</span><br><span class="line">              - NumberFormatException</span><br></pre></td></tr></table></figure><h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><ol><li><p><code>try-catch-catch-...-finally</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能会出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 发生异常1时，处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 发生异常2时，处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 无论对错，始终一定都会执行的代码，即使catch里有return语句，通常用于关闭资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异常子类的catch必须在异常父类的上面，否则报错。</strong></p></li><li>异常类型方法：<ul><li>getMessage(): 返回一个String</li><li>printStackTrace(): void方法，输出栈追踪</li></ul></li><li><code>method() throws 异常类型</code>: 不处理异常，将异常抛给调用者，表示该方法可能抛出一个异常</li><li><code>throw new [异常类型1,2...]</code>：抛出异常</li><li>子类重写父类方法抛出的异常只能是父类异常的子异常。</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol><li>继承已有的异常类</li><li>提供全局常量标识类</li><li>提供多个构造器</li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li>程序：实体</li><li>进程：运行中的程序，<strong>是资源分配的基本单位</strong></li><li>线程：进程的细分，可理解为执行路径，<strong>是调度的基本单位</strong></li><li>并行：多个CPU同时执行多个任务，CPU的并行</li><li>并发：一个CPU同时执行多个任务，任务的并发</li><li>一个Java程序至少有3个线程：main，垃圾收集，异常处理</li></ul><h3 id="通过Thread类创建"><a href="#通过Thread类创建" class="headerlink" title="通过Thread类创建"></a>通过Thread类创建</h3><ol><li>继承java.lang.Thread类</li><li>重写run方法，是线程执行的代码</li><li>创建Thread类的子类对象</li><li>通过对象调用start方法</li><li><strong>start方法只能被同一个线程调用一次（IllegalThreadStateException）</strong></li><li>使用匿名子类使用不同的run方法</li></ol><h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><ol><li>start方法：启动线程</li><li>run方法：线程的执行内容</li><li>currentThread方法：获取执行当前代码的线程</li><li>setName、getName方法：命名的修改与获取</li><li>yield方法：释放对CPU的占用，回到就绪状态</li><li>join方法：阻塞<strong>执行当前代码</strong>的线程，等待调用方法的线程执行完毕后，<strong>结束阻塞状态</strong></li><li><em>stop方法</em>：以及弃用，结束线程的生命周期</li><li>sleep方法（静态）：当前线程“睡眠”毫秒数（1秒=1000毫秒），使线程阻塞</li><li>isAlive方法：线程是否存活</li></ol><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><ul><li>时间片</li><li>优先级</li></ul><p>优先级：从概率上来讲优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="通过Runnable接口创建"><a href="#通过Runnable接口创建" class="headerlink" title="通过Runnable接口创建"></a>通过Runnable接口创建</h3><ol><li>创建实现Runnable接口的类</li><li>实现抽象方法：run</li><li>创建该类的对象</li><li>将此对象传入Thread的构造器中，创建Thread的对象</li><li>通过Thread的对象调用start方法</li></ol><p>继承Thread类影响了拓展性，而实现Runnable接口则不会影响拓展性</p><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowsTest继承了Thread类，创建3个对象来建立3个线程</span></span><br><span class="line">WindowsTest w1 = <span class="keyword">new</span> WindowsTest();</span><br><span class="line">WindowsTest w2 = <span class="keyword">new</span> WindowsTest();</span><br><span class="line">WindowsTest w3 = <span class="keyword">new</span> WindowsTest();</span><br><span class="line">w1.start();</span><br><span class="line">w2.start();</span><br><span class="line">w3.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowsRunnable实现了Runnable接口，创建1个对象来建立3个线程</span></span><br><span class="line">WindowsRunnable wr = <span class="keyword">new</span> WindowsRunnable();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(wr);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(wr);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(wr);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br></pre></td></tr></table></figure><ul><li>Thread也重写了Runnable接口</li><li>第二种方式相当于覆盖了Thread的run方法</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul><li>新建</li><li>就绪</li><li>运行</li><li>阻塞</li><li>死亡</li></ul><p>线程状态转换图：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cpu%E7%8A%B6%E6%80%81.png" alt="线程的生命周期"></p><h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><p>问题：</p><ol><li>当线程之间存在共享数据时，就会存在安全问题</li><li>共享数据成为<strong>临界资源</strong>，访问临界资源的代码称为<strong>临界区</strong></li></ol><p>如何解决：</p><ol><li>对线程的访问的资源进行<strong>加锁</strong>，加锁后其他进程不能访问</li></ol><p>java的解决方式：</p><ul><li><p><code>synchronized</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法：Runnable实现类-this为同步监视器</span></span><br><span class="line">权限修饰符 <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步方法：Thread子类-ClassName.class为调用者，且只有一个</span></span><br><span class="line">权限修饰符 <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步监视器：锁-<strong>任何一个对象都可以作为锁</strong>；要求-<strong>多个线程必须共用一把锁</strong></p></li><li>this作为锁：适用于实现Runnable接口的类的对象，因为只创建了一个对象</li><li>ClassName.class作为锁：该对象只会加载一次</li><li>在Runnable实现类中考虑使用this为锁，在Thread的子类中考虑使用ClassName.class作为锁</li></ul><p>同步的缺点：</p><ol><li>使用了线程同步相当于，线程的串行执行，速度慢</li></ol><h3 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h3><ul><li><p>懒汉式：线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>懒汉式：双重校验锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingle</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    s = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>  不同的线程分别占用对方的资源不放弃，都在等待对方去释放自己需要的同步资源，就形成了死锁。可见申请资源的方向称为一个<strong>环状结构</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="keyword">new</span> Thread(&#123;</span><br><span class="line">    LockA&#123;</span><br><span class="line">        <span class="comment">// 抢占A锁，等待B锁</span></span><br><span class="line">        LockB&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start()</span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">new</span> Thread(&#123;</span><br><span class="line">    LockB&#123;</span><br><span class="line">        <span class="comment">// 抢占B锁，等待A锁</span></span><br><span class="line">        LockA&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><ul><li>Lock对象：JDK5.0+，作为同步锁</li><li><code>java.util.concurrent.locks.Lock</code>接口</li><li>ReentrantLock类实现了Lock接口</li></ul><p>synchronized与lock的不同：</p><ol><li>synchronized相当于自动锁，自动加锁，自动释放锁；lock手动启动锁，手动释放锁</li><li>优先使用顺序：lock锁-&gt;同步代码块-&gt;同步方法</li></ol><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul><li>wait方法：阻塞当前线程，<strong>并释放锁</strong></li><li>notify方法：唤醒用wait阻塞的线程</li><li>notifyAll方法：唤醒所有wait阻塞的线程</li><li><strong>方法的调用者必须是同步代码块或同步方法的同步监视器</strong>，否则出现异常<code>IllegalMonitorStateException</code></li><li><strong>3个方法都来自Object</strong>，因为同步监视器可以是任何对象，他们的共同父类是Object</li></ul><p>生产者消费者问题：使用wait与notify让生产者与消费者之间产生交互</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ind.MultiProcess;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者与消费者的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerAndProducerProblem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StoreManagement store = <span class="keyword">new</span> StoreManagement();</span><br><span class="line">        store.openStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stocks_num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> stocks_now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Store store;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Store store)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.store = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            produceItem(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produceItem</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (store) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (store.stocks_now &lt; store.stocks_num) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        store.stocks_now++;</span><br><span class="line">                        store.notify();   <span class="comment">// 唤醒消费者</span></span><br><span class="line">                        System.out.println(name + <span class="string">": 当前货量-"</span> + store.stocks_now);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        store.wait();    <span class="comment">//  货满，生产者等待</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Store store;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Store store)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.store = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            consumeItem(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumeItem</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (store) &#123;</span><br><span class="line">                <span class="keyword">if</span> (store.stocks_now &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    store.stocks_now--;</span><br><span class="line">                    store.notify();   <span class="comment">// 唤醒生产者</span></span><br><span class="line">                    System.out.println(name + <span class="string">" 消费后剩余"</span> + store.stocks_now);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    store.wait();   <span class="comment">// 货架为空，消费者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoreManagement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Store store = <span class="keyword">new</span> Store();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer(store);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> Consumer(store);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initProducers();      <span class="comment">// 开启生产者</span></span><br><span class="line">        initConsumers();      <span class="comment">// 开启消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initProducers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread[] producers = <span class="keyword">new</span> Thread[<span class="number">5</span>];   <span class="comment">// 5个生产者</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; producers.length; i++) &#123;</span><br><span class="line">            producers[i] = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">            producers[i].setName(<span class="string">"生产者"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : producers) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) (<span class="number">3</span> + Math.random() * <span class="number">5</span>);</span><br><span class="line">        System.out.println(n + <span class="string">"个消费者"</span>);</span><br><span class="line">        System.out.println(<span class="string">"5个生产者"</span>);</span><br><span class="line">        <span class="keyword">final</span> Thread[] consumers = <span class="keyword">new</span> Thread[n];   <span class="comment">// 3-8个消费者</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumers.length; i++) &#123;</span><br><span class="line">            consumers[i] = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line">            consumers[i].setName(<span class="string">"消费者"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : consumers) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK5-0-新增方式"><a href="#JDK5-0-新增方式" class="headerlink" title="JDK5.0+新增方式"></a>JDK5.0+新增方式</h3><ul><li>实现Callable接口</li><li>使用线程池</li></ul><p>Callable接口：</p><ul><li>创建Callable接口的实现类</li><li>借助FutureTask类创建对象，FutureTask类实现了Runnable接口</li><li>用FutureTask类的get方法获取线程执行call的返回值</li><li>同样将FutureTask类的对象来构造Thread，来启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CallThread t = <span class="keyword">new</span> CallThread();     <span class="comment">// Callable接口的实现类</span></span><br><span class="line">        FutureTask ft = <span class="keyword">new</span> FutureTask(t);   <span class="comment">// 继承过Runnable接口</span></span><br><span class="line">        <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object o = ft.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += <span class="number">2</span>;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>有返回值</li><li>可以抛出异常</li><li>支持泛型</li></ul><p>使用线程池：</p><ul><li>提高响应速度</li><li>降低资源消耗</li><li>便于线程管理</li></ul><ol><li><p>ExecutorService：线程池接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = <span class="keyword">new</span> ExecutorService(<span class="number">10</span>);  <span class="comment">// 创建10个线程的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span>: 执行任务，Runnable接口的实现类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span>: 关闭连接池</span></span><br><span class="line"><span class="function"></span>=========================</span><br><span class="line">corePoolSize: 核心池的大小</span><br><span class="line">maximumPoolSize：最大线程数</span><br><span class="line">keepAliveTime：线程没有任务时，最多保持多少时间后会终止</span><br></pre></td></tr></table></figure></li><li><p>Executors：线程池的工厂类、工具类。静态方法</p></li></ol><h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ul><li>final类</li><li>实现了<code>java.io.Serializable, Comparable&lt;String&gt;, CharSequence</code>三个接口<ol><li><code>Serializable</code>接口：表示支持序列化</li><li><code>Compareable&lt;String&gt;</code>接口：比较大小</li></ol></li><li><code>final char[]</code>：用于存储字符串数据</li><li><p><strong>不可变的字符序列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"123"</span>;  <span class="comment">// 字面量，字符串值存储在字符串常量池中，其中不会存储相同的常量字符串</span></span><br><span class="line">String s2 = <span class="string">"123"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> Stirng(<span class="string">"123"</span>)  <span class="comment">// 存储在堆中</span></span><br><span class="line"></span><br><span class="line">sysout(s1 == s2)   <span class="comment">// true</span></span><br><span class="line">sysout(s1 == s3)   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">12</span>)</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">113</span>)</span><br><span class="line">sysout(p1.name == p2.name)   <span class="comment">// true 因为"Jack"为字面量，存储在常量池中</span></span><br><span class="line"></span><br><span class="line">String s1 = <span class="string">"javaEE"</span>;</span><br><span class="line">String s2 = <span class="string">"hadoop"</span>;</span><br><span class="line"></span><br><span class="line">String s3 = <span class="string">"javaEEhadoop"</span>;</span><br><span class="line">String s4 = <span class="string">"javaEE"</span> + <span class="string">"hadoop"</span>;</span><br><span class="line">String s5 = s1 + <span class="string">"hadoop"</span>;</span><br><span class="line">String s6 = <span class="string">"javaEE"</span> + s2;</span><br><span class="line">System.out.println(s3 == s4);  <span class="comment">// true，常量与常量的拼接都在常量池中</span></span><br><span class="line">System.out.println(s3 == s5);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s6);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 只要其中一个是变量，结果就在堆当中</span></span><br><span class="line"></span><br><span class="line">String s7 = s5.intern()  <span class="comment">// 返回在常量池中的字符串</span></span><br><span class="line">sysout(s3 == s7)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>拼接操作会产生新的字符串常量</li><li>replace操作也会产生新的字符串常量</li></ol></li></ul><p>JVM内存结构：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="JVM内存结构"></p><h3 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h3><ul><li>int length()：返回字符串长度</li><li>char charAt(int index)：返回某索引处的字符</li><li>boolean isEmpty()：判断字符串是否为空</li><li>String toLowerCase()</li><li>String toUpperCase()</li><li>String trim()：返回字符串的副本，忽略前后空格</li><li>boolean equals(Object obj)：比较字符串的内容是否相同</li><li>String concat(String str)：等价于“+”</li><li>int CompareTo(String anotherString)：比较字符串中每个字符的Ascii大小</li></ul><hr><ul><li>String substring(int beginIndex)</li><li>boolean startWith(String suffix)</li><li>boolean endWith(String prifix)</li><li>boolean contains(CharSequence s)</li><li>int indexOf(String str)</li><li>int lastIndexOf(String str)</li></ul><hr><ul><li>String replace(String oldStr, String newStr)</li><li>String replaceAll(String regex, String replacement)</li><li>String replaceFirst(String regex, String replacement)</li><li>boolean matches(String regex)</li><li>String split(String regex)</li><li>String转其他类型：parseXxx(String str)</li><li>其他类型转String：String.valueOf(Xxx)</li><li>String转为char数组：str.toCharArray()</li><li>char数组转为String：调用String的构造器</li><li>String转为byte数组：str.getBytes(String charset)，使用默认字符集</li><li>byte数组转为String：调用String的构造器，使用编辑器默认字符集，<strong>或者利用参数指定字符集</strong></li></ul><h3 id="StringBuffer（效率低）与StringBuilder（效率最高）"><a href="#StringBuffer（效率低）与StringBuilder（效率最高）" class="headerlink" title="StringBuffer（效率低）与StringBuilder（效率最高）"></a>StringBuffer（效率低）与StringBuilder（效率最高）</h3><ul><li>String：<strong>不可变的字符序列</strong>；使用char数组存储数据</li><li><p>StringBuffer：<strong>可变的字符序列</strong>，<strong>线程安全的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();  <span class="comment">// 底层创建一个长度为16的char数组</span></span><br><span class="line">sb.append(<span class="string">"hello"</span>)   <span class="comment">// 数组的扩容</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  底层是将 原字符串的长度*2+2 作为新字符串的长度，同时赋给新的数组copyof</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          value = Arrays.copyOf(value,</span><br><span class="line">                  newCapacity(minimumCapacity));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          ? hugeCapacity(minCapacity)</span><br><span class="line">          : newCapacity;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>StringBuilder：<strong>可变的字符序列</strong>，线程不安全的。jdk5.0+；底层原理同StringBuffer，两者继承自同一父类。</p></li></ul><p>常用方法：</p><ol><li>append</li><li>replace</li><li>insert</li><li>reverse</li><li>setCharAt</li><li>delete</li></ol><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><ul><li>System类中的<code>currentTimeMillis()</code>:返回当前的时间戳毫秒数，返回long型</li></ul><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><ul><li>java.util.Date</li><li>java.sql.Date:继承自前者</li></ul><p>转换：<strong>利用时间戳来相互转换</strong></p><h3 id="SimpleDateFormat格式化日期"><a href="#SimpleDateFormat格式化日期" class="headerlink" title="SimpleDateFormat格式化日期"></a>SimpleDateFormat格式化日期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">String s = sdf.format(date)   <span class="comment">// 日期----&gt;字符串  format</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line">String s1 = <span class="string">"2000-12-1 23:22"</span>;</span><br><span class="line">Date date1 = sdf1.parse(s1);   <span class="comment">// 字符串-----&gt;日期 parse</span></span><br></pre></td></tr></table></figure><h3 id="Calender抽象类的使用-JDK8-0"><a href="#Calender抽象类的使用-JDK8-0" class="headerlink" title="Calender抽象类的使用 JDK8.0-"></a>Calender抽象类的使用 JDK8.0-</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.getClass());   <span class="comment">// class java.util.GregorianCalendar</span></span><br><span class="line">System.out.println(calendar.get(Calendar.HOUR));  <span class="comment">// get</span></span><br><span class="line">calendar.set(Calendar.MONTH, <span class="number">9</span>);   <span class="comment">// set</span></span><br><span class="line">calendar.add(Calendar.MONTH, -<span class="number">2</span>);  <span class="comment">// add</span></span><br></pre></td></tr></table></figure><h3 id="JDK8-0-时间API"><a href="#JDK8-0-时间API" class="headerlink" title="JDK8.0+ 时间API"></a>JDK8.0+ 时间API</h3><p>常用类(没有偏移量了；<strong>不可变性</strong>)：</p><ul><li>LocalDate</li><li>LocalTime</li><li>LocalDateTime</li><li>Instant</li><li>DateTimeFomatter</li></ul><p>方法：</p><ul><li>withxxx()：返回带有指定值的新的日期对象</li><li>plusxxx()</li><li>minusxxx()</li></ul><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>两个接口</p><ul><li>Compareable（内比较器）：实现类需重写<code>compareTo</code>方法</li><li>Comparator（外比较器）：<strong>定制排序</strong>，重写<code>compare</code>方法</li></ul><h2 id="System、Math、BigInteger、BigDecimal"><a href="#System、Math、BigInteger、BigDecimal" class="headerlink" title="System、Math、BigInteger、BigDecimal"></a>System、Math、BigInteger、BigDecimal</h2><ul><li>System：有关系统的</li><li>Math：有关数学运算的</li><li>BigInteger：表示不可变的任意精度的整数</li><li>BigDecimal：表示不可变的、任意精度的有符号十进制<strong>定点数</strong>。精度较高。</li></ul><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>有限个、确定的值的类。（JDK5-自定义，JDK5+引入enum关键字）</p><h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><ol><li>私有化每个枚举值</li><li>私有化构造器</li><li>创建全局枚举对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String season;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.season = name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">"春天"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">"夏天"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">"秋天"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">"冬天"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeason</span><span class="params">()</span> </span>&#123;   <span class="comment">// 获取枚举变量的值</span></span><br><span class="line">        <span class="keyword">return</span> season;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Season&#123;"</span> +</span><br><span class="line">                <span class="string">"season='"</span> + season + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用enum关键字"><a href="#使用enum关键字" class="headerlink" title="使用enum关键字"></a>使用enum关键字</h3><ul><li>继承自java.lang.Enum</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> SeasonStatus&#123;</span><br><span class="line">    <span class="comment">// objName</span></span><br><span class="line">    SPRING(<span class="string">"春天"</span>),   <span class="comment">// 逗号隔开</span></span><br><span class="line">    SUMMER(<span class="string">"夏天"</span>),</span><br><span class="line">    AUTUMN(<span class="string">"秋天"</span>),</span><br><span class="line">    WINTER(<span class="string">"冬天"</span>);   <span class="comment">// 分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    SeasonStatus(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类的方法：</p><ul><li>values()</li><li>valueOf(String objName)</li></ul><p>枚举类实现接口：</p><ul><li>同类一样实现接口方法</li><li><strong>每个对象可以不同地实现接口方法</strong></li></ul><h2 id="注解（Annotation）JDK5-0"><a href="#注解（Annotation）JDK5-0" class="headerlink" title="注解（Annotation）JDK5.0+"></a>注解（Annotation）JDK5.0+</h2><ul><li>@override：限定重写父类的方法</li><li>@Deprecated：过时的</li><li>@SuppressWarnings：抑制编译器警告</li></ul><p>自定义注解：参照@SuppressWarnings；有成员value，或无成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The set of warnings that are to be suppressed by the compiler in the</span></span><br><span class="line"><span class="comment">     * annotated element.  Duplicate names are permitted.  The second and</span></span><br><span class="line"><span class="comment">     * successive occurrences of a name are ignored.  The presence of</span></span><br><span class="line"><span class="comment">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span></span><br><span class="line"><span class="comment">     * ignore any warning names they do not recognize.  They are, however,</span></span><br><span class="line"><span class="comment">     * free to emit a warning if an annotation contains an unrecognized</span></span><br><span class="line"><span class="comment">     * warning name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The string &#123;<span class="doctag">@code</span> "unchecked"&#125; is used to suppress</span></span><br><span class="line"><span class="comment">     * unchecked warnings. Compiler vendors should document the</span></span><br><span class="line"><span class="comment">     * additional warning names they support in conjunction with this</span></span><br><span class="line"><span class="comment">     * annotation type. They are encouraged to cooperate to ensure</span></span><br><span class="line"><span class="comment">     * that the same names work across multiple compilers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the set of warnings to be suppressed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>对<strong>现有的注解进行解释说明</strong>的注解：</p><ul><li>Retention（保留）：用于指定注解的生命周期-SOURCE\CLASS(default)\RUNTIME</li><li>Target：指定注解能用于修饰那些元素-TYPE/FIELD/METHOD/CONSTRUCTOR… …</li><li>Documented：令注解在被javadoc解析后被保留下来</li><li>Inherited：令注解具有继承性</li></ul><h3 id="JDK8-0-新特性"><a href="#JDK8-0-新特性" class="headerlink" title="JDK8.0+新特性"></a>JDK8.0+新特性</h3><ul><li>可重复注解</li><li>类型注解：TYPE_USER/TYPE_PARAMETER</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li>Collection接口：单列数据，单一对象<ol><li>List：有序、可重复</li><li>Set：无序、不可重复</li></ol></li><li>Map接口：双列数据，存储key-value<ol><li>HashMap</li><li>LinkedHashMap</li><li>TreeMap</li><li>HashTable</li><li>Properties</li></ol></li><li>Collections工具类</li></ul><p>Collection接口常用方法：</p><ul><li>add(Object e)：添加一个元素</li><li>addAll(Collection coll)：添加一个集合中的所有元素</li><li>size()：集合的大小</li><li>isEmpty()：集合是否为空</li><li>clear()：清空集合</li><li>contains(Object e)：是否存在元素，<strong>使用equals来比较元素</strong></li><li>containsAll(Collection coll)：判断集合的元素是否都存在</li><li>remove(Object e)</li><li>removeAll(Collection coll)</li><li>retainAll(Collection coll1)：求两个集合的交集，并替换this集合</li><li>Object.equals()</li><li>Object.hashCode()</li><li>toArray()：集合—&gt;Object数组</li><li>Arrays.asList()：数组—&gt;集合</li><li>iterator()：放回Iterator接口的实例</li></ul><p>注：<strong>添加的obj要重写equals方法</strong></p><h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>迭代器，用于遍历集合中的元素，<strong>只能用一次。不可逆。</strong></p><ul><li>E next()：指针下移</li><li>boolean hasNext()：指针不变</li><li>void remove()：删除集合中的元素（）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用遍历</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List接口（Collection子接口）"><a href="#List接口（Collection子接口）" class="headerlink" title="List接口（Collection子接口）"></a>List接口（Collection子接口）</h3><p>元素有序、可重复、动态变化大小。List实现类：</p><ul><li>ArrayList：线程不安全，效率高；底层用Object[]<strong>数组</strong></li><li>LinkedList：插入、删除效率高；底层使用<strong>双向链表</strong>实现</li><li>Vector：线程安全，效率低；底层用Object[]<strong>数组</strong></li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>JDK7.0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arr = <span class="keyword">new</span> ArrayList();  <span class="comment">// 容量默认为10的Object数组</span></span><br><span class="line"><span class="comment">// add操作会让判断数组大小，扩容机制：变为原来的1.5倍，并赋值给新的数组</span></span><br><span class="line"><span class="comment">// 建议使用带参数的构造器，就避免去频繁的动态扩容</span></span><br></pre></td></tr></table></figure><p>JDK8.0+:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  <span class="comment">// &#123;&#125;空的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用add操作后才开始创建数组，其它与JDK7无异</span></span><br><span class="line"><span class="comment">// 延迟了数组的创建时间</span></span><br></pre></td></tr></table></figure><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类，前后指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;  <span class="comment">// 最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;  <span class="comment">// 新节点作为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>基本不用了</p><h3 id="List接口常用方法"><a href="#List接口常用方法" class="headerlink" title="List接口常用方法"></a>List接口常用方法</h3><ul><li>void add(int index, Object ele)</li><li>boolean addAll(int index, Collection eles)</li><li>Object get(int index)</li><li>int indexOf(Object obj)：如果不存在返回-1</li><li>int lastIndexOf(Object obj)</li><li>Object remove(int index) / boolean remove(Object o)：按照索引删除，并返回此元素</li><li>Object set(int index, Object ele)，按照索引修改，并返回此元素</li><li>List subList(int fromIndex, int toList)</li></ul><h3 id="Set接口（Collection子接口）"><a href="#Set接口（Collection子接口）" class="headerlink" title="Set接口（Collection子接口）"></a>Set接口（Collection子接口）</h3><ul><li><strong>存储无序的</strong>：不等于随机性，体现在哈希值上，根据哈希值存储。</li><li><strong>不可重复的</strong>：利用hashCode方法与equals方法判断是否重复。底层：<strong>数组+链表，哈希值与equals方法，在数组中的位置与哈希值有关</strong>（JDK7与8不一样，对链表的操作分为<strong>头插法</strong>8+与尾插法7-）</li></ul><p>实现类：</p><ul><li><code>HashSet</code>：主要实现类，线程不安全，可以存储null值，底层是一个数组，长度为16<ul><li><code>LinkedHashSet</code>：HashSet的子类，可以按照顺序变量。<strong>原理依然是数组+链表，不过链表的节点的双向量表，记录的是添加的顺序</strong>。遍历的效率高</li></ul></li><li><code>TreeSet</code>：空参构造底层是一个TreeMap，可以对属性排序。<strong>只能添加同类型的数据</strong>，并自然排序（实现Comparable接口的类）。<strong>根据compareTo来判断对象是否相同（返回0）。</strong><ul><li>定制排序：<code>TreeSet treeset = new TreeSet(Comparator com)</code>，使用比较器</li></ul></li></ul><p>所以<strong>一般需要重写hashCode方法与equals方法：相等的对象要有相等的哈希值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试题：理解hashSet利用哈希值存储、不可重复性的特点</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">hashSet.add(p1);</span><br><span class="line">hashSet.add(p2);</span><br><span class="line"></span><br><span class="line">System.out.println(hashSet);  <span class="comment">// [Person&#123;name='Tom', age=22&#125;, Person&#123;name='Jack', age=12&#125;]</span></span><br><span class="line"></span><br><span class="line">p1.age = <span class="number">11</span>;</span><br><span class="line">System.out.println(hashSet.remove(p1));  <span class="comment">// false</span></span><br><span class="line">System.out.println(hashSet);  <span class="comment">// [Person&#123;name='Tom', age=22&#125;, Person&#123;name='Jack', age=11&#125;]</span></span><br><span class="line">hashSet.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">11</span>));</span><br><span class="line">System.out.println(hashSet);  <span class="comment">// [Person&#123;name='Tom', age=22&#125;, Person&#123;name='Jack', age=11&#125;, Person&#123;name='Jack', age=11&#125;]</span></span><br><span class="line">hashSet.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">12</span>));</span><br><span class="line">System.out.println(hashSet);  <span class="comment">// [Person&#123;name='Tom', age=22&#125;, Person&#123;name='Jack', age=11&#125;, Person&#123;name='Jack', age=11&#125;, Person&#123;name='Jack', age=12&#125;]</span></span><br></pre></td></tr></table></figure><h3 id="Map接口（Collection子接口）"><a href="#Map接口（Collection子接口）" class="headerlink" title="Map接口（Collection子接口）"></a>Map接口（Collection子接口）</h3><p>双列数据，key-value型数据。实现类</p><ul><li>HashMap：常用实现类。线程不安全的。有null的key与value<ul><li>LinkedHashMap：继承自HashMap，可以按照添加的顺序遍历</li></ul></li><li>TreeMap：可以按照添加的顺序排序（<strong>按照key排序，要求是同一个类</strong>）遍历，底层使用红黑树</li><li>Hashtable：古老类。线程安全。不能有null的key与value<ul><li>Properties：用来处理配置文件，key与value都是String型的</li></ul></li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>底层概述：</p><ul><li>JDK7-：数组+链表</li><li>JDK8+：数组+链表+红黑树</li><li>Key：无序，不重复。使用set存储Key，需要重写equals方法与hashCode方法</li><li>Value：无序，可重复。</li><li>Key-Value：一个Entry</li></ul><p>JDK7：Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();  <span class="comment">// 默认16长度的Entry数组，数组+链表</span></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">hashMap.put(key, value)  <span class="comment">// 使用key的hashCode计算哈希值，按此哈希值计算存储位置。与Set类似，key的去重过程为先比较哈希值，再使用equals方法比较。</span></span><br><span class="line"><span class="comment">// 如果存在相同的key，则用新的value替换。从始至终都是比较的key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容：当超出临界值，且存放位置不为空</span></span><br><span class="line"><span class="comment">// 扩容为原来的2倍，并将原来的数据复制过来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------源码-------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span></span>&#123; <span class="comment">// 16, 0.75</span></span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); <span class="comment">// 默认初始化容量16，默认加载因子0.75</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> loadFactor)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> capcity = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)&#123;</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>   <span class="comment">// 2倍增加</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 临界值，影响扩容时的条件  16*0.75=12</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(capacity*loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容操作</span></span><br><span class="line"><span class="comment">// 头插法, 新节点next指向当前链表的头部</span></span><br><span class="line"></span><br><span class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K, V&gt; n)&#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK8：Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();  <span class="comment">// 底层没有创建数组，Node，数组+链表+红黑树</span></span><br><span class="line"><span class="comment">// 添加，首次调用时，再创建</span></span><br><span class="line">hashMap.put(key, value)  <span class="comment">// 使用key的hashCode计算哈希值，按此哈希值计算存储位置。与Set类似，key的去重过程为先比较哈希值，再使用equals方法比较。</span></span><br><span class="line"><span class="comment">// 如果存在相同的key，则用新的value替换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容：容量*2，且加载因子*2</span></span><br><span class="line"><span class="comment">// 当某个索引位置处链表长度 &gt; 8 且当前数组长度 &gt; 64时，将此索引位置上的结构转变为红黑树。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------源码-------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123; <span class="comment">// 加载因子0.75，用于扩容临界值</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// put操作</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)  <span class="comment">// 第一个元素</span></span><br><span class="line">        n = (tab = resize()).length;  <span class="comment">// 初始化16</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  <span class="comment">// 找到需要插入的位置上是否为空</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;  <span class="comment">// 创建一个临时变量</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;  <span class="comment">// 比较两者的哈希值是否相同</span></span><br><span class="line">            <span class="comment">// 再比较key的地址是否相同，再equals比较内容是否相同</span></span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;  <span class="comment">// 哈希值相同且key相同的情况，p是旧的元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;  <span class="comment">// p旧元素的下一个元素</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);  <span class="comment">// 尾插法</span></span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD = 8，当超过这个长度时将变成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下一个元素与本元素比较</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;  <span class="comment">// 继续考虑下一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>内部单元为Entry，继承自HashMap中的Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map中的常用方法"><a href="#Map中的常用方法" class="headerlink" title="Map中的常用方法"></a>Map中的常用方法</h3><ul><li>Object put(Object key, object value)</li><li>void putAll(Map m)</li><li>Object remove(Object key)</li><li>void clear()</li></ul><hr><ul><li>Object get(Object key)</li><li>boolean containsKey(Object key)</li><li>boolean containsValue(Object value)</li><li>int size()</li><li>boolean isEmpty()</li><li>boolean equals(Object obj)</li></ul><hr><p>  通过迭代器遍历键与值</p><ul><li>Set keySet()</li><li>Collection values()</li><li>Set entrySet()</li></ul><h3 id="Properties（继承自Hashtable）"><a href="#Properties（继承自Hashtable）" class="headerlink" title="Properties（继承自Hashtable）"></a>Properties（继承自Hashtable）</h3><p>key和value都是String，通常用于配置文件<code>xxx.properties</code>。使用文件流操作。</p><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>常用方法：</p><ul><li>reverse(List)</li><li>shuffle(List)</li><li>sort(List)</li><li>sort(List, Comparator)</li><li>swap(List, int, int)</li><li>Object max(Collection)</li><li>Object max(Collection, Comparator)</li><li>int frequency(Collection, Object)</li><li>void copy(List destination, List src):<code>Arrays.toList(new Object[src.size()])</code></li><li>boolean replaceAll(List, oldVal, newVal)</li><li>synchronizedXxx()</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>类型泛化，默认为Objec类型</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> Map&lt;&gt;();</span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = <span class="keyword">new</span> Set&lt;&gt;()</span><br></pre></td></tr></table></figure><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class MyObject&lt;T&gt;&#123;</span><br><span class="line">    T myObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>多个泛型参数用逗号隔开</li><li>构造器不需要带泛型声明</li><li>不同泛型引用不能相互赋值</li><li>静态方法中不能使用类的泛型</li><li>不能使用new T()</li><li><strong>静态方法可以是泛型方法</strong></li></ol><p><strong>泛型方法</strong>：具有泛型的结构，与类的泛型没有任何关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;E&gt; 说明了他是泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通配符<code>?</code></strong>的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">List&lt;?&gt; = <span class="keyword">new</span> List&lt;&gt;();  <span class="comment">// 公用父类，拒接写入（add），允许读（get）</span></span><br></pre></td></tr></table></figure><p>有限制的通配符：</p><ul><li>&lt;? extends SuperClass&gt;: SuperClass的子类或本身才可以, 往下找，add(Object)</li><li>&lt;? super SuperClass&gt;：SuperClass的父类或本身才可以，往上找，add(Person往下)</li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>不涉及到文件内容，仅存储文件的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);  <span class="comment">// 相对于当前的项目路径下</span></span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">"D:\\windows\\program\\hello.txt"</span>);</span><br><span class="line">File file3 = <span class="keyword">new</span> File(<span class="string">"D:\\windows"</span>, <span class="string">"program"</span>);</span><br></pre></td></tr></table></figure><p>常用方法：</p><ul><li>public String getAbsolutePath()</li><li>public String getPath()</li><li>public String getName()</li><li>public String getParent()</li><li>public long length()</li><li>public long lastModified()</li><li>boolean renameTo(File2 file2)</li><li>String[] list()：返回路径下的文件名</li><li>File[] listFile()：返回文件对象</li></ul><hr><ul><li>boolean isDirectory()</li><li>boolean isFile()</li><li>boolean exists()</li><li>boolean canRead()</li><li>boolean canWrite()</li><li>boolean isHidden()</li></ul><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><ul><li>字节流：<code>OutputStream</code>, <code>InputStream</code></li><li>字符流：<code>Writer</code>, <code>Reader</code></li><li>转换流：<code>InputStreamReader</code>, <code>OutputStreamWriter</code></li></ul><p>字符流读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化File类对象</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"src/ind/IOTest/hello_three.txt"</span>);</span><br><span class="line">        <span class="comment">// 提供具体的流</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = fr.read();  <span class="comment">// 读入一个字符</span></span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>)&#123;  <span class="comment">// 返回-1说明到达文件末尾</span></span><br><span class="line">            System.out.println(data+<span class="string">" "</span>+(<span class="keyword">char</span>)data);</span><br><span class="line">            data = fr.read();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fr!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();  <span class="comment">// 关闭流</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节流使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"src/ind/IOTest/头像.jpg"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"src/ind/IOTest/头像copy.jpg"</span>);</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(f2);</span><br><span class="line">        <span class="keyword">byte</span>[] bcBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bcBuffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bcBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换流：</p><ol><li>将字节流转为字符流。—-解码过程</li><li>再将字符流转为字节流。—-编码过程</li></ol><p>标准输入输出流：<code>System.in</code>与<code>System.out</code><br>打印流：<code>PrintStream</code><br>数据流：<code>DataInputStream</code>  </p><h3 id="对象流（序列化与反序列化）"><a href="#对象流（序列化与反序列化）" class="headerlink" title="对象流（序列化与反序列化）"></a>对象流（序列化与反序列化）</h3><ul><li><code>ObjectInputStream</code></li><li><code>ObjectOutputStream</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"object.dat"</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> String(<span class="string">"hello!"</span>));</span><br><span class="line">    oos.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类可序列化的要求：</p><ul><li>实现<code>java.io.Serializable</code>接口</li><li>定义序列版本号属性：<code>private static final long serialVersionUID = 10L;</code>：解决序列化与反序列化过程中，版本不一致的问题</li><li>其内部所有属性也必须是可序列化的</li></ul><h3 id="随机存取文件流（RandomAccessFile类）"><a href="#随机存取文件流（RandomAccessFile类）" class="headerlink" title="随机存取文件流（RandomAccessFile类）"></a>随机存取文件流（RandomAccessFile类）</h3><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>服务器端例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        Socket s = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line">            s = ss.accept();</span><br><span class="line">            is = s.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len=is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ss != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket s = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress ia = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">            s = <span class="keyword">new</span> Socket(ia, <span class="number">8899</span>);</span><br><span class="line">            os = s.getOutputStream();</span><br><span class="line">            os.write(<span class="string">"hello! this is client."</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射-动态性"><a href="#反射-动态性" class="headerlink" title="反射(动态性)"></a>反射(动态性)</h2><p>反射的主要且重要的特点：<strong>动态性</strong>。运行前存在变数，运行后才确定结果。</p><p>反射示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">26</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        <span class="comment">// 反射的使用</span></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        Object obj = cons.newInstance(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">        Person p1 = (Person) obj;</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">        <span class="comment">// 访问非私有属性</span></span><br><span class="line">        Field nameFiled = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        nameFiled.set(p1, <span class="string">"Lily"</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        <span class="comment">// 访问非私有方法</span></span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">"list"</span>);  <span class="comment">// 调用public方法</span></span><br><span class="line">        method.invoke(p1);</span><br><span class="line">        <span class="comment">//---------------------------------</span></span><br><span class="line">        <span class="comment">// 调用私有成员</span></span><br><span class="line">        Method method1 = clazz.getDeclaredMethod(<span class="string">"show"</span>);</span><br><span class="line">        method1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">double</span> res = (<span class="keyword">double</span>) method1.invoke(p1);  <span class="comment">// 接受返回值Object转型</span></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is person."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"list: 1, 2, 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ol><li>javac命令编译java源文件，生成字节码文件（.class结尾）</li><li>使用java命令对某个字节码文件解释执行。相当于将某个类文件加载打内存中去。称为<strong>运行类，并作为Class类的一个实例。</strong></li></ol><h3 id="如何获取Class实例"><a href="#如何获取Class实例" class="headerlink" title="如何获取Class实例"></a>如何获取Class实例</h3><ul><li><code>Class&lt;Person&gt; clazz = Person.class;</code></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz = p.getClass();</span><br></pre></td></tr></table></figure></li><li><p><code>Class clazz = Class.forName(&quot;ind.Reflection.Person&quot;);</code></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ClassLoaderDemo.class.getClassLoader();</span><br><span class="line">Class clazz3 = classLoader.loadClass(<span class="string">"ind.Reflection.Person"</span>);</span><br></pre></td></tr></table></figure></li></ul><p>加载过程（类加载器ClassLoader）：</p><ul><li>加载：将class字节文件加载到内存中去，将静态数据转换为方法区的运行时数据结构</li><li>链接：为类变量分配内存，将常量替换为地址引用</li><li>初始化：执行类构造器\<clinit\>()方法的过程</clinit\></li></ul><p>加载器：</p><ul><li>系统类加载器AppClassLoader</li><li>拓展类加载器ExtClassLoader</li><li>引导类加载器（无法获取）</li></ul><p>使用类加载器加载配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"src/ind/Reflection/jdbc.properties"</span>);</span><br><span class="line">    pro.load(fis);</span><br><span class="line"></span><br><span class="line">    String name = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">    String pwd = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">    System.out.println(name+<span class="string">" "</span>+pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">    ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    InputStream is = classLoader.getResourceAsStream(<span class="string">"ind/Reflection/jdbc.properties"</span>);  <span class="comment">// 默认在src下</span></span><br><span class="line">    pro.load(is);</span><br><span class="line">    String name = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">    String pwd = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">    System.out.println(name+<span class="string">" "</span>+pwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java基础&quot;&gt;&lt;a href=&quot;#java基础&quot; class=&quot;headerlink&quot; title=&quot;java基础&quot;&gt;&lt;/a&gt;java基础&lt;/h2&gt;&lt;h3 id=&quot;常用数据类型&quot;&gt;&lt;a href=&quot;#常用数据类型&quot; class=&quot;headerlink&quot; title=&quot;常用数据类型&quot;&gt;&lt;/a&gt;常用数据类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基本类型：&lt;code&gt;byte, short, int, long, float, double, boolean, char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;引用类型：&lt;code&gt;String, 类&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="程序语言" scheme="http://www.skecis.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://www.skecis.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>模型评估与选择（参考自西瓜书）</title>
    <link href="http://www.skecis.top/2020/06/03/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
    <id>http://www.skecis.top/2020/06/03/模型评估与选择/</id>
    <published>2020-06-03T06:36:48.000Z</published>
    <updated>2020-06-07T06:47:52.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经验误差与过拟合"><a href="#经验误差与过拟合" class="headerlink" title="经验误差与过拟合"></a>经验误差与过拟合</h2><ul><li><strong>错误率</strong>：如果在$m$个样本中有$a$个样本分类错误，则错误率$E=\frac{a}{m}$</li><li><strong>精度(accuracy)</strong>：$1-\frac{a}{m}$，即“精度=1-错误率”</li><li><strong>误差：学习器的实际预测输出与样本的真实输出之间的差异</strong>。</li><li><strong>训练误差：学习器在训练集上的误差。</strong></li><li><strong>泛化误差：学习器在新样本上的误差。</strong></li><li><strong>过拟合(overfitting)</strong>与<strong>欠拟合(underfitting)</strong></li></ul><a id="more"></a><h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><h3 id="数据集的划分"><a href="#数据集的划分" class="headerlink" title="数据集的划分"></a>数据集的划分</h3><ol><li>留出法：直接将数据集$D$划分为两个互斥的集合，其中一个作为训练集$S$，另一个作为测试集$T$，即$D=S\cup T, S\cap T=\phi$。为了保证划分后数据分布的一致性。通常采用“分层抽样”(stratified sampling)的方法。</li><li>交叉验证法：将数据集$D$划分为$k$个大小相似的互斥子集，即$D=D_{1}\cup D_{2}\cup…\cup D_{k},D_{i}\cap D_{j}=\phi(i\neq j)$，每个子集$D_{i}$都尽可能保证数据分布的一致性，即来自分层抽样。<strong>然后每次用$k-1$个子集的并集作为训练集，剩下的那个子集作为测试集</strong>，这样就得到$k$组 训练/测试集，<strong>从而可以进行$k$次训练和测试，最终返回的是这$k$个测试结果的均值，称为“$k$折交叉验证”(k-fold cross validation)</strong></li><li>自助法(bootstrapping)：给定包含$m$个样本的数据集$D$，我们对它进行采样产生数据集$D’$：<strong>每次随机从$D$中挑选一个样本，将其拷贝放入$D’$，然后再将该样本放入$D$中，使得该样本在下次采样时任有可能被采到；重复这个过程$m$次后，我们就得到了含有$m$个样本的数据集$D’$</strong>。做一个简单的估计，样本每次采样不被采到的概率为$1-\frac{1}{m}$，则$m$次不被猜到的概率为$(1-\frac{1}{m})^m$，当$m$足够大时有：<script type="math/tex; mode=display">\lim_{m\to\infty}(1-\frac{1}{m})^m\mapsto\frac{1}{e}\approx0.368</script>即通过自助采样，初始数据集$D$中大约有$36.8\%$的样本没有出现在$D’$中。适用于数据集较小，难以划分的数据集。</li></ol><h3 id="调参与最终模型"><a href="#调参与最终模型" class="headerlink" title="调参与最终模型"></a>调参与最终模型</h3><h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>回归任务中常用的<strong>均方误差</strong>：</p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^m(f(\mathbf{x}_{i})-y_{i})^2</script><p>更一般的，对于数据分布$\mathfrak{D}$和概率密度函数$p(\cdot)$，均方误差可描述为</p><script type="math/tex; mode=display">E(F;\mathfrak{D})=\int_{x\sim\mathfrak{D}}(f(\mathbf{x}_{i}-y)^2)p(\mathbf{x})dx</script><h3 id="查准率、查全率与-F1"><a href="#查准率、查全率与-F1" class="headerlink" title="查准率、查全率与$F1$"></a>查准率、查全率与$F1$</h3><p>对于二分类问题，可将样例的真实类别与学习器的预测类别的组合划分为：</p><ul><li>真正例(true positive)：预测的正例实际上就是正例</li><li>假正例(false positive)：预测的正例实际上是反例</li><li>真反例(true negative)：预测的反例实际上就是负例</li><li>假反例(false negative)：预测的反例实际上是正例</li></ul><p>由以上的概念可以得出，$真实的正例=TP+FN,真实的反例=TN+FP,预测的正例=TP+FP,预测的反例=TN+FN$，可组成混淆矩阵（confusion matrix）。</p><ul><li>查准率：$P=\frac{TP}{TP+FP}=\frac{预测正确的正例}{预测的正例数}$，即考量预测正例的准确率</li><li>查全率：$R=\frac{TP}{TP+FN}=\frac{预测正确的正例}{真实的正例数}$，即考量预测正例的完整率</li><li>P-R曲线与平衡点（Break-Event Point，简称BEP，它是查准率=查全率时的取值）</li><li>$F1$度量比平衡点更常用：<script type="math/tex; mode=display">F1=\frac{2\times P\times R}{P+R}=\frac{2\times TP}{样例总数+TP-TN}</script></li><li>对查全率与查准率的重视程度不同，定义$\beta&gt;0$度量了查全率对查准率的相对重要性：<script type="math/tex; mode=display">F_{\beta}=\frac{(1+\beta^2)\times P\times R}{(\beta^2\times P)+R}</script></li><li>很多时候会多次的训练/测试，得到多个混淆矩阵。从而使用各种指标的<strong>均值</strong>来进行考量</li></ul><h3 id="ROC与AUC"><a href="#ROC与AUC" class="headerlink" title="ROC与AUC"></a>ROC与AUC</h3><p>ROC(Reveiver Operating Characteristic)全称是“受试者工作特征”，它考察“真正例率”(TPR)与“假正例率”(FPR):</p><script type="math/tex; mode=display">TPR=\frac{TP}{TP+FN}=\frac{预测正确的正例}{真实的正例数}\\ FPR=\frac{FP}{FP+TN}=\frac{预测错误的正例}{真实的反例数}</script><p>AUC即ROC曲线下的面积</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;经验误差与过拟合&quot;&gt;&lt;a href=&quot;#经验误差与过拟合&quot; class=&quot;headerlink&quot; title=&quot;经验误差与过拟合&quot;&gt;&lt;/a&gt;经验误差与过拟合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;错误率&lt;/strong&gt;：如果在$m$个样本中有$a$个样本分类错误，则错误率$E=\frac{a}{m}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;精度(accuracy)&lt;/strong&gt;：$1-\frac{a}{m}$，即“精度=1-错误率”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;误差：学习器的实际预测输出与样本的真实输出之间的差异&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练误差：学习器在训练集上的误差。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;泛化误差：学习器在新样本上的误差。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过拟合(overfitting)&lt;/strong&gt;与&lt;strong&gt;欠拟合(underfitting)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.skecis.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="模型评估" scheme="http://www.skecis.top/tags/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>概率论一：随机事件与概率</title>
    <link href="http://www.skecis.top/2020/06/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%80/"/>
    <id>http://www.skecis.top/2020/06/02/概率论一/</id>
    <published>2020-06-02T08:00:01.000Z</published>
    <updated>2020-06-02T09:23:42.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机事件"><a href="#随机事件" class="headerlink" title="随机事件"></a>随机事件</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>随机事件：</p><ul><li>随机现象的一切可能基本结果组成的集合称为<strong>样本空间</strong>，记为$\Omega=\left\{ \omega \right\}$，其中$\omega$为基本结果，又称为<strong>样本点</strong>。</li><li>随机现象的某些样本点组成的集合称为<strong>随机事件</strong>，常用大写字母$A,B,C,…$表示。由样本空间$\Omega$中的单个元素组成的子集称为<strong>基本事件</strong>。</li><li>如果$A$与$B$没有相同的样本点，则称$A$与$B$</li><li>事件$A$的<strong>对立事件</strong>$\bar{A}$，由在$\Omega$中而不在$A$中的样本点组成的新事件。</li><li>德摩根律：$\bar{A\cup B}=\bar{A}\cap\bar{B}$</li></ul><a id="more"></a><p>概率的性质：</p><ul><li>若$A\supset B$，则<script type="math/tex; mode=display">P(A-B)=P(A)-P(B)</script></li><li>对任意两个事件$A,B$，有<script type="math/tex; mode=display">P(A-B)=P(A)-P(AB)</script></li><li>条件概率：在$B$发生下$A$的条件概率：<script type="math/tex; mode=display">P(A|B)=\frac{P(AB)}{P(B)},其中AB是事件A和B的交</script> <strong>可以理解为：在事件B发生的所有现象中A也同时发生的现象</strong></li><li><strong>乘法公式：</strong><script type="math/tex; mode=display">\begin{aligned}P(A|B)P(B)=P(AB)\end{aligned}\tag{1}</script>若$P(A_{1}A_{2}…A_{n-1})&gt;0$<script type="math/tex; mode=display">\begin{aligned}P(A_{1}A_{2}...A_{n})&=P(A_{1})\cdot \frac{P(A_{1}A_{2})}{P(A_{1})}\cdot \frac{P(A_{1}A_{2}A_{3})}{P(A_{1}A_{2})}\cdot\cdots\cdot \frac{P(A_{1}A_{2}...A_{n})}{P(A_{1}A_{2}...A_{n-1})}\\&=P(A_{1})\cdot P(A_{2}|A_{1})\cdot P(A_{3}|A_{1}A_{2})\cdot\cdots\cdot P(A_{n}|P(A_{1}A_{2}...A_{n-1}))\end{aligned}\tag{2}</script></li><li><strong>全概率公式</strong>：设$B_{1},B_{2},…,B_{n}$为样本空间$\Omega$的一个<strong>分割</strong>，如果$P(B_{i})&gt;0$，则对任意事件$A$有<script type="math/tex; mode=display">\begin{aligned}P(A)&=\sum_{i=1}^{n}P(B_{i})P(A|B_{i})\\&=\sum_{i=1}^{n}P(AB_{i})\end{aligned}</script><strong>可以理解为：$P(事件A)=\sum P(事件A与样本空间中每个不相容事件B_{i}的交)$</strong></li><li><strong>贝叶斯公式</strong>：设$B_{1},B_{2},…,B_{n}$为样本空间$\Omega$的一个<strong>分割</strong>，如果$P(B_{i})&gt;0,P(A)&gt;0$，则<script type="math/tex; mode=display">\begin{aligned}P(B_{i}|A)&=\frac{P(AB_{i})}{P(A)}\\&=\frac{P(A|B_{i})P(B_{i})}{\sum_{i=1}^{n}P(AB_{i})}\\&=\frac{P(A|B_{i})P(B_{i})}{\sum_{j=1}^{n}P(A|B_{j})P(B_{j})}\end{aligned}</script><strong>可以理解为：每个被分割的不相容事件$B_{i}$在任意事件$A$发生的条件下的概率可以由每个事件$B_{i}$的概率和事件$A$在分割事件发生的条件下的概率$P(A|B_{i})$所求得</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;随机事件&quot;&gt;&lt;a href=&quot;#随机事件&quot; class=&quot;headerlink&quot; title=&quot;随机事件&quot;&gt;&lt;/a&gt;随机事件&lt;/h2&gt;&lt;h3 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h3&gt;&lt;p&gt;随机事件：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;随机现象的一切可能基本结果组成的集合称为&lt;strong&gt;样本空间&lt;/strong&gt;，记为$\Omega=\left\{ \omega \right\}$，其中$\omega$为基本结果，又称为&lt;strong&gt;样本点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;随机现象的某些样本点组成的集合称为&lt;strong&gt;随机事件&lt;/strong&gt;，常用大写字母$A,B,C,…$表示。由样本空间$\Omega$中的单个元素组成的子集称为&lt;strong&gt;基本事件&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果$A$与$B$没有相同的样本点，则称$A$与$B$&lt;/li&gt;
&lt;li&gt;事件$A$的&lt;strong&gt;对立事件&lt;/strong&gt;$\bar{A}$，由在$\Omega$中而不在$A$中的样本点组成的新事件。&lt;/li&gt;
&lt;li&gt;德摩根律：$\bar{A\cup B}=\bar{A}\cap\bar{B}$&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.skecis.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="条件概率" scheme="http://www.skecis.top/tags/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>线性回归</title>
    <link href="http://www.skecis.top/2020/06/01/linear-reg/"/>
    <id>http://www.skecis.top/2020/06/01/linear-reg/</id>
    <published>2020-06-01T02:05:21.000Z</published>
    <updated>2020-06-01T08:53:11.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性模型的推导-参考自西瓜书"><a href="#线性模型的推导-参考自西瓜书" class="headerlink" title="线性模型的推导(参考自西瓜书)"></a>线性模型的推导(参考自西瓜书)</h2><p>原问题：假设有$m$个样本$D=\left\{(\mathbf{x}_{1},y_{1}),(\mathbf{x}_{2},y_{2}),…,(\mathbf{x}_{m},y_{m}) \right\}$，每个样本$\mathbf{x}_{i}=\left ( x_{1},x_{2},…,x_{d} \right )$有$d$个特征，一个目标值$y_{i}=y$</p><a id="more"></a><h3 id="单变量的线性回归"><a href="#单变量的线性回归" class="headerlink" title="单变量的线性回归"></a>单变量的线性回归</h3><p>考虑最简单的只有<strong>一个特征</strong>的样本$(x_{i}, y_{i})$，线性回归试图学习：</p><script type="math/tex; mode=display">f(x_{i})=wx_{i}+b,使得f(x_{i})渐进等于y_{i}</script><p>为了求得$w$和$b$，则需使用均方误差作为性能度量，并使均方误差最小化：</p><script type="math/tex; mode=display">(w, b) = \arg\limits_{(w, b)}\min\sum_{i=1}^{m}\left(wx_{i}+b-y_{i} \right)^{2}</script><p>令$E(w,b)=\sum_{i=1}^{m}\left(wx_{i}+b-y_{i} \right)^{2}$分别对$w$和$b$求偏导：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial E(w,b)}{\partial w}&=2\cdot x_{i}\cdot \sum_{i=1}^{m}(wx_{i}+b-y_{i})\\ &=2\sum_{i=1}^{m}(wx_{i}^{2}+bx_{i}-x_{i}y_{i})\\ &=2(\sum_{i=1}^{m}wx_{i}^{2}+\sum_{i=1}^{m}x_{i}(b-y_{i}))\end{aligned} \tag{1}</script><p>对$b$:</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial E(w,b)}{\partial b}&=2\cdot \sum_{i=1}^{m}(wx_{i}+b-y_{i})\\&=2(\sum_{i=1}^{m}wx_{i}+\sum_{i=1}^{m}b-\sum_{i=1}^{m}y_{i})\\&=2(\sum_{i=1}^{m}wx_{i}+mb-\sum_{i=1}^{m}y_{i})\end{aligned} \tag{2}</script><p>从以上$w$和$b$的导函数中可以看出相关变量的系数$\sum_{i=1}^{m}x_{i}^{2}$与$m$都为<strong>正数</strong>，故对应的导函数都为<strong>增函数</strong>，故当导函数值取0时对应的极值为。令$(1)$式和$(2)$式为值为0，可推导出$w$和$b$的表达式。$先令x的均值\bar{x}=\frac{1}{m}\sum_{i=1}^{m}x_{i}$，先推导$b$的表达式：</p><script type="math/tex; mode=display">令\frac{\partial E(w,b)}{\partial b}=0 \\\Rightarrow \sum_{i=1}^{m}wx_{i}+mb-\sum_{i=1}^{m}y_{i}=0 \\\Rightarrow b=\frac{1}{m}\sum_{i=1}^{m}y_{i}-\frac{1}{m}\sum_{i=1}^{m}wx_{i} \tag{3}</script><p>再推导$w$的表达式：</p><script type="math/tex; mode=display">令\frac{\partial E(w,b)}{\partial w}=0 \\\Rightarrow \sum_{i}^{m}wx_{i}^{2}+\sum_{i=1}^{m}x_{i}b-\sum_{i=1}^{m}x_{i}y_{i}=0\\ 带入(3)\Rightarrow \sum_{i=1}^{m}wx_{i}^{2}+\sum_{i=1}^{m}x_{i}(\frac{1}{m}\sum_{i=1}^{m}y_{i}-\frac{1}{m}\sum_{i=1}^{m}wx_{i})-\sum_{i=1}^{m}x_{i}y_{i}=0\\ 化简 \Rightarrow \sum_{i=1}^{m}wx_{i}^{2}+\frac{1}{m}\sum_{i=1}^{m}x_{i}\sum_{i=1}^{m}y_{i}-\frac{w}{m}(\sum_{i=1}^{m}x_{i})^{2}-\sum_{i=1}^{m}x_{i}y_{i}=0\\ 化简合并 \Rightarrow w(\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2})+\sum_{i=1}^{m}(\bar{x}-x_{i})y_{i}=0\\ \Rightarrow w = \frac{\sum_{i=1}^{m}y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2}}</script><p>求得的两个表达式为：</p><script type="math/tex; mode=display">w = \frac{\sum_{i=1}^{m}y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{m}x_{i}^2-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^{2}}, \qquadb=\frac{1}{m}\sum_{i=1}^{m}y_{i}-\frac{1}{m}\sum_{i=1}^{m}wx_{i}</script><h3 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><p>考虑多个特征的样本$\mathbf{x}_{i}=\left ( x_{1},x_{2},…,x_{d} \right )$，多元线性回归试图学习：</p><script type="math/tex; mode=display">f(x_{i})=w^{T}x_{i}+b,使得f(x_{i})渐进等于y_{i}</script><p>为了便于向量的运算，令$\hat{w}=(w;b)=\binom{w}{b}$，把数据集$D$表示为一个$m\times(d+1)大小的矩阵：$</p><script type="math/tex; mode=display">X=\begin{Bmatrix} &x_{11}  &x_{12}&...&x_{1d} &1\\ &x_{21}  &x_{22}&...&x_{2d} &1\\ &...  &...  &...  &... &...\\ &x_{m1}  &x_{m2}  &...  &x_{md} &1\end{Bmatrix}=\begin{pmatrix}\mathbf{x}_{1}^{T} &1\\\mathbf{x}_{2}^{T} &1\\... &...\\\mathbf{x}_{m}^{T} &1\end{pmatrix}</script><p>再把目标值也写成向量的形式：$\mathbf{y}=\begin{pmatrix}<br>y_{1}\\<br>y_{2}\\<br>…\\<br>y_{m}<br>\end{pmatrix}$，则类似有：</p><script type="math/tex; mode=display">\hat{w}=\arg\min(\mathbf{y}-X\hat{w})^{T}(\mathbf{y}-X\hat{w})</script><p>令$E_{\hat{w}}=(\mathbf{y}-X\hat{w})^{T}(\mathbf{y}-X\hat{w})$,对$\hat{w}$求导得：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial E_{\hat{w}}}{\partial \hat{w}}&=\triangledown_{\hat{w}}(\mathbf{y}^{T}-\hat{w}^{T}X^{T})(\mathbf{y}-X\hat{w})\\ &=\triangledown_{\hat{w}}(\mathbf{y}^{T}\mathbf{y}-y^{T}X\hat{w}-\hat{w}^{T}X^{T}\mathbf{y}+\hat{w}^{T}X^{T}X\hat{w})\\ &=0-(\mathbf{y}^{T}X)^{T}-X^{T}\mathbf{y}+(X^{T}X\hat{w}+(\hat{w}X^{T}X)^{T})\\ &=-2X^{T}\mathbf{y}+2X^{T}X\hat{w}\\ &=2X^{T}(X\hat{w}-\mathbf{y})\end{aligned}\\ 这里的矩阵求导法则用了如下两个公式: \\ \frac{\partial(A^{T}WB)}{\partial W}=AB^{T},\frac{\partial(A^{T}W^{T}B)}{\partial W}=BA^{T}</script><p>令上式为零即可推导出$\hat{w}$的表达式：</p><script type="math/tex; mode=display">2X^{T}(X\hat{w}-\mathbf{y})=0\Rightarrow X^{T}X\hat{w}=X^{T}\mathbf{y}\\ \Rightarrow \hat{w}=(X^{T}X)^{-1}X^{T}\mathbf{y}</script><p>令每个样本为$\hat{x}_{i}=(\mathbf{x}_{i},1)$，得最终的多元线性回归模型：</p><script type="math/tex; mode=display">\begin{aligned}f(\hat{x}_{i})&=(\mathbf{x}_{i},1)\begin{pmatrix}w\\b\end{pmatrix}=\hat{x}_{i}\hat{w}\\&=\hat{x}_{i}(X^{T}X)^{-1}X^{T}\mathbf{y}\end{aligned}</script><p>显然，上式能成立的基本条件就是矩阵$X^{T}X$可逆（即满秩矩阵），<strong>当特征的数量大于样本的数量时矩阵就不可逆了</strong>。</p><h3 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h3><script type="math/tex; mode=display">g(y)=w^{T}x+b\\ \Rightarrow \\y = g^{-1}(w^{T}x+b)</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性模型的推导-参考自西瓜书&quot;&gt;&lt;a href=&quot;#线性模型的推导-参考自西瓜书&quot; class=&quot;headerlink&quot; title=&quot;线性模型的推导(参考自西瓜书)&quot;&gt;&lt;/a&gt;线性模型的推导(参考自西瓜书)&lt;/h2&gt;&lt;p&gt;原问题：假设有$m$个样本$D=\left\{(\mathbf{x}_{1},y_{1}),(\mathbf{x}_{2},y_{2}),…,(\mathbf{x}_{m},y_{m}) \right\}$，每个样本$\mathbf{x}_{i}=\left ( x_{1},x_{2},…,x_{d} \right )$有$d$个特征，一个目标值$y_{i}=y$&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.skecis.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linear regression" scheme="http://www.skecis.top/tags/linear-regression/"/>
    
      <category term="算法" scheme="http://www.skecis.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶</title>
    <link href="http://www.skecis.top/2020/04/27/python%E8%BF%9B%E9%98%B6/"/>
    <id>http://www.skecis.top/2020/04/27/python进阶/</id>
    <published>2020-04-27T01:43:11.000Z</published>
    <updated>2020-04-27T01:48:49.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python类特殊方法"><a href="#python类特殊方法" class="headerlink" title="python类特殊方法"></a>python类特殊方法</h2><ol><li><p>__init__ 和 __new__</p><p>init方法<strong>不是类的构造方法，其作用是返回实例</strong>，new方法才是<strong>类的构造方法</strong>，通过继承<strong>object</strong>类重写改方法</p></li><li><p>__enter__ 和 __exit__</p><p>enter作用是<strong>初始化后返回实例</strong>，exit作用是<strong>退出with语句后做处理，例如清理内存，关闭文件，删除冗余等</strong></p></li><li><p>__str__ 和 __repr__</p><p>str方法是用于<strong>将实例的信息以字符串的形式输出</strong>，repr方法与str作用相同，不同在于<strong>repr方法用于交互式环境调试</strong></p></li><li><p>__setattr__ 、__getattr__、__getattribute__ 、__delattr__</p><p>setattr用于<strong>设置属性</strong>，getattr用于<strong>获取不存在的属性</strong>，getattribute用于<strong>访问存在的属性</strong>，delattr用于<strong>删除属性</strong></p></li></ol><a id="more"></a><h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><ul><li>迭代器：可迭代对象皆为迭代器，用户自定义对象通过实现iter方法和next方法实现迭代器。</li><li>生成器：特殊的迭代器，更节省内存（call for need）</li></ul><h2 id="args和-kwargs"><a href="#args和-kwargs" class="headerlink" title="*args和**kwargs"></a>*args和**kwargs</h2><ul><li>*args：表示多个<strong>无名参数</strong>，返回其组成的tuple</li><li>**kwargs：表示<strong>key=value关键字型参数</strong>，返回一个dict</li></ul><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ol><li><p>普通装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decoration</span><span class="params">(func)</span>:</span>  <span class="comment"># 装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125; is running."</span>.format(func__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 返回被包装函数</span></span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装函数</span></span><br></pre></td></tr></table></figure></li><li><p>带参数的装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_param</span><span class="params">(level)</span>:</span>  <span class="comment"># 带参数的装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_decoration</span><span class="params">(func)</span>:</span>  <span class="comment"># 内部装饰器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"&#123;&#125; is running."</span>.format(func.__name__))</span><br><span class="line">            print(<span class="string">"this level is &#123;&#125;"</span>.format(level))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 返回被包装函数</span></span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装函数</span></span><br><span class="line">    <span class="keyword">return</span> my_decoration  <span class="comment"># 返回装饰器</span></span><br></pre></td></tr></table></figure></li><li><p>类装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span>  <span class="comment"># 类装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"this is class decorator."</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        print(<span class="string">"ending..."</span>)</span><br></pre></td></tr></table></figure></li><li><p>functools.wraps:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decoration</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)  # 负责保护原函数的doc和name的装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></li><li><p>装饰器的执行顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="meta">@d3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>等价于<code>func = d1(d2(d3(func)))</code></p></li><li><p>内部装饰器</p><ul><li>@staticmethod: 将类中函数修饰为静态方法不需要额外的参数（self等），<strong>不能访问类中的参数</strong></li><li>@classmethod: 函数必须包含一个类参数<strong>cls</strong>，返回一个实例，<strong>可访问类中的成员</strong></li><li>@property: <strong>将函数作为类的属性</strong>，进而使函数拥有setter方法和deletter方法，其本身是getter方法</li></ul></li><li><p>协程、多线程、多进程</p><ul><li>async</li><li>threading</li><li>multiprocessing</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python类特殊方法&quot;&gt;&lt;a href=&quot;#python类特殊方法&quot; class=&quot;headerlink&quot; title=&quot;python类特殊方法&quot;&gt;&lt;/a&gt;python类特殊方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;__init__ 和 __new__&lt;/p&gt;
&lt;p&gt;init方法&lt;strong&gt;不是类的构造方法，其作用是返回实例&lt;/strong&gt;，new方法才是&lt;strong&gt;类的构造方法&lt;/strong&gt;，通过继承&lt;strong&gt;object&lt;/strong&gt;类重写改方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;__enter__ 和 __exit__&lt;/p&gt;
&lt;p&gt;enter作用是&lt;strong&gt;初始化后返回实例&lt;/strong&gt;，exit作用是&lt;strong&gt;退出with语句后做处理，例如清理内存，关闭文件，删除冗余等&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;__str__ 和 __repr__&lt;/p&gt;
&lt;p&gt;str方法是用于&lt;strong&gt;将实例的信息以字符串的形式输出&lt;/strong&gt;，repr方法与str作用相同，不同在于&lt;strong&gt;repr方法用于交互式环境调试&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;__setattr__ 、__getattr__、__getattribute__ 、__delattr__&lt;/p&gt;
&lt;p&gt;setattr用于&lt;strong&gt;设置属性&lt;/strong&gt;，getattr用于&lt;strong&gt;获取不存在的属性&lt;/strong&gt;，getattribute用于&lt;strong&gt;访问存在的属性&lt;/strong&gt;，delattr用于&lt;strong&gt;删除属性&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="程序语言" scheme="http://www.skecis.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://www.skecis.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫：豆瓣短评</title>
    <link href="http://www.skecis.top/2019/11/28/python%E7%88%AC%E8%99%AB%E8%B1%86%E7%93%A3%E7%9F%AD%E8%AF%84/"/>
    <id>http://www.skecis.top/2019/11/28/python爬虫豆瓣短评/</id>
    <published>2019-11-28T11:08:11.000Z</published>
    <updated>2019-12-15T08:09:25.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导入必要的包-package"><a href="#导入必要的包-package" class="headerlink" title="导入必要的包(package)"></a>导入必要的包(package)</h2><p>若没有下列的包，可使用<code>pip install 包名</code>命令安装</p><ul><li>re: 使用正则表达式</li><li>json: 解析json内容</li><li>time: 爬虫间歇时间控制</li><li>jieba: 中文分词库</li><li>urlib: 将中文关键字编码(百分号+数字)</li><li>requests: 向网站发出请求</li><li>bs4: 解析网页内容</li><li>wordcloud: 生成词云</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2 id="项目需求：爬取豆瓣的书评和影评概要"><a href="#项目需求：爬取豆瓣的书评和影评概要" class="headerlink" title="项目需求：爬取豆瓣的书评和影评概要"></a>项目需求：爬取豆瓣的书评和影评概要</h2><ul><li><strong>输入指定的书籍名称和电影名称，返回其评论构成的词云。</strong></li></ul><h3 id="网站分析-豆瓣电影和豆瓣读书"><a href="#网站分析-豆瓣电影和豆瓣读书" class="headerlink" title="网站分析(豆瓣电影和豆瓣读书)"></a>网站分析(豆瓣电影和豆瓣读书)</h3><p>我们豆瓣电影为例，爬取豆瓣读书原理相仿。</p><ul><li><strong>豆瓣电影</strong>：主页网址<a href="https://movie.douban.com/" target="_blank" rel="noopener">https://movie.douban.com/</a>，其页面如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_1.png" alt="movie.com">  </li></ul><p>首先我们打开谷歌浏览器的开发者工具，如果我们要搜索电影则在搜索框中键入搜索关键字是最近刚出的电影<strong>小丑</strong>，则会弹出下拉列表，并且旁边的Network中会显示出刚刚的响应：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_2.png" alt="xiaochou"><br>我们可以发现出现了一个json文件，这个json文件即是下拉列表的信息：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_3.png" alt="list"><br>我们再看看它的url，也就是我们爬虫目标网址，同时我们也能找到需要的请求头headers，可以发现它将我们的搜索关键字重新编码了(%+数字)，这个我们稍后用urllib处理编码：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_6.png" alt="head"><br>继续分析json文件，json文件中的内容就是每个电影的网址，列表中第一个地址即是我们要找的<strong>小丑</strong>的网址主页：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_4.png" alt="xiaochou"><br>我们点进小丑的主页进行验证，网址中的那串数字就是我们需要解析出来的电影唯一标识：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_5.png" alt="zhuye"><br>最后我们来看我们的目的地评论的网址，往下翻，点击全部评论：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_7.png" alt="com"><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_8.png" alt="com1"><br>发现网址并没有什么规律，我们继续点击评论的下一页，规律出现了。每增加一页，start参数增加20，这便是我们批量爬取评论的根据：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/1_9.png" alt="page"><br>好，我们继续看评论在html文件中的位置：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/2.png" alt="loc"><br>ok，分析完毕，爬虫抓取大概就是这个流程，最终的目的就是找到<strong>需求信息的位置</strong>。</p><h3 id="爬虫设计"><a href="#爬虫设计" class="headerlink" title="爬虫设计"></a>爬虫设计</h3><p>根据以上的分析，我们这样来设计我们的爬虫的爬虫流程：</p><ol><li>将我们输入的关键字编码成网址中的编码类型。</li><li>获取json中电影的真实地址信息。</li><li>生成我们要访问的评论所在的网页地址</li><li>抓取评论信息。</li></ol><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>接下来给出几个关键步骤的代码说明</p><h3 id="汉字编码"><a href="#汉字编码" class="headerlink" title="汉字编码"></a>汉字编码</h3><p>使用<code>urllib.parse</code>中的<code>quote</code>函数进行编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__handle_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    编码中文关键字(%+[00-99])</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> str(quote(name))</span><br></pre></td></tr></table></figure><h3 id="解析json获取地址"><a href="#解析json获取地址" class="headerlink" title="解析json获取地址"></a>解析json获取地址</h3><p>使用<code>json</code>库中的<code>loads</code>函数解析json文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__find_url</span><span class="params">(self, url, tp)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取真实主页地址和编号id</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    r = requests.get(url, headers=self.headers[tp])</span><br><span class="line">    json_data = json.loads(r.text)</span><br><span class="line">    address_num = re.search(<span class="string">'[0-9]+'</span>, json_data[<span class="number">0</span>][<span class="string">'url'</span>])</span><br><span class="line">    <span class="keyword">if</span> tp == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> self.movie_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取电影地址</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.book_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取书籍地址</span></span><br></pre></td></tr></table></figure><h3 id="使用WordCloud生成词云"><a href="#使用WordCloud生成词云" class="headerlink" title="使用WordCloud生成词云"></a>使用WordCloud生成词云</h3><p>使用<code>WordCloud</code>生成词云，用<code>jieba</code>进行中文分词。该函数中有两个变量需要解释：</p><ul><li>bg_image: 为词云添加背景图片。</li><li>scale: 词云图片的清晰度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__plot_wordcloud</span><span class="params">(self, name, bg_image=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    绘制词云</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    file_name = str(name) + <span class="string">'.txt'</span></span><br><span class="line">    f = open(file_name, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>).read()</span><br><span class="line">    cut_text = <span class="string">" "</span>.join(jieba.cut(f))  <span class="comment"># 中文分词</span></span><br><span class="line">    print(<span class="string">"正在生成词云..."</span>)</span><br><span class="line">    word_cloud = WordCloud(</span><br><span class="line">        scale=<span class="number">10</span>,</span><br><span class="line">        font_path=<span class="string">'C:/Windows/Fonts/simfang.ttf'</span>,</span><br><span class="line">        background_color=<span class="string">"white"</span>, width=<span class="number">1000</span>, height=<span class="number">1000</span></span><br><span class="line">    ).generate(cut_text)</span><br><span class="line">    plt.imshow(word_cloud, interpolation=<span class="string">'bilinear'</span>)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h2 id="完整代码及运行示例"><a href="#完整代码及运行示例" class="headerlink" title="完整代码及运行示例"></a>完整代码及运行示例</h2><p>将整个爬虫过程封装，根据上述爬取电影评论的方法同时也实现了爬取数据评论的方法，最后爬取了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanCrawl</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, info_type)</span>:</span></span><br><span class="line">        self.info_type = info_type</span><br><span class="line">        self.headers = [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'movie.douban.com'</span></span><br><span class="line">            &#125;,  <span class="comment"># movie's headers</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36'</span>,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'book.douban.com'</span></span><br><span class="line">            &#125;  <span class="comment"># book's headers</span></span><br><span class="line">        ]</span><br><span class="line">        self.movie_search_url = <span class="string">"https://movie.douban.com/j/subject_suggest?q="</span></span><br><span class="line">        self.movie_url = <span class="string">"https://movie.douban.com/subject/%s/"</span></span><br><span class="line">        self.movie_comment_url = <span class="string">"https://movie.douban.com/subject/%s/comments?start=%d&amp;limit=20&amp;sort=new_score&amp;status=P"</span></span><br><span class="line"></span><br><span class="line">        self.book_search_url = <span class="string">"https://book.douban.com/j/subject_suggest?q="</span></span><br><span class="line">        self.book_url = <span class="string">"https://book.douban.com/subject/%s/"</span></span><br><span class="line">        self.book_comment_url = <span class="string">"https://book.douban.com/subject/%s/comments/hot?p=%d"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_crawl</span><span class="params">(self, name, bg_image=None)</span>:</span></span><br><span class="line">        name_str = self.__handle_name(name)  <span class="comment"># 获取url的gbk编码</span></span><br><span class="line">        text_list = []</span><br><span class="line">        <span class="keyword">if</span> self.info_type == <span class="string">"movie"</span>:</span><br><span class="line">            print(<span class="string">"-----爬取电影短评-----"</span>)</span><br><span class="line">            self.movie_search_url += name_str</span><br><span class="line">            self.movie_url, num_str = self.__find_url(self.movie_search_url, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">15</span>):</span><br><span class="line">                url = self.movie_comment_url % (num_str, i*<span class="number">20</span>)</span><br><span class="line">                time.sleep(np.random.randint(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 间隔1~3秒</span></span><br><span class="line">                print(<span class="string">"正在获取第%d个页面"</span> % i)</span><br><span class="line">                r = requests.get(url, headers=self.headers[<span class="number">0</span>])</span><br><span class="line">                soup = BeautifulSoup(r.content, <span class="string">'lxml'</span>)</span><br><span class="line">                comment_list = soup.find_all(<span class="string">'span'</span>, class_=<span class="string">'short'</span>)</span><br><span class="line">                <span class="keyword">for</span> ct <span class="keyword">in</span> comment_list:</span><br><span class="line">                    text_list.append(ct.text)</span><br><span class="line">            self.__comment_to_txt(name, text_list)  <span class="comment"># 存储评论文字</span></span><br><span class="line">            self.__plot_wordcloud(name, bg_image)  <span class="comment"># 绘制词云</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"-----爬取书籍短评-----"</span>)</span><br><span class="line">            self.book_search_url += name_str</span><br><span class="line">            self.book_url, num_str = self.__find_url(self.book_search_url, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">20</span>):</span><br><span class="line">                url = self.book_comment_url % (num_str, i)</span><br><span class="line">                time.sleep(np.random.randint(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 间隔1~3秒</span></span><br><span class="line">                print(<span class="string">"正在获取第%d个页面"</span> % i)</span><br><span class="line">                r = requests.get(url, headers=self.headers[<span class="number">1</span>])</span><br><span class="line">                soup = BeautifulSoup(r.content, <span class="string">'lxml'</span>)</span><br><span class="line">                comment_list = soup.find_all(<span class="string">'span'</span>, class_=<span class="string">'short'</span>)</span><br><span class="line">                <span class="keyword">for</span> ct <span class="keyword">in</span> comment_list:</span><br><span class="line">                    text_list.append(ct.text)</span><br><span class="line">            self.__comment_to_txt(name, text_list)</span><br><span class="line">            self.__plot_wordcloud(name, bg_image)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__plot_wordcloud</span><span class="params">(self, name, bg_image=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        绘制词云</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :param bg_image:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        file_name = str(name) + <span class="string">'.txt'</span></span><br><span class="line">        f = open(file_name, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>).read()</span><br><span class="line">        cut_text = <span class="string">" "</span>.join(jieba.cut(f))</span><br><span class="line">        print(<span class="string">"正在生成词云..."</span>)</span><br><span class="line">        word_cloud = WordCloud(</span><br><span class="line">            scale=<span class="number">10</span>,</span><br><span class="line">            font_path=<span class="string">'C:/Windows/Fonts/simfang.ttf'</span>,</span><br><span class="line">            background_color=<span class="string">"white"</span>, width=<span class="number">1000</span>, height=<span class="number">1000</span></span><br><span class="line">        ).generate(cut_text)</span><br><span class="line">        plt.imshow(word_cloud, interpolation=<span class="string">'bilinear'</span>)</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__comment_to_txt</span><span class="params">(self, name, clist)</span>:</span></span><br><span class="line">        file_name = str(name) + <span class="string">'.txt'</span></span><br><span class="line">        <span class="keyword">with</span> open(file_name, <span class="string">'a+'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> clist:</span><br><span class="line">                f.write(c)</span><br><span class="line">            f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__handle_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        编码中文关键字</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> str(quote(name))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__find_url</span><span class="params">(self, url, tp)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取真实主页地址和编号id</span></span><br><span class="line"><span class="string">        :param url:</span></span><br><span class="line"><span class="string">        :param tp:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        r = requests.get(url, headers=self.headers[tp])</span><br><span class="line">        json_data = json.loads(r.text)</span><br><span class="line">        address_num = re.search(<span class="string">'[0-9]+'</span>, json_data[<span class="number">0</span>][<span class="string">'url'</span>])</span><br><span class="line">        <span class="keyword">if</span> tp == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.movie_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取电影地址</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.book_url % address_num, address_num.group(<span class="number">0</span>)  <span class="comment"># 获取书籍地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    my_crawl = DoubanCrawl(<span class="string">"movie"</span>)</span><br><span class="line">    my_crawl.info_crawl(<span class="string">'千与千寻'</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-----爬取电影短评-----</span><br><span class="line">正在获取第0个页面</span><br><span class="line">正在获取第1个页面</span><br><span class="line">正在获取第2个页面</span><br><span class="line">正在获取第3个页面</span><br><span class="line">正在获取第4个页面</span><br><span class="line">正在获取第5个页面</span><br><span class="line">正在获取第6个页面</span><br><span class="line">正在获取第7个页面</span><br><span class="line">正在获取第8个页面</span><br><span class="line">正在获取第9个页面</span><br><span class="line">正在获取第10个页面</span><br><span class="line">正在获取第11个页面</span><br><span class="line">正在获取第12个页面</span><br><span class="line">正在获取第13个页面</span><br><span class="line">正在获取第14个页面</span><br><span class="line">Building prefix dict from the default dictionary ...</span><br><span class="line">Loading model from cache C:\Users\SkecisAI\AppData\Local\Temp\jieba.cache</span><br><span class="line">Loading model cost 0.879 seconds.</span><br><span class="line">Prefix dict has been built succesfully.</span><br><span class="line">正在生成词云...</span><br></pre></td></tr></table></figure><p><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/2_1.png" alt="cloud"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导入必要的包-package&quot;&gt;&lt;a href=&quot;#导入必要的包-package&quot; class=&quot;headerlink&quot; title=&quot;导入必要的包(package)&quot;&gt;&lt;/a&gt;导入必要的包(package)&lt;/h2&gt;&lt;p&gt;若没有下列的包，可使用&lt;code&gt;pip install 包名&lt;/code&gt;命令安装&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;re: 使用正则表达式&lt;/li&gt;
&lt;li&gt;json: 解析json内容&lt;/li&gt;
&lt;li&gt;time: 爬虫间歇时间控制&lt;/li&gt;
&lt;li&gt;jieba: 中文分词库&lt;/li&gt;
&lt;li&gt;urlib: 将中文关键字编码(百分号+数字)&lt;/li&gt;
&lt;li&gt;requests: 向网站发出请求&lt;/li&gt;
&lt;li&gt;bs4: 解析网页内容&lt;/li&gt;
&lt;li&gt;wordcloud: 生成词云&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python爬虫" scheme="http://www.skecis.top/categories/Python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://www.skecis.top/tags/Python/"/>
    
      <category term="爬虫" scheme="http://www.skecis.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>排序之道</title>
    <link href="http://www.skecis.top/2019/11/22/python%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.skecis.top/2019/11/22/python排序/</id>
    <published>2019-11-22T05:41:03.000Z</published>
    <updated>2019-12-15T09:05:53.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本文使用python实现了一些常用的排序方法。文章结构如下如下：</p><ol><li><a href="#直接插入排序">直接插入排序</a></li><li><a href="#希尔排序">希尔排序</a></li><li><a href="#冒泡排序">冒泡排序</a></li><li><a href="#快速排序">快速排序</a></li><li><a href="#简单选择排序">简单选择排序</a></li><li><a href="#堆排序">堆排序</a></li><li><a href="#归并排序">归并排序</a></li><li><a href="#基数排序">基数排序</a></li></ol><a id="more"></a><p><strong>上述所有的排序均写在一个python自定义类中，作为成员函数。</strong></p><h2 id="排序方法详细介绍"><a href="#排序方法详细介绍" class="headerlink" title="排序方法详细介绍"></a>排序方法详细介绍</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><strong>直接插入排序</strong>(Straight Insertion Sort)是一种最简单的排序方法，它的基本操作是一个值插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/insert.png" alt="insert"><br>由上图可知若最初始的有序表即为数组的第一个元素。用python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">straight_insertion_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    直接插入排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> self.__straight_insert(value_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__straight_insert</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    sorted_list = []</span><br><span class="line">    sorted_list.append(value_list.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(value_list)):</span><br><span class="line">        tail = <span class="literal">True</span>  <span class="comment"># 是否在尾部插入</span></span><br><span class="line">        insert_loc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(sorted_list)):</span><br><span class="line">            <span class="keyword">if</span> value_list[i] &lt;= sorted_list[j]:</span><br><span class="line">                tail = <span class="literal">False</span></span><br><span class="line">                insert_loc = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        sorted_list.append(value_list[i])  <span class="comment"># 先将值插入尾部</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">            <span class="comment"># 移动值</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(sorted_list) - <span class="number">1</span>, insert_loc, <span class="number">-1</span>):</span><br><span class="line">                tmp = sorted_list[j]</span><br><span class="line">                sorted_list[j] = sorted_list[j - <span class="number">1</span>]</span><br><span class="line">                sorted_list[j - <span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><strong>希尔排序</strong>(Shell’s Sort)又称“缩小增量排序”(Diminishing Incerement Sort)，它也是一种数插入排序的方法，但在时间效率上较前面的排序方法有较大的改进。它的基本思想是：先将整个待排记录序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/shell.png" alt="shell"><br>即根据增量将原序列分割成多个子序列进行直接插入排序。<strong>增量应不断减小，且最后一个增量为1</strong>。用python实现如下(其中用到的子函数见前文)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shells_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    gap = len(value_list) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt;= <span class="number">1</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i + gap) &lt; len(value_list):</span><br><span class="line">            start = i</span><br><span class="line">            gap_list = []</span><br><span class="line">            <span class="keyword">while</span> start &lt; len(value_list):</span><br><span class="line">                gap_list.append(value_list[start])</span><br><span class="line">                start = start + gap</span><br><span class="line">            gap_list = self.__straight_insert(gap_list)</span><br><span class="line">            start = i</span><br><span class="line">            <span class="keyword">while</span> start &lt; len(value_list):</span><br><span class="line">                value_list[start] = gap_list.pop(<span class="number">0</span>)</span><br><span class="line">                start = start + gap</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的过程很简单。首先将第一个记录的关键字和第二个记录的关键字进行比较，若逆序(与需要的顺序相反)，则将两个记录交换之，然后比较第二个记录和第三个记录的关键字，以此类推。为第一趟冒泡结束，接着对前$n-1$个记录继续进行上述的过程。这样重复的过程直至$n-1=1$结束。排序过程如下所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/buble.png" alt="buble"><br>用python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubule_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value_list) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(value_list)):</span><br><span class="line">            <span class="keyword">if</span> value_list[i] &gt; value_list[j]:</span><br><span class="line">                tmp = value_list[j]</span><br><span class="line">                value_list[j] = value_list[i]</span><br><span class="line">                value_list[i] = tmp</span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>快速排序</strong>(Quick Sort)是对冒泡排序的的一种改进。它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，已达到整个序列有序。其排序思想如下：</p><blockquote><p>首先任意选取一个记录（通常可选第一个记录）作为<strong>枢轴</strong>，然后按下述原则重新排列记录：将所有关键字较它小的记录都安置在它的位置之前，将所有关键字较它大的记录都安置在它的位置之后。一趟快速排序的具体做法是：设两个指针low和high，他们的初值分别为最低位置的下一个位置和最高位，设最低位置位枢轴的关键字为pivotkey，则首先从high所指位置起像前搜索找到第一个关键字小于pivotkey的记录和枢轴记录互相交换。<strong>发生了交换后</strong>才从low所指向的位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录互相交换。重复这两步直至low=how为止</p></blockquote><p>如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/quick.png" alt="quick"><br>特别要注意换方向的时机是<strong>发生了交换后</strong>，用python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(value_list) - <span class="number">1</span></span><br><span class="line">    self.__qsort(value_list, low, high)</span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__qsort</span><span class="params">(self, val_list, low, high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序辅助函数</span></span><br><span class="line"><span class="string">    :param val_list: 无序列表</span></span><br><span class="line"><span class="string">    :param low: 低位</span></span><br><span class="line"><span class="string">    :param high: 高位</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pivot_key = low</span><br><span class="line">    tmp_low = pivot_key</span><br><span class="line">    tmp_high = high</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:  <span class="comment"># 分成一边比轴（pivot）大，一边比轴（pivot）小的顺序</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">if</span> val_list[high] &lt; val_list[pivot_key]:</span><br><span class="line">                tmp = val_list[high]</span><br><span class="line">                val_list[high] = val_list[pivot_key]</span><br><span class="line">                val_list[pivot_key] = tmp</span><br><span class="line">                pivot_key = high</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 发生交换后，就换方向</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">if</span> val_list[low] &gt; val_list[pivot_key]:</span><br><span class="line">                tmp = val_list[low]</span><br><span class="line">                val_list[low] = val_list[pivot_key]</span><br><span class="line">                val_list[pivot_key] = tmp</span><br><span class="line">                pivot_key = low</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 发生交换后，就换方向</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">    self.__qsort(val_list, tmp_low, pivot_key - <span class="number">1</span>)</span><br><span class="line">    self.__qsort(val_list, pivot_key + <span class="number">1</span>, tmp_high)</span><br></pre></td></tr></table></figure><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>选择排序的基本思想是：每一趟在$n-i+1(i=1,2,…,n-1)$个记录中选取关键字最小的记录作为有序序列中第$i$个记录。简单选择排序：通过$n-1$次关键字的比较，从$n-i+1$个记录中选出关键字最小的记录，并和第$i(1\leq i\leq n)$个记录交换之。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/selection.png" alt="simple"><br>用python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_selection_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    简单选择排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value_list)):</span><br><span class="line">        min_val = <span class="number">9999999</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(value_list)):</span><br><span class="line">            <span class="keyword">if</span> min_val &gt; value_list[j]:</span><br><span class="line">                min_val = value_list[j]</span><br><span class="line">        count = <span class="number">0</span>  <span class="comment"># 如果有多个相同的最小值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(value_list)):</span><br><span class="line">            <span class="keyword">if</span> min_val == value_list[j]:</span><br><span class="line">                tmp = value_list[j]</span><br><span class="line">                value_list[j] = value_list[i + count]</span><br><span class="line">                value_list[i + count] = tmp</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>堆</strong>的定义如下：$n$个元素的序列$\left \{k_{1},k_{2}, …k_{n} \right \}$当且仅当满足一下关系时，称之为堆。</p><script type="math/tex; mode=display">\left\{\begin{matrix}k_{i}\leq k_{2i}\\k_{i}\leq k_{2i+1}\end{matrix}\right.或\left\{\begin{matrix}k_{i}\geq k_{2i}\\k_{i}\geq k_{2i+1}\end{matrix}\right.</script><p><strong>若将序列看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端节点均不大于（或不小于）其左、右孩子节点的值。由此，若序列是堆，则堆顶元素必为序列中的最小值（或最大值）</strong>。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/heap.png" alt="heap"><br>至此，我们可以给出<strong>堆排序</strong>的过程：<strong>若在输出堆顶的最小值后，使得剩余$n-1$个元素的序列又建成一个堆，则得到$n$个元素中的次小值。如此反复执行，便能得到一个有序序列。</strong><br>故整个堆排序可以大致分为两个过程：</p><ul><li>将无序序列建成堆。</li><li>输出堆顶元素后，用类似建堆的方法调整堆。</li></ul><p>如下两个图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/construct_heap.png" alt="1"><br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/heap_sort.png" alt="2"><br>根据堆排序的特点总结出两点注意事项：</p><ol><li>利用把堆看成完全二叉树的特点，用<strong>完全二叉树的性质</strong>解决算法问题</li><li>建堆的过程是从树种的<strong>最后一个非终端节点</strong>逆序开始调整的。</li><li>每调整一次需要检查前后是否依然保持<strong>堆的特征</strong>。</li></ol><p>本文利用了二叉树的<strong>孩子兄弟表示法</strong>来生成二叉树(堆)的。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">__CldSibNode</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    私有内部类：孩子兄弟二叉链表节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.value = val</span><br><span class="line">        self.child = <span class="literal">None</span></span><br><span class="line">        self.sibling = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">堆排序</span></span><br><span class="line"><span class="string">:param value_list: 无序列表</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">sorted_list = []</span><br><span class="line">root_node = self.__CldSibNode(<span class="literal">None</span>)</span><br><span class="line">self.__child_sibling(root_node, value_list, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> ct <span class="keyword">in</span> range(<span class="number">1</span>, len(value_list) // <span class="number">2</span> + <span class="number">1</span>):  <span class="comment"># 建堆</span></span><br><span class="line">    self.__adjust_heap(root_node, len(value_list) // <span class="number">2</span> + <span class="number">1</span> - ct, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(value_list) + <span class="number">1</span>):  <span class="comment"># 堆排序</span></span><br><span class="line">    sorted_list.append(root_node.value)  <span class="comment"># 输出堆顶元素</span></span><br><span class="line">    head = root_node</span><br><span class="line">    self.__shrink_heap(root_node, len(value_list) + <span class="number">1</span> - i, <span class="number">1</span>, head)  <span class="comment"># 收缩堆</span></span><br><span class="line">    self.__adjust_heap(root_node, <span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 调整堆</span></span><br><span class="line"><span class="keyword">return</span> sorted_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__child_sibling</span><span class="params">(self, node, value_list, ind)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建完全二叉树的左孩子右兄弟二叉链表</span></span><br><span class="line"><span class="string">    :param node: 当前节点</span></span><br><span class="line"><span class="string">    :param value_list:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> ind &gt;= len(value_list):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    node.value = value_list[ind]</span><br><span class="line">    <span class="keyword">if</span> (ind * <span class="number">2</span> + <span class="number">1</span>) &lt; len(value_list):</span><br><span class="line">        node.child = self.__CldSibNode(<span class="literal">None</span>)  <span class="comment"># 孩子</span></span><br><span class="line">        self.__child_sibling(node.child, value_list, ind * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (ind * <span class="number">2</span> + <span class="number">2</span>) &lt; len(value_list):</span><br><span class="line">        node.child.sibling = self.__CldSibNode(<span class="literal">None</span>)  <span class="comment"># 兄弟</span></span><br><span class="line">        self.__child_sibling(node.child.sibling, value_list, ind * <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__adjust_heap</span><span class="params">(self, root_node, last_ind, now_ind)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        内部函数：交换两个变量值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> y, x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> root_node) <span class="keyword">or</span> (<span class="keyword">not</span> root_node.child):  <span class="comment"># 不为空且有孩子</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> now_ind == last_ind:  <span class="comment"># 需要调整的非终端节点</span></span><br><span class="line">        tmp = root_node</span><br><span class="line">        cg = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> tmp.child:</span><br><span class="line">            <span class="keyword">if</span> tmp.value &gt; tmp.child.value:  <span class="comment"># 如果大于左子树根节点</span></span><br><span class="line">                tmp.value, tmp.child.value = change(tmp.value, tmp.child.value)</span><br><span class="line">                cg = <span class="literal">True</span>  <span class="comment"># 发生交换</span></span><br><span class="line">            <span class="keyword">if</span> tmp.child.sibling:</span><br><span class="line">                <span class="keyword">if</span> tmp.value &gt; tmp.child.sibling.value:</span><br><span class="line">                    <span class="keyword">if</span> cg:  <span class="comment"># 如果发生过交换</span></span><br><span class="line">                        tmp.value, tmp.child.value = change(tmp.value, tmp.child.value)</span><br><span class="line">                    tmp.value, tmp.child.sibling.value = change(tmp.value, tmp.child.sibling.value)</span><br><span class="line">                    tmp = tmp.child.sibling</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> cg:  <span class="comment"># 如果发生过交换</span></span><br><span class="line">                        tmp = tmp.child</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    self.__adjust_heap(root_node.child, last_ind, now_ind * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> root_node.child.sibling:</span><br><span class="line">        self.__adjust_heap(root_node.child.sibling, last_ind, now_ind * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__shrink_heap</span><span class="params">(self, root_node, last_ind, now_ind, head)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> root_node) <span class="keyword">or</span> (now_ind * <span class="number">2</span> &gt; last_ind):  <span class="comment"># 不为空</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> last_ind == (now_ind * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        head.value = root_node.child.sibling.value</span><br><span class="line">        root_node.child.sibling = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> last_ind == (now_ind * <span class="number">2</span>):</span><br><span class="line">        head.value = root_node.child.value</span><br><span class="line">        root_node.child = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> root_node.child:</span><br><span class="line">        self.__shrink_heap(root_node.child, last_ind, now_ind * <span class="number">2</span>, head)</span><br><span class="line">        self.__shrink_heap(root_node.child.sibling, last_ind, now_ind * <span class="number">2</span> + <span class="number">1</span>, head)</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序(Merging)，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假设初始序列有$n$个记录，则可看成是$n$个有序的子序列，每个子序列的长度为1，然后两两归并，得到$\left \lceil \frac{n}{2} \right \rceil$个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为$n$的有序序列为止，这种排序方法称为<strong>2-路归并排序</strong>。算法的基本思想如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/merge.png" alt="merge"><br>其中两个子序列的合并大有学问，基本思想就是：<strong>分别在两个序列头设置指针，比较两个序列指针所指的值的大小，将满足要求的值提取出来形成新列表，并将指针右移。当其中一个指针指向结尾之后时，表示其中一个列表已取尽，接着直接在新列表尾部连接另一个列表</strong>。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/merge1.png" alt="mege_1"><br>用python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merging_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    归并排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> np.power(<span class="number">2</span>, i) &lt; len(value_list):</span><br><span class="line">        count = np.power(<span class="number">2</span>, i)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        outer_tmp = []</span><br><span class="line">        <span class="keyword">while</span> start &lt; len(value_list):</span><br><span class="line">            other = start + count  <span class="comment"># 定位另一边</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">if</span> other &gt;= len(value_list):  <span class="comment"># 另一边不存在</span></span><br><span class="line">                outer_tmp.extend(value_list[start:start + count])  <span class="comment"># 直接合并</span></span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 结束</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; count) <span class="keyword">or</span> (right &lt; count):</span><br><span class="line">                <span class="keyword">if</span> other + right &gt;= len(value_list):  <span class="comment"># 右边提前结束</span></span><br><span class="line">                    tmp.extend(value_list[start + left:start + count])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> value_list[start + left] &lt; value_list[other + right]:  <span class="comment"># 左边更小</span></span><br><span class="line">                    tmp.append(value_list[start + left])</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> left == count:  <span class="comment"># 左边遍历结束</span></span><br><span class="line">                        tmp.extend(value_list[other + right:other + count])  <span class="comment"># 合并右边</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 右边更小</span></span><br><span class="line">                    tmp.append(value_list[other + right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> right == count:  <span class="comment"># 右边遍历结束</span></span><br><span class="line">                        tmp.extend(value_list[start + left:start + count])  <span class="comment"># 合并左边</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            outer_tmp.extend(tmp)</span><br><span class="line">            start += count * <span class="number">2</span></span><br><span class="line">        value_list = outer_tmp</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序</strong>(Radix Sort)是利用了多关键字排序的思想，分为从低位关键字开始排序的<strong>最低位优先法</strong>(Least Significant Digit first)和从高位关键字开始排序的<strong>高位优先法</strong>(Most Signficant Digit first)。基数排序是借助“分配”和“收集”两种操作对单逻辑关键字进行排序的一种内部排序方法。</p><blockquote><p>如对三位数(0~999，即有三个关键字)进行最低位优先法排序：<strong>首先以静态链表存储$n$个待排记录，并另表头指针指向第一个记录；第一趟分配对低位关键字个位数进行，初始化10个空队列，每个队列中记录关键字的个位数相等。第一趟收集是改变所有费控队列的队尾指针域，令其指向下一个非空队列的队头，重新将10个队列链接成一个链表。第二次、第三次分别对十位和百位进行同样的操作</strong>，直至排序结束。</p></blockquote><p>如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/radix.png" alt="radix"><br>排序时有两点需要注意：</p><ol><li>每完成一趟排序，要清空队列。</li><li>队列的连接要找到第一个不为空的队列作为头，和绕开所有空队列。</li></ol><p>用python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(self, value_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    基数排序</span></span><br><span class="line"><span class="string">    :param value_list: 无序列表</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_n</span><span class="params">(num, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        内部函数：得到数的第n位</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        remainder = num % np.power(<span class="number">10</span>, n)</span><br><span class="line">        quotient = remainder // np.power(<span class="number">10</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> quotient</span><br><span class="line"></span><br><span class="line">    max_val = <span class="number">-99999</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> value_list:</span><br><span class="line">        <span class="keyword">if</span> val &gt; max_val:</span><br><span class="line">            max_val = val</span><br><span class="line">    iter_nums = <span class="number">0</span>  <span class="comment"># 最大位数</span></span><br><span class="line">    <span class="keyword">while</span> max_val &gt; <span class="number">0</span>:</span><br><span class="line">        iter_nums += <span class="number">1</span></span><br><span class="line">        max_val = max_val // <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> bit <span class="keyword">in</span> range(<span class="number">1</span>, iter_nums + <span class="number">1</span>):  <span class="comment"># 开始排序</span></span><br><span class="line">        tmp_list = []</span><br><span class="line">        qs = []  <span class="comment"># 创建新的链式队列数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            qs.append(que.LinkedQueue())</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> value_list:</span><br><span class="line">            qs[get_n(val, bit)].enqueue(val)  <span class="comment"># 按位数入队</span></span><br><span class="line">        qhead = <span class="literal">None</span></span><br><span class="line">        tmp_q = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> qs[j].front <span class="keyword">and</span> (qhead <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">                qhead = qs[j]  <span class="comment"># 寻找重组队列头</span></span><br><span class="line">                tmp_q = qhead</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> qs[j].front:</span><br><span class="line">                tmp_q.rear.pnext = qs[j].front  <span class="comment"># 将队列按顺序连接</span></span><br><span class="line">                tmp_q = qs[j]</span><br><span class="line">        tmp = qhead.front  <span class="comment"># 链接队列头</span></span><br><span class="line">        <span class="keyword">while</span> tmp:  <span class="comment"># 更新数组列表</span></span><br><span class="line">            tmp_list.append(tmp.value)</span><br><span class="line">            tmp = tmp.pnext</span><br><span class="line">        value_list = tmp_list</span><br><span class="line">    sorted_list = value_list</span><br><span class="line">    <span class="keyword">return</span> sorted_list</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>编写测试代码和运行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 排序之道</span></span><br><span class="line">    li = list(np.random.randint(<span class="number">1</span>, <span class="number">1000</span>, <span class="number">30</span>))</span><br><span class="line">    my_sort = MySort()</span><br><span class="line">    print(<span class="string">'original sequence: '</span>, li)</span><br><span class="line">    print(<span class="string">'-'</span> * <span class="number">170</span>)</span><br><span class="line">    print(<span class="string">'1.'</span>, my_sort.straight_insertion_sort.__name__, <span class="string">':'</span>, my_sort.straight_insertion_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'2.'</span>, my_sort.shells_sort.__name__, <span class="string">':            '</span>, my_sort.shells_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'3.'</span>, my_sort.bubule_sort.__name__, <span class="string">':            '</span>, my_sort.bubule_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'4.'</span>, my_sort.quick_sort.__name__, <span class="string">':             '</span>, my_sort.quick_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'5.'</span>, my_sort.simple_selection_sort.__name__, <span class="string">':  '</span>, my_sort.simple_selection_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'6.'</span>, my_sort.heap_sort.__name__, <span class="string">':              '</span>, my_sort.heap_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'7.'</span>, my_sort.merging_sort.__name__, <span class="string">':           '</span>, my_sort.merging_sort(li.copy()))</span><br><span class="line">    print(<span class="string">'8.'</span>, my_sort.radix_sort.__name__, <span class="string">':             '</span>, my_sort.radix_sort(li.copy()))</span><br></pre></td></tr></table></figure><p>测试运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">original sequence:  [758, 74, 857, 781, 831, 719, 489, 785, 405, 621, 165, 568, 915, 939, 886, 4, 966, 461, 385, 757, 263, 505, 793, 259, 107, 437, 296, 702, 240, 644]</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">1. straight_insertion_sort : [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">2. shells_sort :             [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">3. bubule_sort :             [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">4. quick_sort :              [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">5. simple_selection_sort :   [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">6. heap_sort :               [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">7. merging_sort :            [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br><span class="line">8. radix_sort :              [4, 74, 107, 165, 240, 259, 263, 296, 385, 405, 437, 461, 489, 505, 568, 621, 644, 702, 719, 757, 758, 781, 785, 793, 831, 857, 886, 915, 939, 966]</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各个排序效率见下图：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E6%8E%92%E5%BA%8F/time_zone.png" alt="time"><br>可以得出以下几个结论：</p><ol><li>从平均时间性能而言，<strong>快速排序</strong>最佳。</li><li><strong>堆排序</strong>适用于$n$较大的数据。</li><li><strong>基数排序</strong>是稳定的，时间复杂度较大的<strong>简单排序</strong>方法也是稳定的。</li><li>稳定性是由方法本身决定的。</li><li>没有最好的排序方法，视情况而定。</li></ol><h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><ol><li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L16" target="_blank" rel="noopener">直接插入排序</a></li><li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L44" target="_blank" rel="noopener">希尔排序</a></li><li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L69" target="_blank" rel="noopener">冒泡排序</a></li><li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L84" target="_blank" rel="noopener">快速排序</a></li><li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L131" target="_blank" rel="noopener">简单选择排序</a></li><li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L152" target="_blank" rel="noopener">堆排序</a></li><li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L237" target="_blank" rel="noopener">归并排序</a></li><li><a href="https://github.com/SkecisAI/python-sort/blob/master/my_sort.py#L278" target="_blank" rel="noopener">基数排序</a></li></ol><p>仅供参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;本文使用python实现了一些常用的排序方法。文章结构如下如下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#直接插入排序&quot;&gt;直接插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#希尔排序&quot;&gt;希尔排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#冒泡排序&quot;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#快速排序&quot;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#简单选择排序&quot;&gt;简单选择排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#堆排序&quot;&gt;堆排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#归并排序&quot;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#基数排序&quot;&gt;基数排序&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.skecis.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.skecis.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="http://www.skecis.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树(BST)</title>
    <link href="http://www.skecis.top/2019/11/18/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://www.skecis.top/2019/11/18/二叉查找树/</id>
    <published>2019-11-18T09:53:13.000Z</published>
    <updated>2019-11-22T05:43:44.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>二叉排序树又称为二叉查找树(Binary Sort Tree or Binary Search Tree, 简称BST)</strong>，或者是一颗空树，或者是具有下列性质的二叉树：</p><a id="more"></a><ol><li>若它的左子树不为空，则左子树上所有的节点的值均小于它的根节点的值。</li><li>若它的右子树不为空，则右子树上所有的节点的值均大于它的根节点的值。</li><li>它的左、右子树也分别为二叉排序树。</li></ol><p>如下例所示的二叉排序树：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/1.png" alt="二叉排序树"><br>根据上述定义的二叉排序树结构特点可见它的查找过程：当二叉排序树不为空时，首先将给定值和根节点的关键字比较，若相等，则查找成功，否则将依据给定值和根节点的关键字之间的大小关系，分别在左子树或右子树上继续进行查找。最后可见，<strong>二叉排序树的中序遍历结果即为从小到大的排序结果。</strong></p><h2 id="二叉排序树实现-python"><a href="#二叉排序树实现-python" class="headerlink" title="二叉排序树实现(python)"></a>二叉排序树实现(python)</h2><p>对给定的序列<code>list=[51, 12, 34, 5, 54, 89, 25, 11, 45, 67, 31, 22, 99, 79]</code>按顺序生成二叉排序树</p><h3 id="二叉树的节点"><a href="#二叉树的节点" class="headerlink" title="二叉树的节点"></a>二叉树的节点</h3><p>二叉树的节点分为三个部分：左子树指针域，数据域，右子树指针域。如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/1_1.png" alt="node"><br>用python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the node of tree</span></span><br><span class="line"><span class="string">        :param v: the value of node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.value = v</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>生成一个二叉排序树的算法如下：</p><blockquote><p>初始化：生成一个空树$Tree$，即根节点为空：$Tree.root=None$<br>输入：一个数据$v$<br>步骤：  </p><ol><li>判断根节点$Tree.root$是否为空。若是，则生成根节点$Tree.root=Node(v)$，否则执行步骤2。</li><li>另当前节点为$NowNode=Tree.root$。</li><li>判断$v$与当前节点值$NowNode.value$的大小，如果$v&gt;NowNode.value$，执行步骤4，否则执行步骤5.</li><li>判断当前节点的右子树$NowNode.right$是否为空，如果$NowNode.right=None$，则生成新节点$NewNode(v)$，执行步骤6，否则另$NowNode=NowNode.right$，执行步骤3。</li><li>判断当前节点的左子树$NowNode.left$是否为空，如果$NowNode.left=None$，则生成新节点$NewNode(v)$，执行步骤6，否则另$NowNode=NowNode.left$，执行步骤3。</li><li>结束</li></ol></blockquote><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>用python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, seq=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param seq: the optional parameter, to initialize the tree</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.insert(seq)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val_list)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        insert value into the tree</span></span><br><span class="line"><span class="string">        :param val_list: integer or list, the value waiting for inserting</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(val_list, list):</span><br><span class="line">            <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.root = Node(val_list.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> val_list:</span><br><span class="line">                self.__ins(v)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(val_list, int):</span><br><span class="line">            self.__ins(val_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ins</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        insert a value into the tree</span></span><br><span class="line"><span class="string">        :param v: interger</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_node = Node(v)</span><br><span class="line">        tmp = self.root</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> v &gt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.right:</span><br><span class="line">                    tmp = tmp.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.right = new_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> v &lt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.left:</span><br><span class="line">                    tmp = tmp.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.left = new_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        find the specific value</span></span><br><span class="line"><span class="string">        :param val:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.root</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> val == tmp.value:</span><br><span class="line">                print(<span class="string">"查找成功^_^"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> val &gt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.right:</span><br><span class="line">                    tmp = tmp.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"查找失败x_x"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> val &lt; tmp.value:</span><br><span class="line">                <span class="keyword">if</span> tmp.left:</span><br><span class="line">                    tmp = tmp.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"查找失败x_x"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        preorder traversal</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">            self.pre_order(node.left)</span><br><span class="line">            self.pre_order(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        inorder traversal</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.in_order(node.left)</span><br><span class="line">            print(node.value, end=<span class="string">' '</span>)</span><br><span class="line">            self.in_order(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        postorder traversal</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.post_order(node.left)</span><br><span class="line">            self.post_order(node.right)</span><br><span class="line">            print(node.value, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p>其中还包括了二叉排序树的<strong>遍历算法</strong>。<strong>其中中序遍历的结果即为排序结果</strong>。</p><h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h3><p>使用前面的列表<code>list</code>生成二叉排序树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    li = [<span class="number">51</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">54</span>, <span class="number">89</span>, <span class="number">25</span>, <span class="number">11</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">99</span>, <span class="number">79</span>]</span><br><span class="line">    my_tree = BST(li)</span><br><span class="line">    my_tree.in_order(my_tree.root)</span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    my_tree.insert([<span class="number">23</span>, <span class="number">1</span>])</span><br><span class="line">    my_tree.in_order(my_tree.root)</span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    my_tree.search(<span class="number">23</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 11 12 22 25 31 34 45 51 54 67 79 89 99 </span><br><span class="line">1 5 11 12 22 23 25 31 34 45 51 54 67 79 89 99 </span><br><span class="line">查找成功^_^</span><br></pre></td></tr></table></figure><p>生成的二叉排序树图示如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/2.png" alt="result"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉排序树&quot;&gt;&lt;a href=&quot;#二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树&quot;&gt;&lt;/a&gt;二叉排序树&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;二叉排序树又称为二叉查找树(Binary Sort Tree or Binary Search Tree, 简称BST)&lt;/strong&gt;，或者是一颗空树，或者是具有下列性质的二叉树：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.skecis.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.skecis.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉树" scheme="http://www.skecis.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>KNN算法-python实现</title>
    <link href="http://www.skecis.top/2019/11/18/knn%E7%AE%97%E6%B3%95/"/>
    <id>http://www.skecis.top/2019/11/18/knn算法/</id>
    <published>2019-11-18T07:47:21.000Z</published>
    <updated>2019-12-15T08:28:34.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k-近邻算法"><a href="#k-近邻算法" class="headerlink" title="$k$近邻算法"></a>$k$近邻算法</h2><p>$k$近邻(k-Nearest Neighbor, KNN)分类算法，是机器学习中最简单的算法之一。该算法的基本思路是：在一个未知的样本附近选取k个距离最短的已知样本（有类别标签），将这k个已知样本中数量最多的类别（标签）作为未知样本的类别（标签）。直观一点，如下图所示：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/knn%E7%AE%97%E6%B3%95/1.png" alt="knn示例"><br>可以看到上图选取了$k=5$个距离未知样本最近的已知样本，5个已知样本中有三个红色矩形和两个蓝色矩形，由算法的基本思路可知，未知样本应标记为<strong>红色</strong>。</p><a id="more"></a><h2 id="距离的度量"><a href="#距离的度量" class="headerlink" title="距离的度量"></a>距离的度量</h2><p>$x$和$y$分别为两个样本，$n$为特征总数。一般用到的是以下两种距离：</p><ul><li><strong>欧式距离</strong>：<script type="math/tex; mode=display">d\left ( x,y \right )=\sqrt{\sum_{k=1}^{n}\left ( x_{k}-y_{k} \right )^{2}}</script></li><li><strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">d\left ( x,y \right )=\sqrt{\sum_{k=1}^{n}\left | x_{k}-y_{k} \right |}</script></li></ul><p>无论用那种距离，目的都是为了刻画已知样本和未知样本的<strong>相似度</strong>，从而描述预知样本的特征。</p><h2 id="用python实现算法"><a href="#用python实现算法" class="headerlink" title="用python实现算法"></a>用python实现算法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><blockquote><p>初始化：已知类别标签的样本集$X_{n}$和最多近邻数$k$，<br>输入：未知样本$x$<br>步骤：</p><ol><li>对于每个样本集中的样本$X_{i}$和未知样本$x$计算距离$d_{i}$。得到距离集$D_{n}$。</li><li>将距离集$D_{n}$中的数从小到大排序，选择前$k$个距离数据。</li><li>根据步骤2的$k$距离数据中的样本下标，得到对应的类别标签集$C_{k}$</li><li>选择$C_{k}$中数量最多的类别标签$c_{max}$作为未知样本$x$的类别标签$c$</li></ol></blockquote><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><p>python实现knn算法的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the k of KNN</span></span><br><span class="line"><span class="string">        :param k: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.samples_nums = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, x_train, y_train, test)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        predict the categorie of test sample</span></span><br><span class="line"><span class="string">        :param x_train: the set of train sample</span></span><br><span class="line"><span class="string">        :param y_train: the label set of train sample</span></span><br><span class="line"><span class="string">        :param test: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x_train = np.array(x_train)</span><br><span class="line">        self.samples_nums = x_train.shape[<span class="number">0</span>]</span><br><span class="line">        y_train = np.array(y_train)</span><br><span class="line">        sorted_k_v = self.__cal_dist(x_train, test)</span><br><span class="line">        lab_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind <span class="keyword">in</span> range(self.k):</span><br><span class="line">            s = sorted_k_v[ind]</span><br><span class="line">            <span class="keyword">if</span> y_train[s[<span class="number">0</span>]] <span class="keyword">not</span> <span class="keyword">in</span> lab_dict.keys():</span><br><span class="line">                lab_dict[y_train[s[<span class="number">0</span>]]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lab_dict[y_train[s[<span class="number">0</span>]]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(lab_dict, key=lab_dict.get)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cal_dist</span><span class="params">(self, x_train, x_test)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        calculate the distance between train set and test sample</span></span><br><span class="line"><span class="string">        :param x_train: </span></span><br><span class="line"><span class="string">        :param x_test: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind <span class="keyword">in</span> range(self.samples_nums):</span><br><span class="line">            d[ind] = np.sqrt(sum(np.power(x_train[ind, :] - x_test, <span class="number">2</span>)))</span><br><span class="line">        sort_list = sorted(d.items(), key=<span class="keyword">lambda</span> itm: itm[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> sort_list</span><br></pre></td></tr></table></figure><p>测试案例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    my_knn = KNN(<span class="number">3</span>)</span><br><span class="line">    x = [[<span class="number">0.1</span>, <span class="number">0.2</span>], [<span class="number">-1.5</span>, <span class="number">-1.1</span>], [<span class="number">0.7</span>, <span class="number">1.9</span>], [<span class="number">-0.3</span>, <span class="number">1.0</span>]]</span><br><span class="line">    y = [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>]</span><br><span class="line">    print(my_knn.predict(x, y, [<span class="number">1</span>, <span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>输出：<code>b</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;k-近邻算法&quot;&gt;&lt;a href=&quot;#k-近邻算法&quot; class=&quot;headerlink&quot; title=&quot;$k$近邻算法&quot;&gt;&lt;/a&gt;$k$近邻算法&lt;/h2&gt;&lt;p&gt;$k$近邻(k-Nearest Neighbor, KNN)分类算法，是机器学习中最简单的算法之一。该算法的基本思路是：在一个未知的样本附近选取k个距离最短的已知样本（有类别标签），将这k个已知样本中数量最多的类别（标签）作为未知样本的类别（标签）。直观一点，如下图所示：&lt;br&gt;&lt;img src=&quot;https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/knn%E7%AE%97%E6%B3%95/1.png&quot; alt=&quot;knn示例&quot;&gt;&lt;br&gt;可以看到上图选取了$k=5$个距离未知样本最近的已知样本，5个已知样本中有三个红色矩形和两个蓝色矩形，由算法的基本思路可知，未知样本应标记为&lt;strong&gt;红色&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.skecis.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://www.skecis.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="机器学习" scheme="http://www.skecis.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--哈希表</title>
    <link href="http://www.skecis.top/2019/11/14/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://www.skecis.top/2019/11/14/哈希表/</id>
    <published>2019-11-14T01:45:14.000Z</published>
    <updated>2019-12-15T08:34:21.383Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍哈希表之前，先介绍一下<strong>查找表</strong></p><h2 id="查找表-Search-Table"><a href="#查找表-Search-Table" class="headerlink" title="查找表(Search Table)"></a>查找表(Search Table)</h2><blockquote><p>查找表是由同一类型的数据元素(或记录)构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵活的数据结构</p></blockquote><a id="more"></a><h3 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h3><ol><li>查询某个“特定的”的数据元素是否在查找表中。</li><li>检索某个“特定的”数据元素的各种属性。</li><li>在查找表中插入一个数据元素</li><li>从查找表中删去某个元素。</li></ol><p>查找表根据其操作的不同又分为以下两种：</p><ul><li>若对查找表只作前两种统称为“查找”的操作，则称此类查找表为<strong>静态查找表(Static Search Table)</strong>。</li><li>若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素，则称此类表为<strong>动态查找表(Dynamic Search Table)</strong></li></ul><h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><p>为了解释“特定的”，引入了<strong>关键字</strong>:</p><blockquote><p>关键字是数据元素(或记录)中某个数据项的值，用它可以标识一个数据元素(或记录)。</p></blockquote><p>接着定义<strong>查找</strong>:</p><blockquote><p>根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。</p></blockquote><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>查找的效率依赖于查找过程中所进行的比较次数。</p><h3 id="哈希-Hash-函数"><a href="#哈希-Hash-函数" class="headerlink" title="哈希(Hash)函数"></a>哈希(Hash)函数</h3><blockquote><p>理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个对应关系$f$，使每个关键字和结构中一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系$f$找到给定值$K$的像$f\left ( K \right )$。<strong>若结构中存在关键字和$K$相等的记录，则必定在$f\left ( K \right )$的存储位置上</strong>，由此，不需要进行比较便可直接取得所查记录。在此，我们称这个对应关系$f$为<strong>哈希函数</strong>，按这个思想建立的表为<strong>哈希表</strong>。</p></blockquote><h3 id="哈希函数的特征"><a href="#哈希函数的特征" class="headerlink" title="哈希函数的特征"></a>哈希函数的特征</h3><ol><li>哈希函数是一个映像，因此哈希函数的设定很灵活，只要是的任何关键字由此所得的哈希函数值都落在表长允许的范围内即可。</li><li>对不同的关键字可能得到同一哈希地址，即$key_{1}\neq key_{2}$，而$f\left ( key_{1} \right )= f\left ( key_{2} \right )$，这种现象称为<strong>冲突(collision)</strong>。</li></ol><h3 id="哈希表定义"><a href="#哈希表定义" class="headerlink" title="哈希表定义"></a>哈希表定义</h3><p>综上，可如下描述哈希表：</p><blockquote><p>根据设定的哈希函数$H\left ( key \right )$和处理冲突的方法将一组关键字映像到一个有限的连续的地址集上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为<strong>哈希表</strong>，这一映像过程称为哈希造表或<strong>散列</strong>，所得存储位置称<strong>哈希地址</strong>或<strong>散列地址</strong>。</p></blockquote><h2 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h2><p>若对于关键字集合中的任一个关键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称此类哈希函数为<strong>均匀的(Uniform)</strong>哈希函数。换句话说，就是使关键字经过哈希函数得到一个“随机的地址”，以便使一组关键字的哈希地址<strong>均匀分布</strong>在整个地址区间中，从而减少<strong>冲突</strong></p><ul><li><strong>直接定址法</strong>：取关键字或关键字的某个线性函数值作为哈希地址。即：</li></ul><script type="math/tex; mode=display">H\left ( key \right )= key</script><script type="math/tex; mode=display">H\left ( key \right )= a\cdot key+b</script><ul><li><strong>数字分析法</strong>：假设关键字是以$r$为基的数(如：以10为基的十进制数)，并且哈希表中可能出现的关键字都是事先知道的，则可以取关键字的若干数位组成哈希地址。</li><li><strong>平方取中法</strong>：取关键字平方后的中间几位为哈希地址。</li><li><strong>折叠法</strong>：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为哈希地址。</li><li><strong>除留余数法</strong>：取关键字被某个不大于哈希表表长$m$的数$p$除后所得的余数为哈希地址。即:</li></ul><script type="math/tex; mode=display">H\left ( key \right )= key\left ( MOD \right )p, p\leq m</script><h2 id="处理冲突-collision"><a href="#处理冲突-collision" class="headerlink" title="处理冲突(collision)"></a>处理冲突(collision)</h2><p>上文提到的均匀的哈希函数可以减少冲突，但不能避免，因此如何处理冲突时哈希造表不可缺少的另一方面。通常用的处理方法如下：</p><ul><li><strong>开放地址法</strong><script type="math/tex; mode=display">H_{i}=\left ( H\left ( key \right )+d_{i} \right )MOD\left ( m \right ),i=1,2,...,k\left ( k\leq m-1 \right )</script>其中：$H\left ( key \right )$为哈希函数；$m$为哈希表表长；$d_{i}$为增量序列，有下列三种取法：<ol><li>$d_{i}=1,2,3,…,m-1$称线性探测再散列；</li><li>$d_{i}=1^{2},-1^{2},2^{2},-2^{2},3^{2},…,\pm k^{2},\left (k\leq m/2 \right)$称二次探测再散列；</li><li>$d_{i}=伪随机数序列$，称伪随机探测再散列。</li></ol></li><li><strong>再哈希法</strong><script type="math/tex; mode=display">H_{i}=RH_{i}\left (key \right), i=1,2,...,k</script>$RH_{i}$均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不在发生。这种方法不易产生“聚集”，但增加了计算的时间。</li><li><strong>链地址法</strong><br>将所有关键字为同义词的记录存储在同一线性链表中。假设某哈希函数产生的哈希地址在区间$\left [ 0,m-1 \right ]$上，则设立一个指针型向量<script type="math/tex; mode=display">ChainHash\left [m \right]</script>其每个分量的初始状态都是空指针。凡哈希地址为$i$的记录都插入到头指针为$ChainHash\left [i \right]$的链表中。在链表中的插入位置可以在表头或表尾；也可在中间，以保持同义词在同一线性链表中按关键字有序。</li><li><strong>建立公共溢出区</strong><br>假设哈希函数的值域为$\left [0,m-1 \right]$，则设向量$HashTable\left [0..m-1 \right]$为基本表，每个分量存放一个记录，另设立向量$OverTable\left [0..v \right]$为溢出表。所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</li></ul><h2 id="哈希表应用算法案例"><a href="#哈希表应用算法案例" class="headerlink" title="哈希表应用算法案例"></a>哈希表应用算法案例</h2><h3 id="两数之和-2-Sum"><a href="#两数之和-2-Sum" class="headerlink" title="两数之和(2 Sum)"></a>两数之和(2 Sum)</h3><p><strong>问题描述</strong>：</p><blockquote><p>输入一个数组<code>nums</code>和一个数<code>target</code>，返回数组<code>nums</code>中两个数的和为<code>target</code>的这两个数的下标(index),下标从1开始。例子：<br><code>nums = [2, 7, 11, 15]</code>, <code>target = [9]</code><br>返回<code>[1, 2]</code></p></blockquote><p><strong>问题分析</strong>：<br>有两个输入：<code>nums</code>和<code>target</code>，一个输出：<code>两个下标</code>，目的是找到两个数之和等于<code>target</code>。显而易见的一种方法是写两个for循环嵌套：外部循环从数组的第一个元素开始向后遍历作为第一个数<code>nums[i]</code>，内部循环从第一个数的下一个数<code>nums[i+1]</code>开始向后遍历，判断两个数之和是否等于<code>target</code>，找到后返回两个下标即可。不过这样做有明显的缺点：两个循环的算法时间复杂度为$O\left (n*(n-1)\right)$，那么如果<code>nums</code>中有9个元素，最多会遍历9x8=72次，对于更大的<code>nums</code>遍历次数将更多。所以我们来“算算”怎么简化算法。</p><p><strong>解决方案</strong>：<br>我们设找到的两个数中第一个为$x_{i}$，第二个数为$x_{j}$，进行运算：</p><script type="math/tex; mode=display">x_{i}+x_{j}=target\tag{1}</script><script type="math/tex; mode=display">x_{j}=target-x_{i}\tag{2}</script><p>进行上述的运算后可以发现等式(1)中的左边部分有两个未知数，而等式右边只有一个未知数，于是我们可以得到一个下标$i$到$j$的映射：$f\left (i\right)=j$，从而我们可以利用等式(2)来重新构造我们的for循环，即使用一次for循环。<br><strong>程序实现</strong>：<br>用python来实现这个算法，其中python中的字典可以作为很好的哈希映射。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_num</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    solve the problem 2 sum</span></span><br><span class="line"><span class="string">    :param nums: the set of some numbers</span></span><br><span class="line"><span class="string">    :param target: the sum of two numbers</span></span><br><span class="line"><span class="string">    :return: the index of two numbers</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    hash_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ind, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> (target - val) <span class="keyword">in</span> hash_map:</span><br><span class="line">            <span class="keyword">return</span> hash_map[target - val]+<span class="number">1</span>, ind+<span class="number">1</span></span><br><span class="line">        hash_map[val] = ind</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans = two_num([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], <span class="number">9</span>)</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><p>输出：<code>(1, 2)</code><br><strong>代码分析</strong>：<br>分析代码可知，首先创建一个空的字典，该字典用来实现哈希映射，接着我们对数组的每一个元素进行迭代，获取元素的下标和元素值，接着进行判断：如果另一个元素在字典中，则返回另一个元素在字典中的值和当前元素的下标。<br>否则，更新字典，把元素作为字典的键（这样就不必担心重复的元素），把元素的下标作为值，然后继续循环。回过头来可以发现我们最终返回的就是两个数的下标值。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>由上述案例可知哈希思想作为数据结构的应用带来的算法效能提升，在平时的算法编写中应考虑到时间和空间上的条件，利用数据结构的知识来不断优化算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在介绍哈希表之前，先介绍一下&lt;strong&gt;查找表&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;查找表-Search-Table&quot;&gt;&lt;a href=&quot;#查找表-Search-Table&quot; class=&quot;headerlink&quot; title=&quot;查找表(Search Table)&quot;&gt;&lt;/a&gt;查找表(Search Table)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;查找表是由同一类型的数据元素(或记录)构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵活的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.skecis.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Python" scheme="http://www.skecis.top/tags/Python/"/>
    
      <category term="数据结构" scheme="http://www.skecis.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="http://www.skecis.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>操作系统:存储管理算法(python实现)</title>
    <link href="http://www.skecis.top/2019/11/10/memory-alloc/"/>
    <id>http://www.skecis.top/2019/11/10/memory-alloc/</id>
    <published>2019-11-10T11:07:19.000Z</published>
    <updated>2019-12-15T08:29:23.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>该分配方式为用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址<strong>相邻</strong>，体现在内存空间分配是物理地址的<strong>相邻</strong>。连续分配方式可分为四类：</p><a id="more"></a><ul><li>单一连续分配</li><li>固定分区分配</li><li><strong>动态分区分配</strong></li><li>动态可重定向分配</li></ul><p>本文仅重点介绍<strong>动态分区分配算法</strong></p><h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>动态分区分配又称为可变分区分配，它是根据进程的实际需要，动态地为之分配内存空间。</p><h3 id="动态分区分配中的数据结构"><a href="#动态分区分配中的数据结构" class="headerlink" title="动态分区分配中的数据结构"></a>动态分区分配中的数据结构</h3><p>为了实现动态分区分配，系统中必须配置相应的数据结构，用以描述空闲分区和已分配分区的情况，为分配提供依据。常用的数据结构有以下两种形式：</p><ol><li>空闲分区表。在系统中设置一张空闲分区表，用于记录每个空闲的情况。每个空闲分区占一个表目(行)，表目中包括分区号、分区大小和分区始址等数据项，如下图所示<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_1.png" alt="空闲分区表"></li><li><strong>空闲分区链</strong>。为了实现对空闲分区的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接空闲分区的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。为了检索方便，在分区尾部重复设置状态位和分区大小表目。当分区被分配出去以后，把状态位由“0”改为“1”，此时，前、后向指针已无意义。如下图所示<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_2.png" alt="空闲分区链"></li></ol><p>本文主要针对空闲分区链编写python代码</p><h3 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h3><p>在动态分区存储管理方式中，主要的操作是分配内存和回收内存</p><ul><li>分配内存：系统利用某种<strong>分配算法</strong>，从空闲分区链中找到所需大小的分区。设请求的分区大小为apply.size，表中每个空闲分区的大小表示为part.size。若part.size - apply.size &lt;= min_size(min_size是事先规定的最小剩余)，说明多余的部分太小，可不分割，将整个分区分配个请求者。否则(即多余的部分超过min_size)，说明剩下了很多，便可从该分区中按请求的大小划分出一块内存空间出去，余下的部分仍留在空闲分区链(表)中。最后将分配区的 <strong>首址(address)</strong> 返回给调用者。流程如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_3.png" alt="分配内存"></li><li>回收内存：当进程运行完毕释放内存时，系统根据回收区的首址，从空闲链(表)中找到相应的插入点，此时可能出现以下四种情况之一：<ol><li>回收区与插入点前一个空闲分区$F_{1}$相邻接。此时应将回收区与$F_{1}$合并。<strong>不必创建新表项</strong>，只需修改其前一分区$F_{1}$的大小。</li><li>回收分区与插入点的后一空闲分区$F_{2}$相邻接。此时也将两分区合并。<strong>但回收区的首址作为新空闲区的首址</strong>。</li><li>回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，<strong>使用前一个分区的表项和首址，取消后一个分区的表项</strong>。</li><li>回收区既与前后两个分区都不邻接。<strong>此时为回收区单独建立一个新表项</strong>，首址和大小分别为回收区的首址和大小。<br>内存回收的流程如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1_4.png" alt="回收内存"></li></ol></li></ul><h2 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h2><p>为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。所谓顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。基于顺序搜索的动态分区分配算法有如下四种（以下算法讲解皆是基于空闲分区链）：</p><ul><li><strong>首次适应(first fit, FF)算法</strong>：FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。</li><li>循环首次适应(next fit, NF)算法：NF算法不再是每次都从链首开始查找，而是从上一次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区。</li><li>最佳适应(best fit, BF)算法：BF算法要求每次为作业分配内存时，总是把能满足要求、又是最小的空间分区分配给作业。同时，为了加速寻找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。</li><li>最坏适应(worst fit, WF)算法：WF算法与BF算法相反：它在扫描整个空闲分区链时，总是挑选出一个最大的空闲区，以至于存储器中缺乏大的空闲分区</li></ul><h3 id="首次适应算法实现"><a href="#首次适应算法实现" class="headerlink" title="首次适应算法实现"></a>首次适应算法实现</h3><p>分析操作系统的内存管理流程后大致可把算法分为以下几个步骤：</p><ul><li>初始化空闲分区链</li><li>发出内存请求</li><li>使用算法(FF)分配内存</li><li>回收内存</li></ul><p>用python实现该算法代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionNode</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    a node of idle partition chain</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, loc)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize the node</span></span><br><span class="line"><span class="string">        :param size: the size of this partition</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.prior = <span class="literal">None</span>  <span class="comment"># the prior of this partition</span></span><br><span class="line">        self.part_size = size</span><br><span class="line">        self.loc = loc     <span class="comment"># the begin location of this partition</span></span><br><span class="line">        self.status = <span class="number">0</span>    <span class="comment"># the distribution status of this partition</span></span><br><span class="line">        self.next = <span class="literal">None</span>   <span class="comment"># the next of this partition</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionChain</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize a free partition chain</span></span><br><span class="line"><span class="string">        :param num:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.partition_chain = PartitionNode(np.random.randint(<span class="number">50</span>, <span class="number">151</span>), <span class="number">0</span>)  <span class="comment"># create the head node</span></span><br><span class="line">        self.num = num  <span class="comment"># the number of the partition</span></span><br><span class="line">        self.size = self.partition_chain.part_size</span><br><span class="line">        self.free = <span class="number">0</span>   <span class="comment"># the free space of the partition</span></span><br><span class="line">        self.__init_chain()  <span class="comment"># initialize the partition chain</span></span><br><span class="line">        self.min_remain = <span class="number">25</span>  <span class="comment"># the minimum size of split</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_chain</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize the partition charin</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> range(<span class="number">1</span>, self.num):</span><br><span class="line">            tmp.next = PartitionNode(np.random.randint(<span class="number">50</span>, <span class="number">151</span>), self.size)  <span class="comment"># create the next node</span></span><br><span class="line">            self.size += tmp.next.part_size</span><br><span class="line">            tmp.next.prior = tmp  <span class="comment"># point to the prior node</span></span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        self.free = self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_chain</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        print the infomation of partition chain</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        self.free = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            self.free += tmp.part_size</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        print(<span class="string">"空闲分区链(分区数-%d 大小-%d 空闲-%d):"</span> % (self.num, self.size, self.free), end=<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> tmp.next:</span><br><span class="line">                print(<span class="string">"&lt;AT-%d, S-%d&gt;"</span> % (tmp.loc, tmp.part_size), end=<span class="string">'···'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"&lt;AT-%d, S-%d&gt;"</span> % (tmp.loc, tmp.part_size))</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alloc_memory</span><span class="params">(self, method, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        the algorithm of allocate memory</span></span><br><span class="line"><span class="string">        :param method: first fit, next fit, best fit, worst fit</span></span><br><span class="line"><span class="string">        :param m: the memory of application</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">'**需求**:'</span>, m)</span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">'first'</span>:</span><br><span class="line">            tmp = self.partition_chain</span><br><span class="line">            <span class="keyword">while</span> tmp:</span><br><span class="line">                <span class="keyword">if</span> m &lt;= tmp.part_size <span class="keyword">and</span> tmp.status == <span class="number">0</span>:  <span class="comment"># 按顺序找到第一个能满足要求的空闲分区</span></span><br><span class="line">                    <span class="keyword">if</span> tmp.part_size - m &lt;= self.min_remain:  <span class="comment"># 划分后剩余的大小过小，则分出整个分区，并调整分区链结构</span></span><br><span class="line">                        self.num -= <span class="number">1</span>  <span class="comment"># 长度减一</span></span><br><span class="line">                        <span class="keyword">if</span> tmp.prior <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 如果是表头</span></span><br><span class="line">                            self.partition_chain = tmp.next</span><br><span class="line">                            self.partition_chain.prior = <span class="literal">None</span></span><br><span class="line">                        <span class="keyword">elif</span> tmp.next <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果是表尾</span></span><br><span class="line">                            tmp.prior.next = <span class="literal">None</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            tmp.next.prior = tmp.prior</span><br><span class="line">                            tmp.prior.next = tmp.next</span><br><span class="line">                        print(<span class="string">"**Info**: 分配成功^_^, 地址-%d 大小-%d"</span> % (tmp.loc, tmp.part_size))</span><br><span class="line">                        <span class="keyword">return</span> &#123;<span class="string">'Address'</span>: tmp.loc, <span class="string">'Size'</span>: tmp.part_size&#125;</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tmp.part_size -= m</span><br><span class="line">                        print(<span class="string">"**Info**: 分配成功^_^, 地址-%d 大小-%d"</span> % (tmp.loc, m))</span><br><span class="line">                        <span class="keyword">return</span> &#123;<span class="string">'Address'</span>: tmp.loc, <span class="string">'Size'</span>: m&#125;  <span class="comment"># 返回分配区的首地址</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp = tmp.next</span><br><span class="line">            print(<span class="string">'**Info**: 分配失败x_x'</span>)</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">'next'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">'best'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">'fit'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dealloc_memory</span><span class="params">(self, m_dict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        recycle the memeory</span></span><br><span class="line"><span class="string">        :param m_dict: the dict of deallocated memory</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"**Info**: 回收失败x_x"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        loc = m_dict.get(<span class="string">'Address'</span>)</span><br><span class="line">        size = m_dict.get(<span class="string">'Size'</span>)</span><br><span class="line">        tmp = self.partition_chain</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="keyword">if</span> tmp.prior <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 表头分区</span></span><br><span class="line">                <span class="keyword">if</span> loc &lt;= tmp.loc:</span><br><span class="line">                    <span class="keyword">if</span> loc == tmp.loc:  <span class="comment"># 同一分区</span></span><br><span class="line">                        tmp.part_size += size</span><br><span class="line">                    <span class="keyword">else</span>:  <span class="comment"># 与表头分区不邻接，自己作为表头分区</span></span><br><span class="line">                        new_part = PartitionNode(size, loc)</span><br><span class="line">                        new_part.next = tmp</span><br><span class="line">                        tmp.prior = new_part</span><br><span class="line">                        self.partition_chain = new_part</span><br><span class="line">                        self.num += <span class="number">1</span></span><br><span class="line">                    print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> (tmp.next <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">and</span> (loc &gt;= tmp.loc):  <span class="comment"># 表尾分区, 且在表尾之后</span></span><br><span class="line">                <span class="keyword">if</span> tmp.loc == loc:  <span class="comment"># 与表尾分区邻接，表尾分区在前</span></span><br><span class="line">                    tmp.part_size += size</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 与表尾分区不邻接，自己作为表尾分区</span></span><br><span class="line">                    new_part = PartitionNode(size, loc)</span><br><span class="line">                    tmp.next = new_part</span><br><span class="line">                    new_part.prior = tmp</span><br><span class="line">                    self.num += <span class="number">1</span></span><br><span class="line">                print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 表中分区，前后皆有分区存在</span></span><br><span class="line">                <span class="keyword">if</span> loc &lt;= tmp.loc:</span><br><span class="line">                    <span class="keyword">if</span> ((loc + size) == tmp.loc) | (loc == tmp.loc):</span><br><span class="line">                        <span class="keyword">if</span> loc == tmp.loc:  <span class="comment"># 同一分区</span></span><br><span class="line">                            tmp.part_size += size</span><br><span class="line">                        <span class="keyword">elif</span> (tmp.prior.loc + tmp.prior.part_size) == loc:  <span class="comment"># 1.同时与前面和后面的分区邻接</span></span><br><span class="line">                            next_part = tmp.next</span><br><span class="line">                            <span class="keyword">if</span> next_part:  <span class="comment"># 如果是不是表尾分区</span></span><br><span class="line">                                next_part.prior = tmp.prior</span><br><span class="line">                            tmp.prior.part_size += size + tmp.part_size</span><br><span class="line">                            tmp.prior.next = next_part</span><br><span class="line">                        <span class="keyword">else</span>:  <span class="comment"># 2.只与后面的分区邻接</span></span><br><span class="line">                            tmp.part_size += size</span><br><span class="line">                        print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> loc == tmp.prior.loc:</span><br><span class="line">                            tmp.prior.part_size += size</span><br><span class="line">                        <span class="keyword">elif</span> (tmp.prior.loc + tmp.prior.part_size) == loc:  <span class="comment"># 3.只与前面的分区邻接</span></span><br><span class="line">                            tmp.prior.part_size += size</span><br><span class="line">                        <span class="keyword">else</span>:  <span class="comment"># 4.与前面和后面的都不邻接</span></span><br><span class="line">                            new_part = PartitionNode(size, loc)</span><br><span class="line">                            new_part.next = tmp</span><br><span class="line">                            new_part.prior = tmp.prior</span><br><span class="line">                            tmp.prior.next = new_part</span><br><span class="line">                            tmp.prior = new_part</span><br><span class="line">                            self.num += <span class="number">1</span></span><br><span class="line">                        print(<span class="string">"**Info**: 大小:%d 回收成功^_^"</span> % size)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    my_chain = PartitionChain(<span class="number">5</span>)</span><br><span class="line">    my_chain.print_chain()</span><br><span class="line">    my_apply = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 请求内存</span></span><br><span class="line">        rnd = np.random.randint(<span class="number">80</span>, <span class="number">130</span>)</span><br><span class="line">        my_apply.append(my_chain.alloc_memory(<span class="string">'first'</span>, rnd))</span><br><span class="line">    my_chain.print_chain()</span><br><span class="line">    print(<span class="string">'已经请求的分区:'</span>, my_apply)</span><br><span class="line">    <span class="keyword">for</span> applys <span class="keyword">in</span> my_apply:</span><br><span class="line">        my_chain.dealloc_memory(applys)</span><br><span class="line">    my_chain.print_chain()</span><br></pre></td></tr></table></figure><p>运行示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">空闲分区链(分区数-5 大小-484 空闲-484): &lt;AT-0, S-126&gt;···&lt;AT-126, S-132&gt;···&lt;AT-258, S-50&gt;···&lt;AT-308, S-68&gt;···&lt;AT-376, S-108&gt;</span><br><span class="line">**需求**: 118</span><br><span class="line">**Info**: 分配成功^_^, 地址-0 大小-126</span><br><span class="line">**需求**: 86</span><br><span class="line">**Info**: 分配成功^_^, 地址-126 大小-86</span><br><span class="line">**需求**: 82</span><br><span class="line">**Info**: 分配成功^_^, 地址-376 大小-82</span><br><span class="line">空闲分区链(分区数-4 大小-484 空闲-190): &lt;AT-126, S-46&gt;···&lt;AT-258, S-50&gt;···&lt;AT-308, S-68&gt;···&lt;AT-376, S-26&gt;</span><br><span class="line">已经请求的分区: [&#123;&apos;Address&apos;: 0, &apos;Size&apos;: 126&#125;, &#123;&apos;Address&apos;: 126, &apos;Size&apos;: 86&#125;, &#123;&apos;Address&apos;: 376, &apos;Size&apos;: 82&#125;]</span><br><span class="line">**Info**: 大小:126 回收成功^_^</span><br><span class="line">**Info**: 大小:86 回收成功^_^</span><br><span class="line">**Info**: 大小:82 回收成功^_^</span><br><span class="line">空闲分区链(分区数-5 大小-484 空闲-484): &lt;AT-0, S-126&gt;···&lt;AT-126, S-132&gt;···&lt;AT-258, S-50&gt;···&lt;AT-308, S-68&gt;···&lt;AT-376, S-108&gt;</span><br></pre></td></tr></table></figure><p>如有不当指出，请多多指教。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;连续分配存储管理方式&quot;&gt;&lt;a href=&quot;#连续分配存储管理方式&quot; class=&quot;headerlink&quot; title=&quot;连续分配存储管理方式&quot;&gt;&lt;/a&gt;连续分配存储管理方式&lt;/h2&gt;&lt;p&gt;该分配方式为用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址&lt;strong&gt;相邻&lt;/strong&gt;，体现在内存空间分配是物理地址的&lt;strong&gt;相邻&lt;/strong&gt;。连续分配方式可分为四类：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.skecis.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Python" scheme="http://www.skecis.top/tags/Python/"/>
    
      <category term="算法" scheme="http://www.skecis.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="内存分配" scheme="http://www.skecis.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>银行家算法(java实现)</title>
    <link href="http://www.skecis.top/2019/11/08/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://www.skecis.top/2019/11/08/银行家算法/</id>
    <published>2019-11-08T06:45:02.000Z</published>
    <updated>2019-11-10T14:10:08.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>银行家算法是一种避免进程发生<strong>死锁</strong>的算法。</p><blockquote><p>死锁的定义：<br>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么改组进程是死锁的(Deadlock)<br>在死锁避免方法中，把系统的状态分为<strong>安全状态</strong>和<strong>不安全状态</strong>。<br>安全状态和不安全状态：<br>是指系统能按某种进程推进顺序<script type="math/tex">\left ( P_{1},P_{2}, ...,P_{n}\right )</script> 为每个进程<script type="math/tex">P_{i}</script>分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。并称<script type="math/tex">\left ( P_{1},P_{2}, ...,P_{n}\right )</script>为安全序列。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p></blockquote><a id="more"></a><h2 id="银行家算法中的数据结构"><a href="#银行家算法中的数据结构" class="headerlink" title="银行家算法中的数据结构"></a>银行家算法中的数据结构</h2><p>银行家算法中有四个数据结构：</p><ul><li>最大需求向量(Max)：是一个长度为m的数组，它定义了系统中每个进程对第m类资源的最大需求</li><li>已分配向量(Allocation)：是一个长度为m的数组，它定义了系统中每个进程对每一类资源分配给进程的资源数量。</li><li>需求向量(Need)：是一个长度为m的数组，用以表示进程还需要的各类资源数量</li><li>可利用资源向量(Available)：是一个长度为m的数组，其中每一个值代表可以当前可利用的资源数目。</li></ul><p>上述数据中有这样的关系：Need = Max - Allocation</p><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>史上最详细的步骤^_^</p><ul><li>【步骤一】创建进程数组PCB[n] (代表n个进程)</li><li>【步骤二】输入并初始化每个进程PCB[i]的Max数组、Allocation数组</li><li>【步骤三】利用Max数组和Allocation数组计算出Need数组</li><li>【步骤四】输入Available数组</li><li>【步骤五】为每个PCB添加完成状态变量Finish(0-未完成，1-完成)，得到Finish数组(全部初始化为0)</li><li>【步骤六】初始化表示安全状态变量Safe_Status = 0(0-不安全，1-安全)</li><li>【步骤七】循环进行资源分配：</li><li>WHILE(SUM(Finish) &lt; n):</li><li>Safe_Status = 0</li><li>FOR i =  1 TO n</li><li>IF PCB[i]中Need的每个值 &lt;= Avaliable的每个值 AND PCB[i].Finish == 0</li><li>PCB[i].Finish = 1</li><li>将该进程PCB[i]加入安全序列队列</li><li>Available = Available + PCB[i].Need</li><li>Safe_Status = 1</li><li>END IF</li><li>END FOR</li><li>IF Safe_Status == 0</li><li>BREAK</li><li>END IF</li><li>END WHILE</li><li>【步骤八】判断系统是否安全：</li><li>IF (SUM(Finish == n))</li><li>该系统安全</li><li>END IF</li><li>【步骤九】输出安全序列队列</li></ul><h2 id="用Java实现银行家算法"><a href="#用Java实现银行家算法" class="headerlink" title="用Java实现银行家算法"></a>用Java实现银行家算法</h2><h3 id="Proc-java"><a href="#Proc-java" class="headerlink" title="Proc.java"></a>Proc.java</h3><p>表示进程信息的进程类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proc</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> name;</span><br><span class="line"><span class="keyword">int</span> max_res[];</span><br><span class="line"><span class="keyword">int</span> alloc_res[];</span><br><span class="line"><span class="keyword">int</span> need_res[];</span><br><span class="line"><span class="keyword">boolean</span> finish_status = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Proc</span><span class="params">(<span class="keyword">char</span> name , <span class="keyword">int</span> max[], <span class="keyword">int</span> alloc[], <span class="keyword">int</span> need[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.max_res = max;</span><br><span class="line"><span class="keyword">this</span>.alloc_res = alloc;</span><br><span class="line"><span class="keyword">this</span>.need_res = need;</span><br><span class="line"><span class="keyword">this</span>.finish_status = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMax_res</span><span class="params">(<span class="keyword">int</span> max_res[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.max_res = max_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getMax_res() &#123;</span><br><span class="line"><span class="keyword">return</span> max_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlloc_res</span><span class="params">(<span class="keyword">int</span> alloc_res[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.alloc_res = alloc_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getAlloc_res() &#123;</span><br><span class="line"><span class="keyword">return</span> alloc_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNeed_res</span><span class="params">(<span class="keyword">int</span> need_res[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.need_res = need_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNeed_res() &#123;</span><br><span class="line"><span class="keyword">return</span> need_res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BankRR-java"><a href="#BankRR-java" class="headerlink" title="BankRR.java"></a>BankRR.java</h3><p>银行家算法和程序入口所在的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankRR</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pcb_nums;  <span class="comment">// 进程数量</span></span><br><span class="line"><span class="keyword">int</span> res_nums;  <span class="comment">// 资源种类数量</span></span><br><span class="line">Proc pcbs[];   <span class="comment">// 进程数组</span></span><br><span class="line"><span class="keyword">int</span> max[];     <span class="comment">// 最大需求资源向量</span></span><br><span class="line"><span class="keyword">int</span> alloc[];   <span class="comment">// 拥有资源数向量</span></span><br><span class="line"><span class="keyword">int</span> need[];    <span class="comment">// 还需要资源数向量</span></span><br><span class="line"><span class="keyword">int</span> ava[];     <span class="comment">// 可用资源数向量</span></span><br><span class="line"><span class="keyword">char</span> safe_seq[];  <span class="comment">// 安全序列数组</span></span><br><span class="line"><span class="keyword">boolean</span> safe_stauts = <span class="keyword">false</span>;  <span class="comment">// 安全序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bank_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// A sample</span></span><br><span class="line"><span class="comment">/*   Max   Alloc  Need   Avai</span></span><br><span class="line"><span class="comment"> - a 7 5 3, 0 1 0, 7 4 3, 3 3 2</span></span><br><span class="line"><span class="comment"> - b 3 2 2, 2 0 0, 1 2 2</span></span><br><span class="line"><span class="comment"> - c 9 0 2, 3 0 2, 6 0 0</span></span><br><span class="line"><span class="comment"> - d 2 2 2, 2 1 1, 0 1 1</span></span><br><span class="line"><span class="comment"> - e 4 3 3, 0 0 2, 4 3 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"一共有几个进程："</span>);</span><br><span class="line">pcb_nums = in.nextInt();</span><br><span class="line">System.out.println(<span class="string">"一共有几个资源"</span>);</span><br><span class="line">res_nums = in.nextInt();</span><br><span class="line">pcbs = <span class="keyword">new</span> Proc[pcb_nums];  <span class="comment">// 创建进程数组</span></span><br><span class="line">ava = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];     <span class="comment">// 可用资源</span></span><br><span class="line">safe_seq = <span class="keyword">new</span> <span class="keyword">char</span>[pcb_nums];  <span class="comment">// 安全序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcbs.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">max = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];     <span class="comment">// 最大资源</span></span><br><span class="line">alloc = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];   <span class="comment">// 拥有资源</span></span><br><span class="line">need = <span class="keyword">new</span> <span class="keyword">int</span>[res_nums];    <span class="comment">// 需要资源</span></span><br><span class="line">System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">System.out.println(<span class="string">"输入第"</span> + (i+<span class="number">1</span>) + <span class="string">"个进程信息(名字-最大资源-拥有资源)"</span>);</span><br><span class="line">System.out.println(<span class="string">"名字："</span>);</span><br><span class="line"><span class="keyword">char</span> name = in.next().charAt(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">"最大资源："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">&#123;</span><br><span class="line">max[j] = in.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"拥有资源："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">&#123;</span><br><span class="line">alloc[j] = in.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">&#123;</span><br><span class="line">need[j] = max[j] - alloc[j];</span><br><span class="line">&#125;</span><br><span class="line">pcbs[i] = <span class="keyword">new</span> Proc(name, max, alloc, need);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"---可用资源---："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">&#123;</span><br><span class="line">ava[j] = in.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algori</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> safe_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(safe_count != pcb_nums)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcb_nums; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcbs[i].finish_status == <span class="keyword">false</span>) <span class="comment">// 判断该pcb是否完成</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> now_res = pcbs[i].getNeed_res()[j];</span><br><span class="line"><span class="keyword">if</span> (now_res &lt;= ava[j])</span><br><span class="line">&#123;</span><br><span class="line">pcbs[i].finish_status = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pcbs[i].finish_status = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcbs[i].finish_status) <span class="comment">// 如果该pcb可以完成，则完成后回收资源</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res_nums; j++)</span><br><span class="line">&#123;</span><br><span class="line">ava[j] += pcbs[i].getNeed_res()[j];</span><br><span class="line">&#125;</span><br><span class="line">safe_seq[safe_count] = pcbs[i].getName();</span><br><span class="line">safe_count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcb_nums; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcbs[i].finish_status)</span><br><span class="line">&#123;</span><br><span class="line">safe_stauts = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">safe_stauts = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!safe_stauts) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (safe_stauts) &#123;</span><br><span class="line">System.out.println(<span class="string">"该系统安全，安全序列为："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pcb_nums; i++) &#123;</span><br><span class="line">System.out.print(safe_seq[i]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"该系统不安全"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BankRR test = <span class="keyword">new</span> BankRR();</span><br><span class="line">test.bank_init();</span><br><span class="line">test.algori();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><p>进程样例如下：<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/1.png" alt><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">一共有几个进程：</span><br><span class="line">5</span><br><span class="line">一共有几个资源</span><br><span class="line">3</span><br><span class="line">-----------------------</span><br><span class="line">输入第1个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">a</span><br><span class="line">最大资源：</span><br><span class="line">7 5 3</span><br><span class="line">拥有资源：</span><br><span class="line">0 1 0</span><br><span class="line">-----------------------</span><br><span class="line">输入第2个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">b</span><br><span class="line">最大资源：</span><br><span class="line">3 2 2</span><br><span class="line">拥有资源：</span><br><span class="line">2 0 0</span><br><span class="line">-----------------------</span><br><span class="line">输入第3个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">c</span><br><span class="line">最大资源：</span><br><span class="line">9 0 2</span><br><span class="line">拥有资源：</span><br><span class="line">3 0 2</span><br><span class="line">-----------------------</span><br><span class="line">输入第4个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">d</span><br><span class="line">最大资源：</span><br><span class="line">2 2 2</span><br><span class="line">拥有资源：</span><br><span class="line">2 1 1</span><br><span class="line">-----------------------</span><br><span class="line">输入第5个进程信息(名字-最大资源-拥有资源)</span><br><span class="line">名字：</span><br><span class="line">e</span><br><span class="line">最大资源：</span><br><span class="line">4 3 3</span><br><span class="line">拥有资源：</span><br><span class="line">0 0 2</span><br><span class="line">---可用资源---：</span><br><span class="line">3 3 2</span><br><span class="line">该系统安全，安全序列为：</span><br><span class="line">b d e a c</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;银行家算法是一种避免进程发生&lt;strong&gt;死锁&lt;/strong&gt;的算法。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;死锁的定义：&lt;br&gt;如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么改组进程是死锁的(Deadlock)&lt;br&gt;在死锁避免方法中，把系统的状态分为&lt;strong&gt;安全状态&lt;/strong&gt;和&lt;strong&gt;不安全状态&lt;/strong&gt;。&lt;br&gt;安全状态和不安全状态：&lt;br&gt;是指系统能按某种进程推进顺序&lt;script type=&quot;math/tex&quot;&gt;\left ( P_{1},P_{2}, ...,P_{n}\right )&lt;/script&gt; 为每个进程&lt;script type=&quot;math/tex&quot;&gt;P_{i}&lt;/script&gt;分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。并称&lt;script type=&quot;math/tex&quot;&gt;\left ( P_{1},P_{2}, ...,P_{n}\right )&lt;/script&gt;为安全序列。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.skecis.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://www.skecis.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://www.skecis.top/tags/Java/"/>
    
      <category term="进程死锁" scheme="http://www.skecis.top/tags/%E8%BF%9B%E7%A8%8B%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>用python实现链式队列</title>
    <link href="http://www.skecis.top/2019/11/08/python%E9%98%9F%E5%88%97/"/>
    <id>http://www.skecis.top/2019/11/08/python队列/</id>
    <published>2019-11-08T04:55:07.000Z</published>
    <updated>2019-12-15T08:35:58.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列也是一种线性的数据结构，和栈相反的是，队列是一种<strong>先进先出</strong>的线性表。它只允许在表的一端进行插入，而在另一端进行删除元素。与我们现实生活中的排队是一样的：排在队伍最前面的会先完成事情离开队伍。<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%98%9F%E5%88%97/1_1.png" alt><br>在数据结构中抽象为一种<strong>线性链表</strong>，如下所示<br><img src="https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%98%9F%E5%88%97/1_2.png" alt></p><a id="more"></a><h2 id="链式队列基本数据结构"><a href="#链式队列基本数据结构" class="headerlink" title="链式队列基本数据结构"></a>链式队列基本数据结构</h2><p>链式队列即是链表构成，通过指针相连。实现过程如下</p><h3 id="链式队列基本单元-节点-Node"><a href="#链式队列基本单元-节点-Node" class="headerlink" title="链式队列基本单元: 节点(Node)"></a>链式队列基本单元: 节点(Node)</h3><p>创建<code>Node</code>类</p><ul><li>值域</li><li>指针域</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param v: the value of node</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.value = v</span><br><span class="line">        self.pnext = None  # the pointer to point next</span><br></pre></td></tr></table></figure><h3 id="链式队列类"><a href="#链式队列类" class="headerlink" title="链式队列类"></a>链式队列类</h3><p>创建<code>LinkedQueue</code>类</p><ul><li>front: 队头节点</li><li>rear: 队尾节点</li><li>length: 队列长度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class LinkedQueue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.front = None  # the head node of queue</span><br><span class="line">        self.rear = None   # the rear node of queue</span><br><span class="line">        self.length = 0    # the length of queue</span><br></pre></td></tr></table></figure><h2 id="链式队列操作函数"><a href="#链式队列操作函数" class="headerlink" title="链式队列操作函数"></a>链式队列操作函数</h2><p><code>self</code>参数为对象本身，类似于C++中的<code>this</code>指针</p><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><p>创建<code>queue_empty</code>函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def queue_empty(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if the queue is empty</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.front is None:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p><h3 id="获取队首元素"><a href="#获取队首元素" class="headerlink" title="获取队首元素"></a>获取队首元素</h3><p>创建<code>get_head</code>函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def get_head(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    get the value of head node</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return self.front.value</span><br></pre></td></tr></table></figure></p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>创建<code>enqueue</code>函数</p><ul><li>val: 节点值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def enqueue(self, val):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    insert value to queue&apos;s rear</span><br><span class="line">    :param val:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.queue_empty():</span><br><span class="line">        self.front = Node(val)</span><br><span class="line">        self.rear = self.front</span><br><span class="line">        self.length += 1</span><br><span class="line">    else:</span><br><span class="line">        self.rear.pnext = Node(val)</span><br><span class="line">        self.rear = self.rear.pnext</span><br><span class="line">        self.length += 1</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>创建<code>dequeue</code>函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def dequeue(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    delete the value of head node and return its value</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not self.queue_empty():</span><br><span class="line">        val = self.front.value</span><br><span class="line">        self.front = self.front.pnext</span><br><span class="line">        self.length -= 1</span><br><span class="line">        return val</span><br></pre></td></tr></table></figure></p><h3 id="遍历队列-队首-队尾"><a href="#遍历队列-队首-队尾" class="headerlink" title="遍历队列(队首-队尾)"></a>遍历队列(队首-队尾)</h3><p>创建<code>queue_traverse</code>函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def queue_traverse(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    traverse the queue</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&apos;队头-&gt;|&apos;, end=&apos; &apos;)</span><br><span class="line">    tmp = self.front</span><br><span class="line">    while tmp:</span><br><span class="line">        print(tmp.value, &apos;|&apos;, end=&apos; &apos;)</span><br><span class="line">        tmp = tmp.pnext</span><br><span class="line">    print(&quot;\n&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>创建程序入口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    my_queue = LinkedQueue()</span><br><span class="line">    my_queue.enqueue([1, 2, 3])</span><br><span class="line">    my_queue.enqueue(456)</span><br><span class="line">    my_queue.enqueue(&apos;hello&apos;)</span><br><span class="line">    my_queue.queue_traverse()</span><br><span class="line">    my_queue.dequeue()</span><br><span class="line">    my_queue.queue_traverse()</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">队头-&gt;| [1, 2, 3] | 456 | hello |</span><br><span class="line"></span><br><span class="line">队头-&gt;| 456 | hello |</span><br></pre></td></tr></table></figure></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/SkecisAI/python-DS/blob/master/linked_queue.py" target="_blank" rel="noopener">点击此处访问</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;p&gt;队列也是一种线性的数据结构，和栈相反的是，队列是一种&lt;strong&gt;先进先出&lt;/strong&gt;的线性表。它只允许在表的一端进行插入，而在另一端进行删除元素。与我们现实生活中的排队是一样的：排在队伍最前面的会先完成事情离开队伍。&lt;br&gt;&lt;img src=&quot;https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%98%9F%E5%88%97/1_1.png&quot; alt&gt;&lt;br&gt;在数据结构中抽象为一种&lt;strong&gt;线性链表&lt;/strong&gt;，如下所示&lt;br&gt;&lt;img src=&quot;https://skecis-blog-1300426987.cos.ap-chengdu.myqcloud.com/blog_images/python%E9%98%9F%E5%88%97/1_2.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.skecis.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Python" scheme="http://www.skecis.top/tags/Python/"/>
    
      <category term="队列" scheme="http://www.skecis.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
